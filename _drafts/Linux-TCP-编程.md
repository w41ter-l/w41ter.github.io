---
title: Linux TCP 编程
date: 2017-05-26 18:28:19
tags: 
    - Linux 
    - Socket
    - TCP/IP

---

TCP(Transmission Control Protocol) 是由 IETF 的 RFC 793 定义的一种**面向连接的、可靠的、基于字节流的**传输层通信协议。

# TCP 报文段

TCP 数据被封装在一个 IP 数据报中，如下图所示：

![TCP数据在IP数据报中的封装](https://www.hashcoding.net/uploads/images/2017/5/TCP%E5%9C%A8IP%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85.png)

下图是 TCP 首部的数据格式，如果不计任选字段，它通常是20个字节：

![TCP包首部](https://www.hashcoding.net/uploads/images/2017/5/TCP包首部.png)

下面介绍重要的几个数据：

- 32位序号：表示数据当前发送的第一个字节在字节流中的序号
- 32位确认号：表示发送端所期望收到的下一个序号，因此该序号位上一次收到的序号加一
- 6个特殊标志bit: (按照排列顺序)
    - URG: 紧急指针有效
    - ACK：确认序号有效
    - PSH：接收方应该尽快将这个报文段交给应用层
    - RST：重建连接
    - SYN：同步序号，用来发起一个连接
    - FIN：发送端完成任务，关闭发送端到接收端连接

其余的解释请参考 TCP/IP 协议详解。

# TCP 连接的状态图

![TCP状态图](https://www.hashcoding.net/uploads/images/2017/5/TCP状态转换.png)

# TCP 连接的建立与终止

TCP 是一个**面向连接的**通信协议，这要求通信双方在进行通信之前，需要先建立其连接。在常见的客户端、服务器模式的程序中，通常是服务器绑定端口，并在该端口上监听客户端连接请求；客户端主动向服务器发起连接请求，待服务器响应后，双方建立起一条通信链路。

## 建立

TCP 连接建立时通信双方的分组报文如下图所示：

![TCP 三路握手](https://www.hashcoding.net/uploads/images/2017/5/TCP三路握手.png)

如图所示，客户端发起 `connect`，此时客户端发送 `SYN` 报文；服务端使用 `accept` 接受该连接请求，同时反馈 `SYN` 和 `ACK`；等到客户端相应了 `ACK`后，双方建立起完整连接。

将上述过程映射到 TCP 状态图上进行观察，在服务器端：

- 刚开始服务器处于 `CLOSED` 状态
- 服务器初始化时绑定了具体的端口，并使用 `listen` 监听该端口，进入了 `LISTEN` 状态
- 服务端接收到了来自客户端的 `SYN` 请求，发送 `SYN` 和 `ACK` 给客户端，然后进入 `SYN_RCVD` 状态
- 当服务端接收到了客户端紧接着到达的 `ACK` 时，进入 `ESTABLISHED` 状态

客户端方面：

- 刚开始同样处于 `CLOSED` 状态
- 应用主动调用 `CONNECT` 发起连接，发送 `SYN` 给服务器，然后进入 `SYN_SEND` 状态
- 当接受到服务器的 `SYN` 和 `ACK` 后，发送对应的 `ACK` 给服务器，并进入 `ESTABLISHED` 状态

当双方都进入 `ESTABLISHED` 状态时，表示连接已经建立成功。

当然，客户端在发送了 `SYN` 后，等待超时，并重试几次后，便会触发 `Timeout` 进入 `CLOSED`，在应用层则表示为 `connect` 失败。

## 同时建立连接

与常见的模式不同的是，TCP 允许连接双方同时发起建立连接的请求。此时分组报文如下图所示：

![TCP同时建立连接](https://www.hashcoding.net/uploads/images/2017/5/TCP同时建立连接.png)

连接双方同时发送 `SYN` 到对方，然后同样地返回 `SYN` 和 `ACK` 给对方。将该过程对应到状态图中：

- 刚开始同样处于 `CLOSED` 状态
- 应用主动调用 `CONNECT` 发起连接，发送 `SYN` 给服务器，然后进入 `SYN_SEND` 状态
- 接收到 `SYN` 后进入 `SYN-RCVD` 状态
- 接收到 `ACK` 后建立连接，进入 `ESTABLISHED` 状态

## 关闭连接

`FIN` 用于通知对方关闭本方向的连接。由于 TCP 是一个**全双工的**通信协议，像管道一样，支持关闭某一方向上的连接，所以在 TCP 中关闭连接需要双方都发送 `FIN` 报文。此时分组报文如下图所示：

![TCP关闭时的分组交换](https://www.hashcoding.net/uploads/images/2017/5/TCP关闭时的分组交换.png)

当某一方关闭连接时，发送 `FIN` 给另一方，对方回复 `ACK` 后，同时也发送 `FIN`；等到双方都收到最后的 `ACK` 后，连接关闭。当然，**如果另一方只回复了 `ACK` 而没有发起 `FIN`，则表示对方仍然想要发送数据，这种情况称为 TCP 的半关闭**。只有当双方都发送了 `FIN` 并接收到对方的 `ACK` 后，才算真正的连接关闭。所以上图中 Server 端的 `FIN` 包可以在接收到 Client 的 `FIN` 包后，隔一段时间再发送。

在状态图中对应了主动关闭和被动关闭，首先观察主动关闭：

- 当应用使用 `close` 后，发送 `FIN` 给对方，并由 `ESTABLISHED` 状态进入 `FIN_WAIT_1` 状态
- 如果收到 `ACK` 后，进入 `FIN_WAIT_2` 状态
- 此时等待对方的 `FIN` 到达，并发送 `ACK` 给对方，进入 `TIME_WAIT` 状态
- 如果在 `FIN_WAIT_1` 状态直接接收到 `FIN` 和 `ACK`，则直接进入 `TIME_WAIT` 状态
- `TIME_WAIT` 状态等待了 2 MSL 后，进入 `CLOSED` 状态，此时连接关闭

被动关闭则简单得多：

- 当收到对方的 `FIN` 后，发送 `ACK` 并由 `ESTABLISHED` 进入 `CLOSE_WAIT` 状态
- 等到用户层发出 `close` 后，发送 `FIN` 同时进入 `LAST_ACK` 状态
- 等到接收到对方的 `ACK` 后，进入 `CLOSED` 状态，连接关闭

`TIME_WAIT` 状态可能时状态图中最不易懂的地方，它也被称为 `2 MSL` 状态。每一个具体 TCP 实现必须选择一个报文段最大生存时间 MSL(Maximum Segment Lifetime)，表示任何报文段被丢弃前能在网络中存货的时间。当 TCP 执行主动关闭并发送了 `ACK` 给对方进入 `TIME_WAIT` 状态后，该连接必须在 `TIME_WAIT` 状态停留 2 倍的 MSL 。这样可以保证 TCP 在超时后再次发送最后的 `ACK` 以防止这个 `ACK` 丢失。使用 2 MSL 的另外一点是，当前的 `socket` 关闭后，可能立即被用于建立另一个 TCP 连接，而网络中可能存在着尚未到达具有 `TIME_WAIT` 状态一方的包，需要保证这些包不会影响到接下来即将建立的连接。2 MSL 的时间间隔中不允许 `socket` 被重新使用，同时也能够保证消耗掉网络中的包。所以 `TIME_WAIT` 状态存在有两个理由：

- 可靠地实现 TCP 全双工连接的终止
- 允许老的重复的包在网络中消逝

## 同时关闭

如 TCP 同时打开一样，TCP 也存在同时关闭状态，此时双方均进入 `FIN_WAIT_1` 状态，并再接收到 `FIN` 后进入 `CLOSING` 状态。等到接收到 `ACK` 后，则进入 `TIME_WAIT` 状态。

## TCP 复位

在 TCP 首部中 `RST` 位表示表示复位，用来异常的关闭连接，在 TCP 的设计中它是不可或缺的。发送 `RST` 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送 `RST` 包。而接收端收到 `RST` 包后，也不必发送 `ACK` 包来确认。TCP 处理程序会在自己认为的异常时刻发送 `RST` 包。 

下面来分析一下 TCP 中 `RST` 包出现的主要场景。

### 到不存在的端口的连接请求

产生复位的一种常见情况是当连接请求到达时，目的端口没有进程在监听。例如，A 向 B 发起连接，但 B 之上并未监听相应的端口，这时 B 操作系统上的 TCP 处理程序会发 `RST` 包。

### 异常终止一个连接

终止一个连接的正常方式是一方发送 `FIN`，这也成为有序释放，因为在所有排队数据都已经发送之后才发送 `FIN` ，正常情况下没有数据丢失。但是也可以使用 `RST` 来直接释放一个连接，这种方式称为异常释放。使用异常终止有两个有点：
 
- 丢弃任何待发送数据并立即发送复位报文段
- `RST` 的接收方会区分另一端是异常还是正常关闭

### 检测半打开连接

如果一方已经关闭或异常终止而另一方还不知道，这样的 TCP 连接被称为**半打开**的。比如系统断电而不是正常结束就可能造成半打开的连接。如果发生异常的一方重启后重新连接到远程服务，则会发生错误，此时远程服务器会发送 `RST` 关闭此连接。比如，AB 正常建立连接了，正在通讯时，A 向 B 发送了 `FIN` 包要求关连接，B 发送 `ACK` 后，网断了，A 通过若干原因放弃了这个连接（例如进程重启）。网通了后，B 又开始发数据包，A 收到后表示压力很大，不知道这野连接哪来的，就发了个 `RST` 包强制把连接关了，B 收到后会出现 `connect reset by peer` 错误。

# References

1. [TCP - Wikis](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE) 
2. TCP/IP 详解 卷一：协议
3. UNIX 网络编程 卷一：