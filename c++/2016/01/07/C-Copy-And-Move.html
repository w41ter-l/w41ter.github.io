<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>C++0x:Copy And Move | W41ter’s Bistro</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="C++0x:Copy And Move" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="C++ 提供了5种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁，统称为拷贝控制操作(copy control)。这几个函数分别是拷贝构造函数(copy constructor)、拷贝赋值运算符(copy assignment operator)、移动构造函数(move constructor)、移动复制运算符(move assignment operator)和析构函数(destructor)。" />
<meta property="og:description" content="C++ 提供了5种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁，统称为拷贝控制操作(copy control)。这几个函数分别是拷贝构造函数(copy constructor)、拷贝赋值运算符(copy assignment operator)、移动构造函数(move constructor)、移动复制运算符(move assignment operator)和析构函数(destructor)。" />
<link rel="canonical" href="/c++/2016/01/07/C-Copy-And-Move.html" />
<meta property="og:url" content="/c++/2016/01/07/C-Copy-And-Move.html" />
<meta property="og:site_name" content="W41ter’s Bistro" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-01-07T20:53:51+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="C++0x:Copy And Move" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-01-07T20:53:51+08:00","datePublished":"2016-01-07T20:53:51+08:00","description":"C++ 提供了5种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁，统称为拷贝控制操作(copy control)。这几个函数分别是拷贝构造函数(copy constructor)、拷贝赋值运算符(copy assignment operator)、移动构造函数(move constructor)、移动复制运算符(move assignment operator)和析构函数(destructor)。","headline":"C++0x:Copy And Move","mainEntityOfPage":{"@type":"WebPage","@id":"/c++/2016/01/07/C-Copy-And-Move.html"},"url":"/c++/2016/01/07/C-Copy-And-Move.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="W41ter's Bistro" /><!-- for mathjax support -->
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">W41ter&#39;s Bistro</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">C++0x:Copy And Move</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-01-07T20:53:51+08:00" itemprop="datePublished">Jan 7, 2016
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>C++ 提供了5种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁，统称为<em>拷贝控制操作(copy control)</em>。这几个函数分别是<em>拷贝构造函数(copy constructor)</em>、<em>拷贝赋值运算符(copy assignment operator)</em>、<em>移动构造函数(move constructor)</em>、<em>移动复制运算符(move assignment operator)</em>和<em>析构函数(destructor)</em>。</p>

<!-- more -->

<h2 id="拷贝构造函数">拷贝构造函数</h2>

<p>如果一个构造函数的第一个参数是自身类型的引用，且任何额外的参数都有默认值，则此函数是<em>拷贝构造函数</em>。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class test {
public:
  test(const test&amp;);  // copy constructor
};
</code></pre></div></div>

<p>如果我们没有为一个类定义<em>拷贝构造函数</em>，编译器会为我们定义一个<em>合成拷贝构造函数(synthesized copy constructor)</em>。对于<em>合成拷贝构造函数</em>，在发生拷贝时，每个成员的类型会决定其拷贝方式，类成员使用其拷贝构造函数，内置类型成员直接拷贝，数组会逐个元素地拷贝。</p>

<h2 id="拷贝构造时机">拷贝构造时机</h2>

<p>对于没有进行函数调用的初始化，如果使用等号(=)初始化一个变量，则实际上执行的是<em>拷贝初始化(copy initialization)</em>，如果不使用等号，则执行<em>直接初始化(direct initialization)</em>。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string s1("direct initialization");
string s2(s1);    // direct initialization
string s3 = "copy initialization"; 
string s4 = s2;   // copy initialization
</code></pre></div></div>

<p>如果初始化中涉及到函数调用，那么在下列情况也会发生<em>拷贝初始化</em>：</p>

<ul>
  <li>将一个对象作为实参传递给一个非引用类型的形参</li>
  <li>从一个返回值类型为非引用类型的函数返回一个对象</li>
  <li>花括号列表初始化一个数组中的元素或者一个聚合类中的成员</li>
</ul>

<blockquote>
  <p>如果一个类满足下列条件，则称为聚合类：</p>

  <ul>
    <li>所有成员都是 <code class="language-plaintext highlighter-rouge">public</code>的</li>
    <li>没有定义任何构造函数</li>
    <li>没有类内初始值</li>
    <li>没有基类，也没有 <code class="language-plaintext highlighter-rouge">virtual</code> 函数</li>
  </ul>

  <p>对于聚合类，可以使用花括号括起来的成员初始值列表进行初始化：</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct data {
  int ival;
  string s;
};
data val = { 1, "string" };
</code></pre></div>  </div>
  <p>其中初始顺序必须和申明顺序一致，如果初始列表中的元素个数少于类成员的个数，则靠后的成员被值初始化。且初始化列表中的元素个数不能多于成员数量。</p>
</blockquote>

<p>需要注意的是，标准允许编译器在初始化过程中跳过<em>拷贝/移动构造函数</em>直接创建对象。</p>

<h2 id="拷贝赋值运算符">拷贝赋值运算符</h2>

<p><em>拷贝赋值运算符</em>接受一个与其所在类型相同的参数。如果没有定义其<em>拷贝赋值运算符</em>，编译器会为它生成一个<em>合成拷贝赋值运算符(synthesized copy assignment operator)</em>。</p>

<h2 id="安全的拷贝赋值运算符">安全的拷贝赋值运算符</h2>

<p>编写拷贝赋值运算符时，有两点需要注意：1、自我拷贝 2、异常安全。下面精心构造的例子可以说明这些问题：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Bitmap { };
class Widget {
  Bitmap *pb;
  
public:
  Widget(Bitmap *p) : pb(p) {}
  
  Widget &amp;operator = (const Widget &amp;rhs) {
    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
  }
};
</code></pre></div></div>

<p>假设有某用户创建一个对象后对自己进行赋值：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bitmap *b;
Widget w(b);
w = w;  // error;
</code></pre></div></div>

<p>或者编写 <code class="language-plaintext highlighter-rouge">Bitmap</code> 的设计者在内存不足时抛出异常：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Bitmap {
public:
  Bitmap(const Bitmap&amp; obj) {
    throw ...
  }
};
</code></pre></div></div>

<p>那么在 <code class="language-plaintext highlighter-rouge">new Bitmap</code> 操作失败，而原来的备份也被删除。</p>

<p>简单的解决方案是将<em>拷贝复制运算符</em>实现代码进行如下修改：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Widget &amp;operator = (const Widget &amp;rhs) {
  Bitmap *old = pb;
  pb = new Bitmap(*rhs.pb);
  delete old;
  return *this;
}
</code></pre></div></div>

<p>这样的代码首先保证了异常安全，并且顺带解决了自我赋值(拷贝了一份原来的数据)。另一个替代方案是 <em>copy and swap</em> 技术：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Widget &amp;operator = (Widget rhs) {
  this-&gt;swap(rhs);
  return *this;
}
</code></pre></div></div>

<p>其中假设 <code class="language-plaintext highlighter-rouge">swap</code> 函数不会抛出异常。这种方法利用以下依据：</p>

<ul>
  <li>某 class 的 copy assignment 操作可能被申明为 “以 by value 方式接受实参”</li>
  <li>以 by value 方式传递东西会造成一件副本</li>
</ul>

<p>这种方法将 “copying” 动作从函数本体内移到 <em>函数参数构造阶段</em>。</p>

<h2 id="对象移动">对象移动</h2>

<p>对于某些场景，比如 <code class="language-plaintext highlighter-rouge">vector&lt;string&gt;</code> 增长时，将旧元素拷贝到新内存是不必要的，而某些对象如 IO 类或 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 则不能拷贝。为了解决这些问题，新标准引入了移动语义 - <em>右值引用(rvalue reference)</em>。</p>

<h2 id="右值引用">右值引用</h2>

<p>所谓右值引用就是必须绑定到右值的引用，类似于任何引用，一个右值引用也不过是某个对象的另一个名字。左值和右值都是针对表达式而言的，左值是指表达式结束后依然存在的持久对象，右值是指表达式结束时就不再存在的临时对象。一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。左值有持久状态，而右值要么是字面常量，要么是表达式求值过程中创建的临时对象，所以使用右值引用可以自由的接管所引用对象的资源。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int i = 1;
int &amp;&amp;rr = i * 2;
</code></pre></div></div>
<p>基于可以看作是将 <code class="language-plaintext highlighter-rouge">i * 2</code> 产生的临时变量绑定到 <code class="language-plaintext highlighter-rouge">rr</code> 上。而这里的 <code class="language-plaintext highlighter-rouge">rr</code> 是右值引用，但其却是一个变量，对于这种情况，标准中提到：</p>

<blockquote>
  <p>Things that are declared as rvalue reference can be lvalues or rvalues. The distinguishing criterion is: if it has a name, then it is an lvalue. Otherwise, it is an rvalue.</p>
</blockquote>

<p>所以， <code class="language-plaintext highlighter-rouge">rr</code> 也是一个左值。这里也就是所谓的绑定到右值的引用。理解右值引用是理解移动语义的基础。</p>

<h2 id="移动构造函数和移动赋值操作符">移动构造函数和移动赋值操作符</h2>

<p>类似于<em>拷贝构造函数</em>，<em>移动构造函数</em>第一个参数必须是该类型的一个右值引用，其余参数都必须有默认实参。而<em>移动赋值操作符</em>则是接受本类型的右值。需要注意的是使用移动语义后必须保证源对象处于销毁无害的状态，即该对象拥有的资源转移给了赋值对象。所以一般的移动构造函数都会将原对象的指针等设置为 <code class="language-plaintext highlighter-rouge">nullptr</code>。</p>

<p>在移动操作中允许抛出异常，但是通常不会抛出异常。而标准容器库能对异常发生时其自身的行为提供保障，所以如果元素的移动构造函数没有 <code class="language-plaintext highlighter-rouge">noexcept</code> 修饰时，容器库在从新分配内存时会选择<em>拷贝构造函数</em>而不是<em>移动构造函数</em>。因此，如无必要，移动构造函数应当加 <code class="language-plaintext highlighter-rouge">noexcept</code> 修饰。</p>

<p>需要注意到的是合成版本的<em>移动构造函数</em>和<em>移动赋值操作符</em>合成条件比较多，这里没有涉及。如果一个类定义了右值构造，那么我们可以通过给它传递右值参数调用其移动构造函数。如果想要对左值也进行移动，这需要进行转义。这种转义可以看作 <code class="language-plaintext highlighter-rouge">static_cast&lt;T&amp;&amp;&gt;(lvalue);</code>，在标准中由 <code class="language-plaintext highlighter-rouge">std::move(lvaule)</code> 提供支持。值得一提的是，被转化的左值，其生命期并没有随着左右值的转化而改变。也就是说，其实仍然是左值，只是变相调用了移动语义。这也是前面之所以强调的<em>必须保证源对象处于销毁无害的状态</em>。所以调用 <code class="language-plaintext highlighter-rouge">move</code> 就意味着承诺：*除了对 <code class="language-plaintext highlighter-rouge">lvalue</code> 进行赋值或者销毁它以外，我们将不在使用它`。</p>

<h2 id="成员函数与右值">成员函数与右值</h2>

<p>与 <code class="language-plaintext highlighter-rouge">const</code> 修饰的成员函数一致，我们可以在参数列表后放置一个<em>引用限定符(reference qualifier)</em>来指定调用者是左值还是右值。引用限定符可以是 &amp; 或 &amp;&amp;，分别指出 <code class="language-plaintext highlighter-rouge">this</code> 可以指向一个左值或者右值。如果一个函数已经有 <code class="language-plaintext highlighter-rouge">const</code> 修饰，那么引用修饰必须出现在其后面的位置。</p>

<h2 id="小结">小结</h2>

<p>通过以上内容可以看到，C++的许多灵活性来自于其强大的类型系统和精巧的设计理念。</p>

  </div><a class="u-url" href="/c++/2016/01/07/C-Copy-And-Move.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">W41ter&#39;s Bistro</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">W41ter&#39;s Bistro</li><li><a class="u-email" href="mailto:w41ter.l@gmail.com">w41ter.l@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/w41ter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">w41ter</span></a></li><li><a href="https://www.twitter.com/WalterM56697798"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WalterM56697798</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Focus on distributed storage system, compiler.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
