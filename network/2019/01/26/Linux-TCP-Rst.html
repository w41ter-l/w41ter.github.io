<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>探究 Linux 下 TCP 的 RST Packet | W41ter’s Bistro</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="探究 Linux 下 TCP 的 RST Packet" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="注：本文结论来自网络，真实性未考究，请批判性阅读，如果谬误，请斧正。本文所讨论内容，均假设工作环境为 Linux 服务器。 作为 TCP 不可或缺的一部分，TCP 包头的 RST 为 $1$ 时，表示重置，关闭异常链接。发送 RST 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送 RST 包。而接收端收到 RST 包后，也不必发送 ACK 包来确认。TCP 处理程序会在自己认为的异常时刻发送 RST 包。 14:59:23.379829 IP localhost.62412 &gt; localhost.9490: Flags [R], seq 4127385762, win 0, length 0 通过 tcpdump 观察，Flags [R] 表示该包携带了 RST 。 RST 主要用在三种场景中，保证 TCP 链接的安全性，三种场景分别是：1、到不存在端口的连接请求；2、异常终止连接；3、检测半打开连接。接下来看看 RST 的具体表现。 三种错误 内核中的 TCP 协议栈将收到 RST 的场景分为三种，并抛出了对应的错误。 connection refused 当内核中的 TCP 协议栈收到了 SYN 请求，但是该端口上没有处于监听状态，则相应 RST，此时 client 看到的便是 connection refused。 broken pipe fd is connected to a pipe or socket whose reading end is closed. When this happens the writing process will also receive a SIGPIPE signal.(Thus, the write return value is seen only if the program catches, blocks or ignores this signal.) 简单的说，如果已知远端读通道已经被关闭，而应用程序仍然在调用 write(2) 尝试向 socket 中写入数据，TCP 协议栈便会抛出 broken pipe。 connection reset by peer A network connection was closed for reasons outside the control of the local host, such as by the remote machine rebooting or an unrecoverable protocol violation. 如果远端已经 close(2) 连接了，本地服务仍发送了数据，此时 TCP 协议栈便会抛出 connection reset by peer。 broken pipe 和 connection reset by peer 无论是 broken pipe 还是 connection reset by peer，都是收到 RST 的表现，二者有何不同呢？ 为了进一步研究，这里尝试着构建两个场景，分别重现 broken pipe 和 connection reset by peer。 重现 broken pipe 首先，在服务中监听端口，每个连接分多次写入数据，然后关闭连接。 int server() { Acceptor acceptor = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4(&quot;127.0.0.1&quot;, 9490); acceptor.bind(address); acceptor.listen(10); const char *msg1 = &quot;hello&quot;, *msg2 = &quot;world&quot;; while (true) { Connection conn = acceptor.accept(); sleep(1); // wait client shutdown conn.write(msg1, strlen(msg1)); // write success, but RST recieved conn.write(msg2, strlen(msg2)); // throw `broken pipe` } // RAII close conn socket } // RAII close acceptor socket 然后客户端连接到服务端，并立即关闭连接。 int client() { Connector connector = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4(&quot;127.0.0.1&quot;, 9490); connector.connect(address); } // RAII close connector socket 通过 tcpdump 观察程序运行时请求： $ sudo tcpdump -i lo &#39;(src host 127.0.0.1) and (port 9490)&#39; -B 4096 14:59:13.376906 IP localhost.62412 &gt; localhost.9490: Flags [S], seq 4127385760, win 43690, options [mss 65495,sackOK,TS val 168040030 ecr 0,nop,wscale 10], length 0 14:59:13.376919 IP localhost.9490 &gt; localhost.62412: Flags [S.], seq 2306780414, ack 4127385761, win 43690, options [mss 65495,sackOK,TS val 168040030 ecr 168040030,nop,wscale 10], length 0 14:59:13.376928 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 1, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 0 14:59:13.377089 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 1:2, ack 1, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 1 14:59:13.377223 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 2, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 0 14:59:14.377352 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 2:3, ack 1, win 43, options [nop,nop,TS val 168040280 ecr 168040030], length 1 14:59:14.377439 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 3, win 43, options [nop,nop,TS val 168040280 ecr 168040280], length 0 // .... 14:59:22.379462 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 10:11, ack 1, win 43, options [nop,nop,TS val 168042281 ecr 168042031], length 1 14:59:22.379489 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 11, win 43, options [nop,nop,TS val 168042281 ecr 168042281], length 0 14:59:22.379626 IP localhost.62412 &gt; localhost.9490: Flags [F.], seq 1, ack 11, win 43, options [nop,nop,TS val 168042281 ecr 168042281], length 0 14:59:22.382190 IP localhost.9490 &gt; localhost.62412: Flags [.], ack 2, win 43, options [nop,nop,TS val 168042282 ecr 168042281], length 0 14:59:23.379808 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 11:12, ack 2, win 43, options [nop,nop,TS val 168042531 ecr 168042281], length 1 14:59:23.379829 IP localhost.62412 &gt; localhost.9490: Flags [R], seq 4127385762, win 0, length 0 上述 log 为实验过程中，和上面上面的代码略有出入。 可以观察到，client close(2)，发送了 FIN 给 server，并收到了 ACK。server 此时再次尝试 write(2)，便抛出了 broken pipe 异常。 int main(int argc, char** argv) { try { return server(); } catch (Exception&amp; e) { cout &lt;&lt; e.what() &lt;&lt; endl; return -1; } } server 调用方式。 SIGPIPE 与 broken pipe 按照预期，当 socket 抛出 broken pipe 时，会被最外层 try 和 catch 抓住，并输出。实际上运行结果为： $ ./server $ $ echo $? 141 $ 某次 server 端运行结果，没有任何输出，程序返回值为 $141$。 内核中 TCP 栈如果已经接收到 RST，那么下一次使用 write(2) 时，除了会返回 broken pipe 外，还会产生 SIGPIPE，默认情况下这个信号会终止整个进程，当然你并不想让进程被 SIGPIPE 信号杀死。对 server 来说，为了不被 SIGPIPE 信号杀死，那就需要忽略 SIGPIPE 信号： signal(SIGPIPE, SIG_IGN); 最后，让我们整体分析下 broken pipe 产生方式： client 发送了 FIN 给 server； server 仍给 client 发送数据，client 回复 RST； server 收到 RST 后，再次给 client 发送数据；往一个已经收到 RST 的 socket 继续写入数据，将引起 SIGPIPE 信号，write(2) 返回 EPIPE。 重现 connection reset by peer int server() { Acceptor acceptor = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4(&quot;127.0.0.1&quot;, 9490); acceptor.bind(address); acceptor.listen(10); while (true) { Connection conn = acceptor.accept(); sleep(10); // 给拔网线留下足够的时间 } // RAII close conn socket } // RAII close acceptor socket 模拟服务端断线重启。 int client() { Connector connector = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4(&quot;127.0.0.1&quot;, 9490); connector.connect(address); sleep(120); const char *msg = &quot;hello&quot;; connector.write(msg, strlen(msg)); } // RAII close connector socket 一段时间后，再给服务器发送请求，此时服务器已经重启。 这里构造了这样一个场景，与客户端建立连接后，服务端由于不可抗力，比如断电，未能发送 FIN 给客户端。当服务器重启后，内核中 TCP 协议栈收到了客户端的数据包，回应 RST，此时客户端抛出 connection reset by peer。 $ sudo tcpdump -i lo &#39;(src host 127.0.0.1) and (port 9490)&#39; -B 4096 15:43:12.638464 IP localhost.21316 &gt; localhost.9490: Flags [S], seq 3640034867, win 43690, options [mss 65495,sackOK,TS val 168699846 ecr 0,nop,wscale 10], length 0 15:43:12.638478 IP localhost.9490 &gt; localhost.21316: Flags [S.], seq 485213568, ack 3640034868, win 43690, options [mss 65495,sackOK,TS val 168699846 ecr 168699846,nop,wscale 10], length 0 15:43:16.639791 IP localhost.9490 &gt; localhost.21316: Flags [P.], seq 5:6, ack 6, win 43, options [nop,nop,TS val 168700846 ecr 168700596], length 1 15:43:16.639807 IP localhost.21316 &gt; localhost.9490: Flags [.], ack 6, win 43, options [nop,nop,TS val 168700846 ecr 168700846], length 0 15:43:17.640127 IP localhost.9490 &gt; localhost.21316: Flags [P.], seq 6:7, ack 6, win 43, options [nop,nop,TS val 168701096 ecr 168700846], length 1 15:43:17.640137 IP localhost.21316 &gt; localhost.9490: Flags [.], ack 7, win 43, options [nop,nop,TS val 168701096 ecr 168701096], length 0 15:43:18.170130 IP localhost.9490 &gt; localhost.21316: Flags [R.], seq 7, ack 6, win 43, options [nop,nop,TS val 168701228 ecr 168701096], length 0 某次模拟 connection reset by peer。 这里从读写两个角度来看 RST，如果已经 ACK 远端的 FIN 包： read(2) ：返回 0，表示 eof； write(2) ：远端返回 RST，抛出 broken pipe； 如果尚未接收到远端的 FIN 包，无论读写操作，收到 RST 时，抛出 connection reset by peer。 what more ？ 除了上述几个场景外，还有其他可能吗？ 强行关闭 正常关闭 TCP 链接时，主动关闭一方会进入 TIME_WAIT 状态，等待 2MSL（报文段最大生存时间-Maximum Segment Lifetime，根据具体的实现不同，这个值会不同），此时该端口处于不可用状态。 解决 TIME_WAIT 有三种手段： 设置 SO_REUSEADDR 和 SO_REUSEPORT； 修改 TIME_WAIT 等待时长； 设置 SO_LINGER，强行关闭。 设置 socket 选项 SO_LINGER 为 (on, 0) 后，close(2) 将立即向对端发送 RST，这种关闭方式称为“强行关闭”。而被动关闭方却不知道对端已经彻底断开，所以紧接着的读写操作，引发 connection reset by peer。 数据滞留 socket 关闭时，如果接收窗口仍有数据滞留，那么会直接发送 RST ，不会进入正常的 FIN 流程。可以参考：TCP RST: Calling close() on a socket with data in the receive queue。 和“强行关闭”一样，数据滞留也会导致被动关闭方引发 connection reset by peer，这样造成的结果是：如果你的服务各种指标正常，但是有非常多的 connection reset by peer 警告，可能就是服务上游超时 close(2) socket，而由于接收窗口仍有数据滞留，发送了 RST。 References [1] Linux TCP 编程 [2] 网络编程中 SIGPIPE 信号 [3] Linux 下 TCP 连接断开未发送 FIN [4] TCP关闭连接(为什么会能Time_wait,Close_wait?)" />
<meta property="og:description" content="注：本文结论来自网络，真实性未考究，请批判性阅读，如果谬误，请斧正。本文所讨论内容，均假设工作环境为 Linux 服务器。 作为 TCP 不可或缺的一部分，TCP 包头的 RST 为 $1$ 时，表示重置，关闭异常链接。发送 RST 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送 RST 包。而接收端收到 RST 包后，也不必发送 ACK 包来确认。TCP 处理程序会在自己认为的异常时刻发送 RST 包。 14:59:23.379829 IP localhost.62412 &gt; localhost.9490: Flags [R], seq 4127385762, win 0, length 0 通过 tcpdump 观察，Flags [R] 表示该包携带了 RST 。 RST 主要用在三种场景中，保证 TCP 链接的安全性，三种场景分别是：1、到不存在端口的连接请求；2、异常终止连接；3、检测半打开连接。接下来看看 RST 的具体表现。 三种错误 内核中的 TCP 协议栈将收到 RST 的场景分为三种，并抛出了对应的错误。 connection refused 当内核中的 TCP 协议栈收到了 SYN 请求，但是该端口上没有处于监听状态，则相应 RST，此时 client 看到的便是 connection refused。 broken pipe fd is connected to a pipe or socket whose reading end is closed. When this happens the writing process will also receive a SIGPIPE signal.(Thus, the write return value is seen only if the program catches, blocks or ignores this signal.) 简单的说，如果已知远端读通道已经被关闭，而应用程序仍然在调用 write(2) 尝试向 socket 中写入数据，TCP 协议栈便会抛出 broken pipe。 connection reset by peer A network connection was closed for reasons outside the control of the local host, such as by the remote machine rebooting or an unrecoverable protocol violation. 如果远端已经 close(2) 连接了，本地服务仍发送了数据，此时 TCP 协议栈便会抛出 connection reset by peer。 broken pipe 和 connection reset by peer 无论是 broken pipe 还是 connection reset by peer，都是收到 RST 的表现，二者有何不同呢？ 为了进一步研究，这里尝试着构建两个场景，分别重现 broken pipe 和 connection reset by peer。 重现 broken pipe 首先，在服务中监听端口，每个连接分多次写入数据，然后关闭连接。 int server() { Acceptor acceptor = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4(&quot;127.0.0.1&quot;, 9490); acceptor.bind(address); acceptor.listen(10); const char *msg1 = &quot;hello&quot;, *msg2 = &quot;world&quot;; while (true) { Connection conn = acceptor.accept(); sleep(1); // wait client shutdown conn.write(msg1, strlen(msg1)); // write success, but RST recieved conn.write(msg2, strlen(msg2)); // throw `broken pipe` } // RAII close conn socket } // RAII close acceptor socket 然后客户端连接到服务端，并立即关闭连接。 int client() { Connector connector = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4(&quot;127.0.0.1&quot;, 9490); connector.connect(address); } // RAII close connector socket 通过 tcpdump 观察程序运行时请求： $ sudo tcpdump -i lo &#39;(src host 127.0.0.1) and (port 9490)&#39; -B 4096 14:59:13.376906 IP localhost.62412 &gt; localhost.9490: Flags [S], seq 4127385760, win 43690, options [mss 65495,sackOK,TS val 168040030 ecr 0,nop,wscale 10], length 0 14:59:13.376919 IP localhost.9490 &gt; localhost.62412: Flags [S.], seq 2306780414, ack 4127385761, win 43690, options [mss 65495,sackOK,TS val 168040030 ecr 168040030,nop,wscale 10], length 0 14:59:13.376928 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 1, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 0 14:59:13.377089 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 1:2, ack 1, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 1 14:59:13.377223 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 2, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 0 14:59:14.377352 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 2:3, ack 1, win 43, options [nop,nop,TS val 168040280 ecr 168040030], length 1 14:59:14.377439 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 3, win 43, options [nop,nop,TS val 168040280 ecr 168040280], length 0 // .... 14:59:22.379462 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 10:11, ack 1, win 43, options [nop,nop,TS val 168042281 ecr 168042031], length 1 14:59:22.379489 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 11, win 43, options [nop,nop,TS val 168042281 ecr 168042281], length 0 14:59:22.379626 IP localhost.62412 &gt; localhost.9490: Flags [F.], seq 1, ack 11, win 43, options [nop,nop,TS val 168042281 ecr 168042281], length 0 14:59:22.382190 IP localhost.9490 &gt; localhost.62412: Flags [.], ack 2, win 43, options [nop,nop,TS val 168042282 ecr 168042281], length 0 14:59:23.379808 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 11:12, ack 2, win 43, options [nop,nop,TS val 168042531 ecr 168042281], length 1 14:59:23.379829 IP localhost.62412 &gt; localhost.9490: Flags [R], seq 4127385762, win 0, length 0 上述 log 为实验过程中，和上面上面的代码略有出入。 可以观察到，client close(2)，发送了 FIN 给 server，并收到了 ACK。server 此时再次尝试 write(2)，便抛出了 broken pipe 异常。 int main(int argc, char** argv) { try { return server(); } catch (Exception&amp; e) { cout &lt;&lt; e.what() &lt;&lt; endl; return -1; } } server 调用方式。 SIGPIPE 与 broken pipe 按照预期，当 socket 抛出 broken pipe 时，会被最外层 try 和 catch 抓住，并输出。实际上运行结果为： $ ./server $ $ echo $? 141 $ 某次 server 端运行结果，没有任何输出，程序返回值为 $141$。 内核中 TCP 栈如果已经接收到 RST，那么下一次使用 write(2) 时，除了会返回 broken pipe 外，还会产生 SIGPIPE，默认情况下这个信号会终止整个进程，当然你并不想让进程被 SIGPIPE 信号杀死。对 server 来说，为了不被 SIGPIPE 信号杀死，那就需要忽略 SIGPIPE 信号： signal(SIGPIPE, SIG_IGN); 最后，让我们整体分析下 broken pipe 产生方式： client 发送了 FIN 给 server； server 仍给 client 发送数据，client 回复 RST； server 收到 RST 后，再次给 client 发送数据；往一个已经收到 RST 的 socket 继续写入数据，将引起 SIGPIPE 信号，write(2) 返回 EPIPE。 重现 connection reset by peer int server() { Acceptor acceptor = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4(&quot;127.0.0.1&quot;, 9490); acceptor.bind(address); acceptor.listen(10); while (true) { Connection conn = acceptor.accept(); sleep(10); // 给拔网线留下足够的时间 } // RAII close conn socket } // RAII close acceptor socket 模拟服务端断线重启。 int client() { Connector connector = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4(&quot;127.0.0.1&quot;, 9490); connector.connect(address); sleep(120); const char *msg = &quot;hello&quot;; connector.write(msg, strlen(msg)); } // RAII close connector socket 一段时间后，再给服务器发送请求，此时服务器已经重启。 这里构造了这样一个场景，与客户端建立连接后，服务端由于不可抗力，比如断电，未能发送 FIN 给客户端。当服务器重启后，内核中 TCP 协议栈收到了客户端的数据包，回应 RST，此时客户端抛出 connection reset by peer。 $ sudo tcpdump -i lo &#39;(src host 127.0.0.1) and (port 9490)&#39; -B 4096 15:43:12.638464 IP localhost.21316 &gt; localhost.9490: Flags [S], seq 3640034867, win 43690, options [mss 65495,sackOK,TS val 168699846 ecr 0,nop,wscale 10], length 0 15:43:12.638478 IP localhost.9490 &gt; localhost.21316: Flags [S.], seq 485213568, ack 3640034868, win 43690, options [mss 65495,sackOK,TS val 168699846 ecr 168699846,nop,wscale 10], length 0 15:43:16.639791 IP localhost.9490 &gt; localhost.21316: Flags [P.], seq 5:6, ack 6, win 43, options [nop,nop,TS val 168700846 ecr 168700596], length 1 15:43:16.639807 IP localhost.21316 &gt; localhost.9490: Flags [.], ack 6, win 43, options [nop,nop,TS val 168700846 ecr 168700846], length 0 15:43:17.640127 IP localhost.9490 &gt; localhost.21316: Flags [P.], seq 6:7, ack 6, win 43, options [nop,nop,TS val 168701096 ecr 168700846], length 1 15:43:17.640137 IP localhost.21316 &gt; localhost.9490: Flags [.], ack 7, win 43, options [nop,nop,TS val 168701096 ecr 168701096], length 0 15:43:18.170130 IP localhost.9490 &gt; localhost.21316: Flags [R.], seq 7, ack 6, win 43, options [nop,nop,TS val 168701228 ecr 168701096], length 0 某次模拟 connection reset by peer。 这里从读写两个角度来看 RST，如果已经 ACK 远端的 FIN 包： read(2) ：返回 0，表示 eof； write(2) ：远端返回 RST，抛出 broken pipe； 如果尚未接收到远端的 FIN 包，无论读写操作，收到 RST 时，抛出 connection reset by peer。 what more ？ 除了上述几个场景外，还有其他可能吗？ 强行关闭 正常关闭 TCP 链接时，主动关闭一方会进入 TIME_WAIT 状态，等待 2MSL（报文段最大生存时间-Maximum Segment Lifetime，根据具体的实现不同，这个值会不同），此时该端口处于不可用状态。 解决 TIME_WAIT 有三种手段： 设置 SO_REUSEADDR 和 SO_REUSEPORT； 修改 TIME_WAIT 等待时长； 设置 SO_LINGER，强行关闭。 设置 socket 选项 SO_LINGER 为 (on, 0) 后，close(2) 将立即向对端发送 RST，这种关闭方式称为“强行关闭”。而被动关闭方却不知道对端已经彻底断开，所以紧接着的读写操作，引发 connection reset by peer。 数据滞留 socket 关闭时，如果接收窗口仍有数据滞留，那么会直接发送 RST ，不会进入正常的 FIN 流程。可以参考：TCP RST: Calling close() on a socket with data in the receive queue。 和“强行关闭”一样，数据滞留也会导致被动关闭方引发 connection reset by peer，这样造成的结果是：如果你的服务各种指标正常，但是有非常多的 connection reset by peer 警告，可能就是服务上游超时 close(2) socket，而由于接收窗口仍有数据滞留，发送了 RST。 References [1] Linux TCP 编程 [2] 网络编程中 SIGPIPE 信号 [3] Linux 下 TCP 连接断开未发送 FIN [4] TCP关闭连接(为什么会能Time_wait,Close_wait?)" />
<link rel="canonical" href="/network/2019/01/26/Linux-TCP-Rst.html" />
<meta property="og:url" content="/network/2019/01/26/Linux-TCP-Rst.html" />
<meta property="og:site_name" content="W41ter’s Bistro" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-26T15:13:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="探究 Linux 下 TCP 的 RST Packet" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-01-26T15:13:00+08:00","datePublished":"2019-01-26T15:13:00+08:00","description":"注：本文结论来自网络，真实性未考究，请批判性阅读，如果谬误，请斧正。本文所讨论内容，均假设工作环境为 Linux 服务器。 作为 TCP 不可或缺的一部分，TCP 包头的 RST 为 $1$ 时，表示重置，关闭异常链接。发送 RST 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送 RST 包。而接收端收到 RST 包后，也不必发送 ACK 包来确认。TCP 处理程序会在自己认为的异常时刻发送 RST 包。 14:59:23.379829 IP localhost.62412 &gt; localhost.9490: Flags [R], seq 4127385762, win 0, length 0 通过 tcpdump 观察，Flags [R] 表示该包携带了 RST 。 RST 主要用在三种场景中，保证 TCP 链接的安全性，三种场景分别是：1、到不存在端口的连接请求；2、异常终止连接；3、检测半打开连接。接下来看看 RST 的具体表现。 三种错误 内核中的 TCP 协议栈将收到 RST 的场景分为三种，并抛出了对应的错误。 connection refused 当内核中的 TCP 协议栈收到了 SYN 请求，但是该端口上没有处于监听状态，则相应 RST，此时 client 看到的便是 connection refused。 broken pipe fd is connected to a pipe or socket whose reading end is closed. When this happens the writing process will also receive a SIGPIPE signal.(Thus, the write return value is seen only if the program catches, blocks or ignores this signal.) 简单的说，如果已知远端读通道已经被关闭，而应用程序仍然在调用 write(2) 尝试向 socket 中写入数据，TCP 协议栈便会抛出 broken pipe。 connection reset by peer A network connection was closed for reasons outside the control of the local host, such as by the remote machine rebooting or an unrecoverable protocol violation. 如果远端已经 close(2) 连接了，本地服务仍发送了数据，此时 TCP 协议栈便会抛出 connection reset by peer。 broken pipe 和 connection reset by peer 无论是 broken pipe 还是 connection reset by peer，都是收到 RST 的表现，二者有何不同呢？ 为了进一步研究，这里尝试着构建两个场景，分别重现 broken pipe 和 connection reset by peer。 重现 broken pipe 首先，在服务中监听端口，每个连接分多次写入数据，然后关闭连接。 int server() { Acceptor acceptor = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4(&quot;127.0.0.1&quot;, 9490); acceptor.bind(address); acceptor.listen(10); const char *msg1 = &quot;hello&quot;, *msg2 = &quot;world&quot;; while (true) { Connection conn = acceptor.accept(); sleep(1); // wait client shutdown conn.write(msg1, strlen(msg1)); // write success, but RST recieved conn.write(msg2, strlen(msg2)); // throw `broken pipe` } // RAII close conn socket } // RAII close acceptor socket 然后客户端连接到服务端，并立即关闭连接。 int client() { Connector connector = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4(&quot;127.0.0.1&quot;, 9490); connector.connect(address); } // RAII close connector socket 通过 tcpdump 观察程序运行时请求： $ sudo tcpdump -i lo &#39;(src host 127.0.0.1) and (port 9490)&#39; -B 4096 14:59:13.376906 IP localhost.62412 &gt; localhost.9490: Flags [S], seq 4127385760, win 43690, options [mss 65495,sackOK,TS val 168040030 ecr 0,nop,wscale 10], length 0 14:59:13.376919 IP localhost.9490 &gt; localhost.62412: Flags [S.], seq 2306780414, ack 4127385761, win 43690, options [mss 65495,sackOK,TS val 168040030 ecr 168040030,nop,wscale 10], length 0 14:59:13.376928 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 1, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 0 14:59:13.377089 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 1:2, ack 1, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 1 14:59:13.377223 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 2, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 0 14:59:14.377352 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 2:3, ack 1, win 43, options [nop,nop,TS val 168040280 ecr 168040030], length 1 14:59:14.377439 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 3, win 43, options [nop,nop,TS val 168040280 ecr 168040280], length 0 // .... 14:59:22.379462 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 10:11, ack 1, win 43, options [nop,nop,TS val 168042281 ecr 168042031], length 1 14:59:22.379489 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 11, win 43, options [nop,nop,TS val 168042281 ecr 168042281], length 0 14:59:22.379626 IP localhost.62412 &gt; localhost.9490: Flags [F.], seq 1, ack 11, win 43, options [nop,nop,TS val 168042281 ecr 168042281], length 0 14:59:22.382190 IP localhost.9490 &gt; localhost.62412: Flags [.], ack 2, win 43, options [nop,nop,TS val 168042282 ecr 168042281], length 0 14:59:23.379808 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 11:12, ack 2, win 43, options [nop,nop,TS val 168042531 ecr 168042281], length 1 14:59:23.379829 IP localhost.62412 &gt; localhost.9490: Flags [R], seq 4127385762, win 0, length 0 上述 log 为实验过程中，和上面上面的代码略有出入。 可以观察到，client close(2)，发送了 FIN 给 server，并收到了 ACK。server 此时再次尝试 write(2)，便抛出了 broken pipe 异常。 int main(int argc, char** argv) { try { return server(); } catch (Exception&amp; e) { cout &lt;&lt; e.what() &lt;&lt; endl; return -1; } } server 调用方式。 SIGPIPE 与 broken pipe 按照预期，当 socket 抛出 broken pipe 时，会被最外层 try 和 catch 抓住，并输出。实际上运行结果为： $ ./server $ $ echo $? 141 $ 某次 server 端运行结果，没有任何输出，程序返回值为 $141$。 内核中 TCP 栈如果已经接收到 RST，那么下一次使用 write(2) 时，除了会返回 broken pipe 外，还会产生 SIGPIPE，默认情况下这个信号会终止整个进程，当然你并不想让进程被 SIGPIPE 信号杀死。对 server 来说，为了不被 SIGPIPE 信号杀死，那就需要忽略 SIGPIPE 信号： signal(SIGPIPE, SIG_IGN); 最后，让我们整体分析下 broken pipe 产生方式： client 发送了 FIN 给 server； server 仍给 client 发送数据，client 回复 RST； server 收到 RST 后，再次给 client 发送数据；往一个已经收到 RST 的 socket 继续写入数据，将引起 SIGPIPE 信号，write(2) 返回 EPIPE。 重现 connection reset by peer int server() { Acceptor acceptor = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4(&quot;127.0.0.1&quot;, 9490); acceptor.bind(address); acceptor.listen(10); while (true) { Connection conn = acceptor.accept(); sleep(10); // 给拔网线留下足够的时间 } // RAII close conn socket } // RAII close acceptor socket 模拟服务端断线重启。 int client() { Connector connector = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4(&quot;127.0.0.1&quot;, 9490); connector.connect(address); sleep(120); const char *msg = &quot;hello&quot;; connector.write(msg, strlen(msg)); } // RAII close connector socket 一段时间后，再给服务器发送请求，此时服务器已经重启。 这里构造了这样一个场景，与客户端建立连接后，服务端由于不可抗力，比如断电，未能发送 FIN 给客户端。当服务器重启后，内核中 TCP 协议栈收到了客户端的数据包，回应 RST，此时客户端抛出 connection reset by peer。 $ sudo tcpdump -i lo &#39;(src host 127.0.0.1) and (port 9490)&#39; -B 4096 15:43:12.638464 IP localhost.21316 &gt; localhost.9490: Flags [S], seq 3640034867, win 43690, options [mss 65495,sackOK,TS val 168699846 ecr 0,nop,wscale 10], length 0 15:43:12.638478 IP localhost.9490 &gt; localhost.21316: Flags [S.], seq 485213568, ack 3640034868, win 43690, options [mss 65495,sackOK,TS val 168699846 ecr 168699846,nop,wscale 10], length 0 15:43:16.639791 IP localhost.9490 &gt; localhost.21316: Flags [P.], seq 5:6, ack 6, win 43, options [nop,nop,TS val 168700846 ecr 168700596], length 1 15:43:16.639807 IP localhost.21316 &gt; localhost.9490: Flags [.], ack 6, win 43, options [nop,nop,TS val 168700846 ecr 168700846], length 0 15:43:17.640127 IP localhost.9490 &gt; localhost.21316: Flags [P.], seq 6:7, ack 6, win 43, options [nop,nop,TS val 168701096 ecr 168700846], length 1 15:43:17.640137 IP localhost.21316 &gt; localhost.9490: Flags [.], ack 7, win 43, options [nop,nop,TS val 168701096 ecr 168701096], length 0 15:43:18.170130 IP localhost.9490 &gt; localhost.21316: Flags [R.], seq 7, ack 6, win 43, options [nop,nop,TS val 168701228 ecr 168701096], length 0 某次模拟 connection reset by peer。 这里从读写两个角度来看 RST，如果已经 ACK 远端的 FIN 包： read(2) ：返回 0，表示 eof； write(2) ：远端返回 RST，抛出 broken pipe； 如果尚未接收到远端的 FIN 包，无论读写操作，收到 RST 时，抛出 connection reset by peer。 what more ？ 除了上述几个场景外，还有其他可能吗？ 强行关闭 正常关闭 TCP 链接时，主动关闭一方会进入 TIME_WAIT 状态，等待 2MSL（报文段最大生存时间-Maximum Segment Lifetime，根据具体的实现不同，这个值会不同），此时该端口处于不可用状态。 解决 TIME_WAIT 有三种手段： 设置 SO_REUSEADDR 和 SO_REUSEPORT； 修改 TIME_WAIT 等待时长； 设置 SO_LINGER，强行关闭。 设置 socket 选项 SO_LINGER 为 (on, 0) 后，close(2) 将立即向对端发送 RST，这种关闭方式称为“强行关闭”。而被动关闭方却不知道对端已经彻底断开，所以紧接着的读写操作，引发 connection reset by peer。 数据滞留 socket 关闭时，如果接收窗口仍有数据滞留，那么会直接发送 RST ，不会进入正常的 FIN 流程。可以参考：TCP RST: Calling close() on a socket with data in the receive queue。 和“强行关闭”一样，数据滞留也会导致被动关闭方引发 connection reset by peer，这样造成的结果是：如果你的服务各种指标正常，但是有非常多的 connection reset by peer 警告，可能就是服务上游超时 close(2) socket，而由于接收窗口仍有数据滞留，发送了 RST。 References [1] Linux TCP 编程 [2] 网络编程中 SIGPIPE 信号 [3] Linux 下 TCP 连接断开未发送 FIN [4] TCP关闭连接(为什么会能Time_wait,Close_wait?)","headline":"探究 Linux 下 TCP 的 RST Packet","mainEntityOfPage":{"@type":"WebPage","@id":"/network/2019/01/26/Linux-TCP-Rst.html"},"url":"/network/2019/01/26/Linux-TCP-Rst.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="W41ter's Bistro" /><!-- for mathjax support -->
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          extensions: [
          "tex2jax.js",
          "MathMenu.js",
          "MathZoom.js",
          "AssistiveMML.js",
          "a11y/accessibility-menu.js"
        ],
        tex2jax: {      // AND HERE
          inlineMath: [['$', '$']],
          displayMath: [['$$', '$$']]
        },
        jax: ["input/TeX", "output/CommonHTML"],
        TeX: {
          extensions: [
            "AMSmath.js",
            "AMSsymbols.js",
            "noErrors.js",
            "noUndefined.js",
          ],
          equationNumbers: { autoNumber: "AMS" }
        }
      });
    </script>
    <script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">W41ter&#39;s Bistro</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">探究 Linux 下 TCP 的 RST Packet</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-01-26T15:13:00+08:00" itemprop="datePublished">Jan 26, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <blockquote>
  <p>注：<strong>本文结论来自网络，真实性未考究，请批判性阅读，如果谬误，请斧正。</strong>本文所讨论内容，均假设工作环境为 Linux 服务器。</p>
</blockquote>

<p>作为 TCP 不可或缺的一部分，TCP 包头的 <code class="language-plaintext highlighter-rouge">RST</code> 为 $1$ 时，表示重置，关闭异常链接。发送 RST 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送 <code class="language-plaintext highlighter-rouge">RST</code> 包。而接收端收到 <code class="language-plaintext highlighter-rouge">RST</code> 包后，也不必发送 <code class="language-plaintext highlighter-rouge">ACK</code> 包来确认。TCP 处理程序会在自己认为的异常时刻发送 <code class="language-plaintext highlighter-rouge">RST</code> 包。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>14:59:23.379829 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>R], <span class="nb">seq </span>4127385762, win 0, length 0
</code></pre></div></div>

<p><em>通过 tcpdump 观察，<code class="language-plaintext highlighter-rouge">Flags [R]</code> 表示该包携带了 <code class="language-plaintext highlighter-rouge">RST</code> 。</em></p>

<p><code class="language-plaintext highlighter-rouge">RST</code> 主要用在三种场景中，保证 TCP 链接的安全性，三种场景分别是：1、到不存在端口的连接请求；2、异常终止连接；3、检测半打开连接。接下来看看 <code class="language-plaintext highlighter-rouge">RST</code> 的具体表现。</p>

<h1 id="三种错误">三种错误</h1>

<p>内核中的 TCP 协议栈将收到 <code class="language-plaintext highlighter-rouge">RST</code> 的场景分为三种，并抛出了对应的错误。</p>

<h2 id="connection-refused">connection refused</h2>

<p>当内核中的 TCP 协议栈收到了 <code class="language-plaintext highlighter-rouge">SYN</code> 请求，但是该端口上没有处于监听状态，则相应 <code class="language-plaintext highlighter-rouge">RST</code>，此时 client 看到的便是 <code class="language-plaintext highlighter-rouge">connection refused</code>。</p>

<h2 id="broken-pipe">broken pipe</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">fd</code> is connected to a pipe or socket whose reading end is closed.  When this happens the writing process will also receive a SIGPIPE signal.(Thus, the write return value is seen only if the program catches, blocks or ignores this signal.)</p>
</blockquote>

<p>简单的说，如果<strong>已知</strong>远端读通道已经被关闭，而应用程序仍然在调用 <code class="language-plaintext highlighter-rouge">write</code>(2) 尝试向 socket 中写入数据，TCP 协议栈便会抛出 <code class="language-plaintext highlighter-rouge">broken pipe</code>。</p>

<h2 id="connection-reset-by-peer">connection reset by peer</h2>

<blockquote>
  <p>A network connection was closed for reasons outside the control of the local host, such as by the remote machine rebooting or an unrecoverable protocol violation.</p>
</blockquote>

<p>如果远端已经 <code class="language-plaintext highlighter-rouge">close</code>(2) 连接了，本地服务仍发送了数据，此时 TCP 协议栈便会抛出 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<h1 id="broken-pipe-和-connection-reset-by-peer">broken pipe 和 connection reset by peer</h1>

<p>无论是 <code class="language-plaintext highlighter-rouge">broken pipe</code> 还是 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>，都是收到 <code class="language-plaintext highlighter-rouge">RST</code> 的表现，二者有何不同呢？</p>

<p>为了进一步研究，这里尝试着构建两个场景，分别重现 <code class="language-plaintext highlighter-rouge">broken pipe</code> 和 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<h2 id="重现-broken-pipe">重现 broken pipe</h2>

<p>首先，在服务中监听端口，每个连接分多次写入数据，然后关闭连接。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">server</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Acceptor</span> <span class="n">acceptor</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="n">InetAddress</span><span class="o">::</span><span class="n">parseV4</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">9490</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg1</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">,</span> <span class="o">*</span><span class="n">msg2</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">acceptor</span><span class="p">.</span><span class="n">accept</span><span class="p">();</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                        <span class="c1">// wait client shutdown</span>
        <span class="n">conn</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg1</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg1</span><span class="p">));</span>  <span class="c1">// write success, but RST recieved</span>
        <span class="n">conn</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg2</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg2</span><span class="p">));</span>  <span class="c1">// throw `broken pipe`</span>
    <span class="p">}</span> <span class="c1">// RAII close conn socket</span>
<span class="p">}</span> <span class="c1">// RAII close acceptor socket</span>
</code></pre></div></div>

<p>然后客户端连接到服务端，并立即关闭连接。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">client</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Connector</span> <span class="n">connector</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="n">InetAddress</span><span class="o">::</span><span class="n">parseV4</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">9490</span><span class="p">);</span>
    <span class="n">connector</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// RAII close connector socket</span>
</code></pre></div></div>

<p>通过 tcpdump 观察程序运行时请求：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>tcpdump <span class="nt">-i</span> lo <span class="s1">'(src host 127.0.0.1) and (port 9490)'</span>  <span class="nt">-B</span> 4096
14:59:13.376906 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>S], <span class="nb">seq </span>4127385760, win 43690, options <span class="o">[</span>mss 65495,sackOK,TS val 168040030 ecr 0,nop,wscale 10], length 0
14:59:13.376919 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>S.], <span class="nb">seq </span>2306780414, ack 4127385761, win 43690, options <span class="o">[</span>mss 65495,sackOK,TS val 168040030 ecr 168040030,nop,wscale 10], length 0
14:59:13.376928 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 1, win 43, options <span class="o">[</span>nop,nop,TS val 168040030 ecr 168040030], length 0
14:59:13.377089 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>P.], <span class="nb">seq </span>1:2, ack 1, win 43, options <span class="o">[</span>nop,nop,TS val 168040030 ecr 168040030], length 1
14:59:13.377223 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 2, win 43, options <span class="o">[</span>nop,nop,TS val 168040030 ecr 168040030], length 0
14:59:14.377352 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>P.], <span class="nb">seq </span>2:3, ack 1, win 43, options <span class="o">[</span>nop,nop,TS val 168040280 ecr 168040030], length 1
14:59:14.377439 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 3, win 43, options <span class="o">[</span>nop,nop,TS val 168040280 ecr 168040280], length 0
// ....
14:59:22.379462 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>P.], <span class="nb">seq </span>10:11, ack 1, win 43, options <span class="o">[</span>nop,nop,TS val 168042281 ecr 168042031], length 1
14:59:22.379489 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 11, win 43, options <span class="o">[</span>nop,nop,TS val 168042281 ecr 168042281], length 0
14:59:22.379626 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>F.], <span class="nb">seq </span>1, ack 11, win 43, options <span class="o">[</span>nop,nop,TS val 168042281 ecr 168042281], length 0
14:59:22.382190 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>.], ack 2, win 43, options <span class="o">[</span>nop,nop,TS val 168042282 ecr 168042281], length 0
14:59:23.379808 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>P.], <span class="nb">seq </span>11:12, ack 2, win 43, options <span class="o">[</span>nop,nop,TS val 168042531 ecr 168042281], length 1
14:59:23.379829 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>R], <span class="nb">seq </span>4127385762, win 0, length 0
</code></pre></div></div>

<p><em>上述 log 为实验过程中，和上面上面的代码略有出入。</em></p>

<p>可以观察到，client <code class="language-plaintext highlighter-rouge">close</code>(2)，发送了 <code class="language-plaintext highlighter-rouge">FIN</code> 给 server，并收到了 <code class="language-plaintext highlighter-rouge">ACK</code>。server 此时再次尝试 <code class="language-plaintext highlighter-rouge">write</code>(2)，便抛出了 <code class="language-plaintext highlighter-rouge">broken pipe</code> 异常。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">server</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em><code class="language-plaintext highlighter-rouge">server</code> 调用方式。</em></p>

<h3 id="sigpipe-与-broken-pipe">SIGPIPE 与 broken pipe</h3>

<p>按照预期，当 socket 抛出 <code class="language-plaintext highlighter-rouge">broken pipe</code> 时，会被最外层 <code class="language-plaintext highlighter-rouge">try</code> 和 <code class="language-plaintext highlighter-rouge">catch</code> 抓住，并输出。实际上运行结果为：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./server
<span class="nv">$ </span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
141
<span class="nv">$ </span>
</code></pre></div></div>

<p><em>某次 server 端运行结果，没有任何输出，程序返回值为 $141$。</em></p>

<p>内核中 TCP 栈如果已经接收到 <code class="language-plaintext highlighter-rouge">RST</code>，那么下一次使用 <code class="language-plaintext highlighter-rouge">write</code>(2) 时，除了会返回 <code class="language-plaintext highlighter-rouge">broken pipe</code> 外，还会产生 <code class="language-plaintext highlighter-rouge">SIGPIPE</code>，默认情况下这个信号会终止整个进程，当然你并不想让进程被 <code class="language-plaintext highlighter-rouge">SIGPIPE</code> 信号杀死。对 server 来说，为了不被 <code class="language-plaintext highlighter-rouge">SIGPIPE</code> 信号杀死，那就需要忽略 <code class="language-plaintext highlighter-rouge">SIGPIPE</code> 信号：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
</code></pre></div></div>

<p>最后，让我们整体分析下 <code class="language-plaintext highlighter-rouge">broken pipe</code> 产生方式：</p>

<ol>
  <li>client 发送了 <code class="language-plaintext highlighter-rouge">FIN</code> 给 server；</li>
  <li>server 仍给 client 发送数据，client 回复 <code class="language-plaintext highlighter-rouge">RST</code>；</li>
  <li>server 收到 <code class="language-plaintext highlighter-rouge">RST</code> 后，再次给 client 发送数据；往一个已经收到 <code class="language-plaintext highlighter-rouge">RST</code> 的 socket 继续写入数据，将引起 <code class="language-plaintext highlighter-rouge">SIGPIPE</code> 信号，<code class="language-plaintext highlighter-rouge">write</code>(2) 返回 <code class="language-plaintext highlighter-rouge">EPIPE</code>。</li>
</ol>

<h2 id="重现-connection-reset-by-peer">重现 <code class="language-plaintext highlighter-rouge">connection reset by peer</code></h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">server</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Acceptor</span> <span class="n">acceptor</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="n">InetAddress</span><span class="o">::</span><span class="n">parseV4</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">9490</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">acceptor</span><span class="p">.</span><span class="n">accept</span><span class="p">();</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>                       <span class="c1">// 给拔网线留下足够的时间</span>
    <span class="p">}</span> <span class="c1">// RAII close conn socket</span>
<span class="p">}</span> <span class="c1">// RAII close acceptor socket</span>
</code></pre></div></div>

<p><em>模拟服务端断线重启。</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">client</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Connector</span> <span class="n">connector</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="n">InetAddress</span><span class="o">::</span><span class="n">parseV4</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">9490</span><span class="p">);</span>
    <span class="n">connector</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">120</span><span class="p">);</span> 

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
    <span class="n">connector</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
<span class="p">}</span> <span class="c1">// RAII close connector socket</span>
</code></pre></div></div>

<p><em>一段时间后，再给服务器发送请求，此时服务器已经重启。</em></p>

<p>这里构造了这样一个场景，与客户端建立连接后，服务端由于不可抗力，比如断电，未能发送 <code class="language-plaintext highlighter-rouge">FIN</code> 给客户端。当服务器重启后，内核中 TCP 协议栈收到了客户端的数据包，回应 <code class="language-plaintext highlighter-rouge">RST</code>，此时客户端抛出 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>tcpdump <span class="nt">-i</span> lo <span class="s1">'(src host 127.0.0.1) and (port 9490)'</span>  <span class="nt">-B</span> 4096
15:43:12.638464 IP localhost.21316 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>S], <span class="nb">seq </span>3640034867, win 43690, options <span class="o">[</span>mss 65495,sackOK,TS val 168699846 ecr 0,nop,wscale 10], length 0
15:43:12.638478 IP localhost.9490 <span class="o">&gt;</span> localhost.21316: Flags <span class="o">[</span>S.], <span class="nb">seq </span>485213568, ack 3640034868, win 43690, options <span class="o">[</span>mss 65495,sackOK,TS val 168699846 ecr 168699846,nop,wscale 10], length 0
15:43:16.639791 IP localhost.9490 <span class="o">&gt;</span> localhost.21316: Flags <span class="o">[</span>P.], <span class="nb">seq </span>5:6, ack 6, win 43, options <span class="o">[</span>nop,nop,TS val 168700846 ecr 168700596], length 1
15:43:16.639807 IP localhost.21316 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 6, win 43, options <span class="o">[</span>nop,nop,TS val 168700846 ecr 168700846], length 0
15:43:17.640127 IP localhost.9490 <span class="o">&gt;</span> localhost.21316: Flags <span class="o">[</span>P.], <span class="nb">seq </span>6:7, ack 6, win 43, options <span class="o">[</span>nop,nop,TS val 168701096 ecr 168700846], length 1
15:43:17.640137 IP localhost.21316 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 7, win 43, options <span class="o">[</span>nop,nop,TS val 168701096 ecr 168701096], length 0
15:43:18.170130 IP localhost.9490 <span class="o">&gt;</span> localhost.21316: Flags <span class="o">[</span>R.], <span class="nb">seq </span>7, ack 6, win 43, options <span class="o">[</span>nop,nop,TS val 168701228 ecr 168701096], length 0
</code></pre></div></div>

<p><em>某次模拟 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</em></p>

<hr />

<p>这里从读写两个角度来看 <code class="language-plaintext highlighter-rouge">RST</code>，如果已经 <code class="language-plaintext highlighter-rouge">ACK</code> 远端的 <code class="language-plaintext highlighter-rouge">FIN</code> 包：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">read</code>(2) ：返回 0，表示 eof；</li>
  <li><code class="language-plaintext highlighter-rouge">write</code>(2) ：远端返回 <code class="language-plaintext highlighter-rouge">RST</code>，抛出 <code class="language-plaintext highlighter-rouge">broken pipe</code>；</li>
</ol>

<p>如果尚未接收到远端的 <code class="language-plaintext highlighter-rouge">FIN</code> 包，无论读写操作，收到 <code class="language-plaintext highlighter-rouge">RST</code> 时，抛出 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<h2 id="what-more-">what more ？</h2>

<p>除了上述几个场景外，还有其他可能吗？</p>

<h3 id="强行关闭">强行关闭</h3>

<p>正常关闭 TCP 链接时，主动关闭一方会进入 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 状态，等待 2MSL（报文段最大生存时间-Maximum Segment Lifetime，根据具体的实现不同，这个值会不同），此时该端口处于不可用状态。</p>

<p>解决 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 有三种手段：</p>

<ol>
  <li>设置 <code class="language-plaintext highlighter-rouge">SO_REUSEADDR</code> 和 <code class="language-plaintext highlighter-rouge">SO_REUSEPORT</code>；</li>
  <li>修改 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 等待时长；</li>
  <li>设置 <code class="language-plaintext highlighter-rouge">SO_LINGER</code>，强行关闭。</li>
</ol>

<p>设置 socket 选项 <code class="language-plaintext highlighter-rouge">SO_LINGER</code> 为 <code class="language-plaintext highlighter-rouge">(on, 0)</code> 后，<code class="language-plaintext highlighter-rouge">close</code>(2) 将立即向对端发送 <code class="language-plaintext highlighter-rouge">RST</code>，这种关闭方式称为“强行关闭”。而被动关闭方却不知道对端已经彻底断开，所以紧接着的读写操作，引发 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<h3 id="数据滞留">数据滞留</h3>

<p>socket 关闭时，如果接收窗口仍有数据滞留，那么会直接发送 <code class="language-plaintext highlighter-rouge">RST</code> ，不会进入正常的 <code class="language-plaintext highlighter-rouge">FIN</code> 流程。可以参考：<a href="http://cs.ecs.baylor.edu/~donahoo/practical/CSockets/TCPRST.pdf">TCP RST: Calling close() on a socket with data in the receive queue</a>。</p>

<p>和“强行关闭”一样，数据滞留也会导致被动关闭方引发 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>，这样造成的结果是：如果你的服务各种指标正常，但是有非常多的 <code class="language-plaintext highlighter-rouge">connection reset by peer</code> 警告，可能就是服务上游超时 <code class="language-plaintext highlighter-rouge">close</code>(2) socket，而由于接收窗口仍有数据滞留，发送了 <code class="language-plaintext highlighter-rouge">RST</code>。</p>

<h1 id="references">References</h1>

<p>[1] <a href="/2017/05/26/Linux-TCP-%E7%BC%96%E7%A8%8B/">Linux TCP 编程</a></p>

<p>[2] <a href="http://senlinzhan.github.io/2017/03/02/sigpipe/">网络编程中 SIGPIPE 信号</a></p>

<p>[3] <a href="http://xiangruix.com/2016/01/12/tcp-closed-without-fin/">Linux 下 TCP 连接断开未发送 FIN</a></p>

<p>[4] <a href="http://itindex.net/detail/56132-tcp-time-wait">TCP关闭连接(为什么会能Time_wait,Close_wait?)</a></p>

  </div><a class="u-url" href="/network/2019/01/26/Linux-TCP-Rst.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">W41ter&#39;s Bistro</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">W41ter&#39;s Bistro</li><li><a class="u-email" href="mailto:w41ter.l@gmail.com">w41ter.l@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/w41ter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">w41ter</span></a></li><li><a href="https://www.twitter.com/WalterM56697798"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WalterM56697798</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Focus on distributed storage system, compiler.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
