<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>LeetCode - 85 Maximal Rectangle | W41ter’s Bistro</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="LeetCode - 85 Maximal Rectangle" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="85. Maximal Rectangle 首先看题意，题目需要求出由0和1组成的2Dmatrix中，全由1组成的矩形最大面积为多少。比如下面的矩形： 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 最大面积为 6。 在做这提前，需要看看前一题：84. Largest Rectangle in Histogram。这道题目是求出柱状图中可以摆放下的最大矩形。 如何求解？仔细观察可以发现，像 576 这样的数据，可以看作中间高，两边低。而具体面积则由数据个数 * 选取区间中最矮的高度决定。所以完全可以把这几个变为：555、7和66这样的形式，然后再从中选出最大的。 所以这道题的简单解法是从头到尾扫一次，每次遇到递减时，将多出的部分计算后给扔掉，那么扔掉后的数据则仍然是递增的。比如576，当扫描到6时，计算得7，并将7改为6，得到566继续计算。这样，得到了中间去掉部分能组成的最大面积，和最后剩下的递增数组进行比较。对于单调递增的数据，也好算，减少宽度，增加高度就能算出来。所以代码部分如下： class Solution { public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { stack&lt;int&gt; stack; int max_ = 0; for (auto i : heights) { if (stack.empty()) stack.push(i); else { int l = stack.top(); if (l &lt;= i) { stack.push(i); } else { int count = 1; while (!stack.empty() &amp;&amp; stack.top() &gt; i) { int t = stack.top(); stack.pop(); if (t * count &gt; max_) { max_ = t * count; } count++; } for (int j = 0; j &lt; count; j++) { stack.push(i); } } } } if (!stack.empty()) { int count = stack.size(); for (int i = 1; i &lt;= count; ++i) { int t = stack.top(); stack.pop(); if (t * i &gt; max_) max_ = t * i; } } return max_; } }; 现在回到计算matrix中的矩形问题上来。用一行将矩形分割成两半，上面部分和下面部分。遮住下面部分，那么看到的就是一个Histogram，则可以使用上面一题的解法来做。将行往下挪，如果出现了(1/0/1)这样的列数据，不再是一个Histogram，那么可以认为0以上部分全为0，得到Histogram。所以题目答案为： class Solution { public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { if (matrix.empty() || matrix[0].empty()) return 0; int max = 0; vector&lt;int&gt; heights(matrix[0].size(), 0); for (int i = 0; i &lt; matrix.size(); ++i) { for (int j = 0; j &lt; matrix[0].size(); ++j) { heights[j] = (matrix[i][j] == &#39;0&#39;) ? 0 : heights[j] + 1; } max = std::max(largestRectangleArea(heights), max); } return max; } int largestRectangleArea(vector&lt;int&gt;&amp; heights) { stack&lt;int&gt; stack; int max_ = 0; for (auto i : heights) { if (stack.empty()) stack.push(i); else { int l = stack.top(); if (l &lt;= i) { stack.push(i); } else { int count = 1; while (!stack.empty() &amp;&amp; stack.top() &gt; i) { int t = stack.top(); stack.pop(); if (t * count &gt; max_) { max_ = t * count; } count++; } for (int j = 0; j &lt; count; j++) { stack.push(i); } } } } if (!stack.empty()) { int count = stack.size(); for (int i = 1; i &lt;= count; ++i) { int t = stack.top(); stack.pop(); if (t * i &gt; max_) max_ = t * i; } } return max_; } };" />
<meta property="og:description" content="85. Maximal Rectangle 首先看题意，题目需要求出由0和1组成的2Dmatrix中，全由1组成的矩形最大面积为多少。比如下面的矩形： 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 最大面积为 6。 在做这提前，需要看看前一题：84. Largest Rectangle in Histogram。这道题目是求出柱状图中可以摆放下的最大矩形。 如何求解？仔细观察可以发现，像 576 这样的数据，可以看作中间高，两边低。而具体面积则由数据个数 * 选取区间中最矮的高度决定。所以完全可以把这几个变为：555、7和66这样的形式，然后再从中选出最大的。 所以这道题的简单解法是从头到尾扫一次，每次遇到递减时，将多出的部分计算后给扔掉，那么扔掉后的数据则仍然是递增的。比如576，当扫描到6时，计算得7，并将7改为6，得到566继续计算。这样，得到了中间去掉部分能组成的最大面积，和最后剩下的递增数组进行比较。对于单调递增的数据，也好算，减少宽度，增加高度就能算出来。所以代码部分如下： class Solution { public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { stack&lt;int&gt; stack; int max_ = 0; for (auto i : heights) { if (stack.empty()) stack.push(i); else { int l = stack.top(); if (l &lt;= i) { stack.push(i); } else { int count = 1; while (!stack.empty() &amp;&amp; stack.top() &gt; i) { int t = stack.top(); stack.pop(); if (t * count &gt; max_) { max_ = t * count; } count++; } for (int j = 0; j &lt; count; j++) { stack.push(i); } } } } if (!stack.empty()) { int count = stack.size(); for (int i = 1; i &lt;= count; ++i) { int t = stack.top(); stack.pop(); if (t * i &gt; max_) max_ = t * i; } } return max_; } }; 现在回到计算matrix中的矩形问题上来。用一行将矩形分割成两半，上面部分和下面部分。遮住下面部分，那么看到的就是一个Histogram，则可以使用上面一题的解法来做。将行往下挪，如果出现了(1/0/1)这样的列数据，不再是一个Histogram，那么可以认为0以上部分全为0，得到Histogram。所以题目答案为： class Solution { public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { if (matrix.empty() || matrix[0].empty()) return 0; int max = 0; vector&lt;int&gt; heights(matrix[0].size(), 0); for (int i = 0; i &lt; matrix.size(); ++i) { for (int j = 0; j &lt; matrix[0].size(); ++j) { heights[j] = (matrix[i][j] == &#39;0&#39;) ? 0 : heights[j] + 1; } max = std::max(largestRectangleArea(heights), max); } return max; } int largestRectangleArea(vector&lt;int&gt;&amp; heights) { stack&lt;int&gt; stack; int max_ = 0; for (auto i : heights) { if (stack.empty()) stack.push(i); else { int l = stack.top(); if (l &lt;= i) { stack.push(i); } else { int count = 1; while (!stack.empty() &amp;&amp; stack.top() &gt; i) { int t = stack.top(); stack.pop(); if (t * count &gt; max_) { max_ = t * count; } count++; } for (int j = 0; j &lt; count; j++) { stack.push(i); } } } } if (!stack.empty()) { int count = stack.size(); for (int i = 1; i &lt;= count; ++i) { int t = stack.top(); stack.pop(); if (t * i &gt; max_) max_ = t * i; } } return max_; } };" />
<link rel="canonical" href="/leetcode/2017/06/13/LeetCode-85-Maximal-Rectangle.html" />
<meta property="og:url" content="/leetcode/2017/06/13/LeetCode-85-Maximal-Rectangle.html" />
<meta property="og:site_name" content="W41ter’s Bistro" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-13T03:33:29+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="LeetCode - 85 Maximal Rectangle" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-06-13T03:33:29+08:00","datePublished":"2017-06-13T03:33:29+08:00","description":"85. Maximal Rectangle 首先看题意，题目需要求出由0和1组成的2Dmatrix中，全由1组成的矩形最大面积为多少。比如下面的矩形： 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 最大面积为 6。 在做这提前，需要看看前一题：84. Largest Rectangle in Histogram。这道题目是求出柱状图中可以摆放下的最大矩形。 如何求解？仔细观察可以发现，像 576 这样的数据，可以看作中间高，两边低。而具体面积则由数据个数 * 选取区间中最矮的高度决定。所以完全可以把这几个变为：555、7和66这样的形式，然后再从中选出最大的。 所以这道题的简单解法是从头到尾扫一次，每次遇到递减时，将多出的部分计算后给扔掉，那么扔掉后的数据则仍然是递增的。比如576，当扫描到6时，计算得7，并将7改为6，得到566继续计算。这样，得到了中间去掉部分能组成的最大面积，和最后剩下的递增数组进行比较。对于单调递增的数据，也好算，减少宽度，增加高度就能算出来。所以代码部分如下： class Solution { public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { stack&lt;int&gt; stack; int max_ = 0; for (auto i : heights) { if (stack.empty()) stack.push(i); else { int l = stack.top(); if (l &lt;= i) { stack.push(i); } else { int count = 1; while (!stack.empty() &amp;&amp; stack.top() &gt; i) { int t = stack.top(); stack.pop(); if (t * count &gt; max_) { max_ = t * count; } count++; } for (int j = 0; j &lt; count; j++) { stack.push(i); } } } } if (!stack.empty()) { int count = stack.size(); for (int i = 1; i &lt;= count; ++i) { int t = stack.top(); stack.pop(); if (t * i &gt; max_) max_ = t * i; } } return max_; } }; 现在回到计算matrix中的矩形问题上来。用一行将矩形分割成两半，上面部分和下面部分。遮住下面部分，那么看到的就是一个Histogram，则可以使用上面一题的解法来做。将行往下挪，如果出现了(1/0/1)这样的列数据，不再是一个Histogram，那么可以认为0以上部分全为0，得到Histogram。所以题目答案为： class Solution { public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { if (matrix.empty() || matrix[0].empty()) return 0; int max = 0; vector&lt;int&gt; heights(matrix[0].size(), 0); for (int i = 0; i &lt; matrix.size(); ++i) { for (int j = 0; j &lt; matrix[0].size(); ++j) { heights[j] = (matrix[i][j] == &#39;0&#39;) ? 0 : heights[j] + 1; } max = std::max(largestRectangleArea(heights), max); } return max; } int largestRectangleArea(vector&lt;int&gt;&amp; heights) { stack&lt;int&gt; stack; int max_ = 0; for (auto i : heights) { if (stack.empty()) stack.push(i); else { int l = stack.top(); if (l &lt;= i) { stack.push(i); } else { int count = 1; while (!stack.empty() &amp;&amp; stack.top() &gt; i) { int t = stack.top(); stack.pop(); if (t * count &gt; max_) { max_ = t * count; } count++; } for (int j = 0; j &lt; count; j++) { stack.push(i); } } } } if (!stack.empty()) { int count = stack.size(); for (int i = 1; i &lt;= count; ++i) { int t = stack.top(); stack.pop(); if (t * i &gt; max_) max_ = t * i; } } return max_; } };","headline":"LeetCode - 85 Maximal Rectangle","mainEntityOfPage":{"@type":"WebPage","@id":"/leetcode/2017/06/13/LeetCode-85-Maximal-Rectangle.html"},"url":"/leetcode/2017/06/13/LeetCode-85-Maximal-Rectangle.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="W41ter's Bistro" /><!-- for mathjax support -->
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">W41ter&#39;s Bistro</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">LeetCode - 85 Maximal Rectangle</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-06-13T03:33:29+08:00" itemprop="datePublished">Jun 13, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="https://leetcode.com/problems/maximal-rectangle/#/description">85. Maximal Rectangle</a></p>

<p>首先看题意，题目需要求出由0和1组成的2Dmatrix中，全由1组成的矩形最大面积为多少。比如下面的矩形：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
</code></pre></div></div>

<p>最大面积为 6。</p>

<p>在做这提前，需要看看前一题：<a href="https://leetcode.com/problems/largest-rectangle-in-histogram/#/description">84. Largest Rectangle in Histogram</a>。这道题目是求出柱状图中可以摆放下的最大矩形。</p>

<p>如何求解？仔细观察可以发现，像 <code class="language-plaintext highlighter-rouge">576</code> 这样的数据，可以看作中间高，两边低。而具体面积则由数据个数 * 选取区间中最矮的高度决定。所以完全可以把这几个变为：<code class="language-plaintext highlighter-rouge">555</code>、<code class="language-plaintext highlighter-rouge">7</code>和<code class="language-plaintext highlighter-rouge">66</code>这样的形式，然后再从中选出最大的。</p>

<p>所以这道题的简单解法是从头到尾扫一次，每次遇到递减时，将多出的部分计算后给扔掉，那么扔掉后的数据则仍然是递增的。比如<code class="language-plaintext highlighter-rouge">576</code>，当扫描到<code class="language-plaintext highlighter-rouge">6</code>时，计算得<code class="language-plaintext highlighter-rouge">7</code>，并将<code class="language-plaintext highlighter-rouge">7</code>改为<code class="language-plaintext highlighter-rouge">6</code>，得到<code class="language-plaintext highlighter-rouge">566</code>继续计算。这样，得到了中间去掉部分能组成的最大面积，和最后剩下的递增数组进行比较。对于单调递增的数据，也好算，减少宽度，增加高度就能算出来。所以代码部分如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution {
public:
    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
        stack&lt;int&gt; stack;
        int max_ = 0;
        for (auto i : heights) {
            if (stack.empty())
                stack.push(i);
            else {
                int l = stack.top();
                if (l &lt;= i) {
                    stack.push(i);
                }
                else {
                    int count = 1;
                    while (!stack.empty() &amp;&amp; stack.top() &gt; i) {
                        int t = stack.top();
                        stack.pop();
                        if (t * count &gt; max_) {
                            max_ = t * count;
                        }
                        count++;
                    }
                    for (int j = 0; j &lt; count; j++) {
                        stack.push(i);
                    }
                }
            }
        }
        if (!stack.empty()) {
            int count = stack.size();
            for (int i = 1; i &lt;= count; ++i) {
                int t = stack.top();
                stack.pop();
                if (t * i &gt; max_)
                    max_ = t * i;
            }
        }
        return max_;
    }
};
</code></pre></div></div>

<p>现在回到计算matrix中的矩形问题上来。用一行将矩形分割成两半，上面部分和下面部分。遮住下面部分，那么看到的就是一个<code class="language-plaintext highlighter-rouge">Histogram</code>，则可以使用上面一题的解法来做。将行往下挪，如果出现了(1/0/1)这样的列数据，不再是一个<code class="language-plaintext highlighter-rouge">Histogram</code>，那么可以认为0以上部分全为0，得到<code class="language-plaintext highlighter-rouge">Histogram</code>。所以题目答案为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution {
public:
    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        if (matrix.empty() || matrix[0].empty()) return 0;
        int max = 0;
        vector&lt;int&gt; heights(matrix[0].size(), 0);
        for (int i = 0; i &lt; matrix.size(); ++i) {
            for (int j = 0; j &lt; matrix[0].size(); ++j) {
                heights[j] = (matrix[i][j] == '0') ? 0 : heights[j] + 1;
            }
            max = std::max(largestRectangleArea(heights), max);
        }
        return max;
    }
    
    int largestRectangleArea(vector&lt;int&gt;&amp; heights) {
        stack&lt;int&gt; stack;
        int max_ = 0;
        for (auto i : heights) {
            if (stack.empty())
                stack.push(i);
            else {
                int l = stack.top();
                if (l &lt;= i) {
                    stack.push(i);
                }
                else {
                    int count = 1;
                    while (!stack.empty() &amp;&amp; stack.top() &gt; i) {
                        int t = stack.top();
                        stack.pop();
                        if (t * count &gt; max_) {
                            max_ = t * count;
                        }
                        count++;
                    }
                    for (int j = 0; j &lt; count; j++) {
                        stack.push(i);
                    }
                }
            }
        }
        if (!stack.empty()) {
            int count = stack.size();
            for (int i = 1; i &lt;= count; ++i) {
                int t = stack.top();
                stack.pop();
                if (t * i &gt; max_)
                    max_ = t * i;
            }
        }
        return max_;
    }
};
</code></pre></div></div>

  </div><a class="u-url" href="/leetcode/2017/06/13/LeetCode-85-Maximal-Rectangle.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">W41ter&#39;s Bistro</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">W41ter&#39;s Bistro</li><li><a class="u-email" href="mailto:w41ter.l@gmail.com">w41ter.l@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/w41ter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">w41ter</span></a></li><li><a href="https://www.twitter.com/WalterM56697798"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WalterM56697798</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Focus on distributed storage system, compiler.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
