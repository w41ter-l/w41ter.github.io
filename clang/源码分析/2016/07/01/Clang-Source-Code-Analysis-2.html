<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Clang Source Code Analysis (2) | W41ter’s Bistro</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Clang Source Code Analysis (2)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="前面部分分析了初始化流程，紧接着分析的是 Parse 部分。 所有 Action 的基类是 FrontendAction，在 FrontendAction 的 Execute 中发现： bool FrontendAction::Execute() { CompilerInstance &amp;CI = getCompilerInstance(); if (CI.hasFrontendTimer()) { llvm::TimeRegion Timer(CI.getFrontendTimer()); ExecuteAction(); } else ExecuteAction(); // .... return true; } 流程转入了 ExecuteAction 中，目前的 Act 是 EmitLLVMAction： class EmitLLVMAction : public CodeGenAction { virtual void anchor(); public: EmitLLVMAction(llvm::LLVMContext *_VMContext = nullptr); }; 实际上 EmitLLVMAction 只是 CodeGenAction 的一个子类。所以应该在 CodeGenAction 中找 Execute 的逻辑。 void CodeGenAction::ExecuteAction() { // If this is an IR file, we have to treat it specially. if (getCurrentFileKind() == IK_LLVM_IR) { // other codes. } // Otherwise follow the normal AST path. this-&gt;ASTFrontendAction::ExecuteAction(); } 所以在 CodeGenAction::ExecuteAction 中，直接使用了 ASTFrontendAction::ExecuteAction 的实现。找到 ASTFrontendAction 对应的 ExecuteAction： void ASTFrontendAction::ExecuteAction() { ParseAST(CI.getSema(), CI.getFrontendOpts().ShowStats, CI.getFrontendOpts().SkipFunctionBodies); } 这里截取了重要的部分代码。跟踪 ParseAST，截取代码如下： void clang::ParseAST(Sema &amp;S, bool PrintStats, bool SkipFunctionBodies) { ASTConsumer *Consumer = &amp;S.getASTConsumer(); std::unique_ptr&lt;Parser&gt; ParseOP( new Parser(S.getPreprocessor(), S, SkipFunctionBodies)); Parser &amp;P = *ParseOP.get(); S.getPreprocessor().EnterMainSourceFile(); P.Initialize(); if (P.ParseTopLevelDecl(ADecl)) { if (!External &amp;&amp; !S.getLangOpts().CPlusPlus) P.Diag(diag::ext_empty_translation_unit); } else { do { // If we got a null return and something *was* parsed, ignore it. This // is due to a top-level semicolon, an action override, or a parse error // skipping something. if (ADecl &amp;&amp; !Consumer-&gt;HandleTopLevelDecl(ADecl.get())) return; } while (!P.ParseTopLevelDecl(ADecl)); } // Process any TopLevelDecls generated by #pragma weak. for (Decl *D : S.WeakTopLevelDecls()) Consumer-&gt;HandleTopLevelDecl(DeclGroupRef(D)); Consumer-&gt;HandleTranslationUnit(S.getASTContext()); } Parse 通过 ParseTopLevelDecl 得到 Decl ，然后通过 ASTConsumer 的 HandleTopLevelDecl 处理。忽略其他现在并不关心的部分，在 ParseTopLevelDecl 内部调用 ParseExternalDeclaration 开始。而 ParseExternalDeclaration 内部，我们只关心下面一行代码： return ParseDeclarationOrFunctionDefinition(attrs, DS); 这里处理声明或者函数定义，内部有一个 Internal 包含。这其中分为两部分，一部分是 ParseDeclarationSpecifiers；另一部分是最后的 ParseDeclGroup。 第一部分用于获取类型说明符，第二部分则是具体声明部分，这里重点看第二部分： Parser::DeclGroupPtrTy Parser::ParseDeclGroup(ParsingDeclSpec &amp;DS, unsigned Context, SourceLocation *DeclEnd, ForRangeInit *FRI) { // Parse the first declarator. ParsingDeclarator D(*this, DS, static_cast&lt;Declarator::TheContext&gt;(Context)); ParseDeclarator(D); // Check to see if we have a function *definition* which must have a body. if (D.isFunctionDeclarator() &amp;&amp; !isDeclarationAfterDeclarator()) { Decl *TheDecl = ParseFunctionDefinition(D, ParsedTemplateInfo(), &amp;LateParsedAttrs); return Actions.ConvertDeclToDeclGroup(TheDecl); } SmallVector&lt;Decl *, 8&gt; DeclsInGroup; Decl *FirstDecl = ParseDeclarationAfterDeclaratorAndAttributes( D, ParsedTemplateInfo(), FRI); // If we don&#39;t have a comma, it is either the end of the list (a &#39;;&#39;) or an // error, bail out. SourceLocation CommaLoc; while (TryConsumeToken(tok::comma, CommaLoc)) { ParseDeclarator(D); if (!D.isInvalidType()) { Decl *ThisDecl = ParseDeclarationAfterDeclarator(D); } } } ParseDeclGroup 的结构大致如上，首先使用 ParseDeclarator 获取一个声明，比如 int i; 这里得到的就是 i，然后判断是否紧接 ()，如果是，则调用 ParseFunctionDefinition 分析函数定义，否则循环调用 ParseDeclarator 获取所有声明的变量。 对于声明而言，需要调用 ParseDeclarationAfterDeclarator 将类型与 declarator 结合，形成一个完整的声明。ParseDeclarationAfterDeclarator 中调用了 ParseDeclarationAfterDeclaratorAndAttributes, 而 ParseDeclarationAfterDeclaratorAndAttributes 中实际调用了 Actions.ActOnDeclarator，ActOnDeclarator 实际调用了 HandleDeclarator。 在 HandleDeclarator 中，实际的工作有三个，首先调用 GetTypeForDeclarator; 得到类型信息，因为各个类型实际上只有一个实例，所以这里需要映射过程。其次调用以下几个中的某一个: ActOnTypedefDeclarator ActOnFunctionDeclarator ActOnVariableDeclarator 最后，调用 PushOnScopeChains 将声明存起来。保存起来的 declarator 的信息可以用于处理下一次遇到 declarator 判断是否符合语法。 现在回头看 ParseFunctionDefinition 部分。节选代码如下： Decl *Parser::ParseFunctionDefinition(ParsingDeclarator &amp;D, const ParsedTemplateInfo &amp;TemplateInfo, LateParsedAttrList *LateParsedAttrs) { // Enter a scope for the function body. ParseScope BodyScope(this, Scope::FnScope|Scope::DeclScope); // Tell the actions module that we have entered a function definition with the // specified Declarator for the function. Decl *Res = Actions.ActOnStartOfFunctionDef(getCurScope(), D, TemplateInfo.TemplateParams ? *TemplateInfo.TemplateParams : MultiTemplateParamsArg(), &amp;SkipBody); return ParseFunctionStatementBody(Res, BodyScope); } 首先进入函数作用域，执行相应的 Action，最后调用 ParseFunctionStatementBody 开始解析函数部分。 Decl *Parser::ParseFunctionStatementBody(Decl *Decl, ParseScope &amp;BodyScope) { // Do not enter a scope for the brace, as the arguments are in the same scope // (the function body) as the body itself. Instead, just read the statement // list and put it into a CompoundStmt for safe keeping. StmtResult FnBody(ParseCompoundStatementBody()); BodyScope.Exit(); return Actions.ActOnFinishFunctionBody(Decl, FnBody.get()); } ParseFunctionStatementBody 中最重要的一句是: StmtResult FnBody(ParseCompoundStatementBody()); 然后就是退出作用域，执行相应的 Action。继续跟进 ParseCompoundStatementBody。 在 ParseCompoundStatementBody 中，暂时忽略 kw__extension__ 的情况，于是，实际的调用为 ParseStatementOrDeclaration，其中又调用了 ParseStatementOrDeclarationAfterAttributes，这个函数就是正式进行分析的代码部分： StmtResult Parser::ParseStatementOrDeclarationAfterAttributes(StmtVector &amp;Stmts, AllowedContsructsKind Allowed, SourceLocation *TrailingElseLoc, ParsedAttributesWithRange &amp;Attrs) { switch (Kind) { case tok::identifier: { Token Next = NextToken(); if (Next.is(tok::colon)) { // C99 6.8.1: labeled-statement // identifier &#39;:&#39; statement return ParseLabeledStatement(Attrs); } // Look up the identifier, and typo-correct it to a keyword if it&#39;s not // found. if (Next.isNot(tok::coloncolon)) { // Try to limit which sets of keywords should be included in typo // correction based on what the next token is. if (TryAnnotateName(/*IsAddressOfOperand*/ false, llvm::make_unique&lt;StatementFilterCCC&gt;(Next)) == ANK_Error) { // Handle errors here by skipping up to the next semicolon or &#39;}&#39;, and // eat the semicolon if that&#39;s what stopped us. SkipUntil(tok::r_brace, StopAtSemi | StopBeforeMatch); if (Tok.is(tok::semi)) ConsumeToken(); return StmtError(); } // If the identifier was typo-corrected, try again. if (Tok.isNot(tok::identifier)) goto Retry; } // Fall through } default: { if ((getLangOpts().CPlusPlus || Allowed == ACK_Any) &amp;&amp; isDeclarationStatement()) { SourceLocation DeclStart = Tok.getLocation(), DeclEnd; DeclGroupPtrTy Decl = ParseDeclaration(Declarator::BlockContext, DeclEnd, Attrs); return Actions.ActOnDeclStmt(Decl, DeclStart, DeclEnd); } if (Tok.is(tok::r_brace)) { Diag(Tok, diag::err_expected_statement); return StmtError(); } return ParseExprStatement(); } case tok::kw_case: // C99 6.8.1: labeled-statement return ParseCaseStatement(); case tok::kw_default: // C99 6.8.1: labeled-statement return ParseDefaultStatement(); case tok::l_brace: // C99 6.8.2: compound-statement return ParseCompoundStatement(); case tok::semi: { // C99 6.8.3p3: expression[opt] &#39;;&#39; bool HasLeadingEmptyMacro = Tok.hasLeadingEmptyMacro(); return Actions.ActOnNullStmt(ConsumeToken(), HasLeadingEmptyMacro); } case tok::kw_if: // C99 6.8.4.1: if-statement return ParseIfStatement(TrailingElseLoc); case tok::kw_switch: // C99 6.8.4.2: switch-statement return ParseSwitchStatement(TrailingElseLoc); case tok::kw_while: // C99 6.8.5.1: while-statement return ParseWhileStatement(TrailingElseLoc); case tok::kw_do: // C99 6.8.5.2: do-statement Res = ParseDoStatement(); SemiError = &quot;do/while&quot;; break; case tok::kw_for: // C99 6.8.5.3: for-statement return ParseForStatement(TrailingElseLoc); case tok::kw_goto: // C99 6.8.6.1: goto-statement Res = ParseGotoStatement(); SemiError = &quot;goto&quot;; break; case tok::kw_continue: // C99 6.8.6.2: continue-statement Res = ParseContinueStatement(); SemiError = &quot;continue&quot;; break; case tok::kw_break: // C99 6.8.6.3: break-statement Res = ParseBreakStatement(); SemiError = &quot;break&quot;; break; case tok::kw_return: // C99 6.8.6.4: return-statement Res = ParseReturnStatement(); SemiError = &quot;return&quot;; break; } return Res; } 关键代码如上，可以看到针对对应的关键字，调用对应的 Parse。这里就不继续跟踪了，有兴趣可以深入了解。 可以发现的是，Action 穿插在代码中，Parse 到指定位置，则调用相应的语义动作进行检查，这样就不需要在 Parse 完成后，遍历一次语法树，且代码简介易于编写。" />
<meta property="og:description" content="前面部分分析了初始化流程，紧接着分析的是 Parse 部分。 所有 Action 的基类是 FrontendAction，在 FrontendAction 的 Execute 中发现： bool FrontendAction::Execute() { CompilerInstance &amp;CI = getCompilerInstance(); if (CI.hasFrontendTimer()) { llvm::TimeRegion Timer(CI.getFrontendTimer()); ExecuteAction(); } else ExecuteAction(); // .... return true; } 流程转入了 ExecuteAction 中，目前的 Act 是 EmitLLVMAction： class EmitLLVMAction : public CodeGenAction { virtual void anchor(); public: EmitLLVMAction(llvm::LLVMContext *_VMContext = nullptr); }; 实际上 EmitLLVMAction 只是 CodeGenAction 的一个子类。所以应该在 CodeGenAction 中找 Execute 的逻辑。 void CodeGenAction::ExecuteAction() { // If this is an IR file, we have to treat it specially. if (getCurrentFileKind() == IK_LLVM_IR) { // other codes. } // Otherwise follow the normal AST path. this-&gt;ASTFrontendAction::ExecuteAction(); } 所以在 CodeGenAction::ExecuteAction 中，直接使用了 ASTFrontendAction::ExecuteAction 的实现。找到 ASTFrontendAction 对应的 ExecuteAction： void ASTFrontendAction::ExecuteAction() { ParseAST(CI.getSema(), CI.getFrontendOpts().ShowStats, CI.getFrontendOpts().SkipFunctionBodies); } 这里截取了重要的部分代码。跟踪 ParseAST，截取代码如下： void clang::ParseAST(Sema &amp;S, bool PrintStats, bool SkipFunctionBodies) { ASTConsumer *Consumer = &amp;S.getASTConsumer(); std::unique_ptr&lt;Parser&gt; ParseOP( new Parser(S.getPreprocessor(), S, SkipFunctionBodies)); Parser &amp;P = *ParseOP.get(); S.getPreprocessor().EnterMainSourceFile(); P.Initialize(); if (P.ParseTopLevelDecl(ADecl)) { if (!External &amp;&amp; !S.getLangOpts().CPlusPlus) P.Diag(diag::ext_empty_translation_unit); } else { do { // If we got a null return and something *was* parsed, ignore it. This // is due to a top-level semicolon, an action override, or a parse error // skipping something. if (ADecl &amp;&amp; !Consumer-&gt;HandleTopLevelDecl(ADecl.get())) return; } while (!P.ParseTopLevelDecl(ADecl)); } // Process any TopLevelDecls generated by #pragma weak. for (Decl *D : S.WeakTopLevelDecls()) Consumer-&gt;HandleTopLevelDecl(DeclGroupRef(D)); Consumer-&gt;HandleTranslationUnit(S.getASTContext()); } Parse 通过 ParseTopLevelDecl 得到 Decl ，然后通过 ASTConsumer 的 HandleTopLevelDecl 处理。忽略其他现在并不关心的部分，在 ParseTopLevelDecl 内部调用 ParseExternalDeclaration 开始。而 ParseExternalDeclaration 内部，我们只关心下面一行代码： return ParseDeclarationOrFunctionDefinition(attrs, DS); 这里处理声明或者函数定义，内部有一个 Internal 包含。这其中分为两部分，一部分是 ParseDeclarationSpecifiers；另一部分是最后的 ParseDeclGroup。 第一部分用于获取类型说明符，第二部分则是具体声明部分，这里重点看第二部分： Parser::DeclGroupPtrTy Parser::ParseDeclGroup(ParsingDeclSpec &amp;DS, unsigned Context, SourceLocation *DeclEnd, ForRangeInit *FRI) { // Parse the first declarator. ParsingDeclarator D(*this, DS, static_cast&lt;Declarator::TheContext&gt;(Context)); ParseDeclarator(D); // Check to see if we have a function *definition* which must have a body. if (D.isFunctionDeclarator() &amp;&amp; !isDeclarationAfterDeclarator()) { Decl *TheDecl = ParseFunctionDefinition(D, ParsedTemplateInfo(), &amp;LateParsedAttrs); return Actions.ConvertDeclToDeclGroup(TheDecl); } SmallVector&lt;Decl *, 8&gt; DeclsInGroup; Decl *FirstDecl = ParseDeclarationAfterDeclaratorAndAttributes( D, ParsedTemplateInfo(), FRI); // If we don&#39;t have a comma, it is either the end of the list (a &#39;;&#39;) or an // error, bail out. SourceLocation CommaLoc; while (TryConsumeToken(tok::comma, CommaLoc)) { ParseDeclarator(D); if (!D.isInvalidType()) { Decl *ThisDecl = ParseDeclarationAfterDeclarator(D); } } } ParseDeclGroup 的结构大致如上，首先使用 ParseDeclarator 获取一个声明，比如 int i; 这里得到的就是 i，然后判断是否紧接 ()，如果是，则调用 ParseFunctionDefinition 分析函数定义，否则循环调用 ParseDeclarator 获取所有声明的变量。 对于声明而言，需要调用 ParseDeclarationAfterDeclarator 将类型与 declarator 结合，形成一个完整的声明。ParseDeclarationAfterDeclarator 中调用了 ParseDeclarationAfterDeclaratorAndAttributes, 而 ParseDeclarationAfterDeclaratorAndAttributes 中实际调用了 Actions.ActOnDeclarator，ActOnDeclarator 实际调用了 HandleDeclarator。 在 HandleDeclarator 中，实际的工作有三个，首先调用 GetTypeForDeclarator; 得到类型信息，因为各个类型实际上只有一个实例，所以这里需要映射过程。其次调用以下几个中的某一个: ActOnTypedefDeclarator ActOnFunctionDeclarator ActOnVariableDeclarator 最后，调用 PushOnScopeChains 将声明存起来。保存起来的 declarator 的信息可以用于处理下一次遇到 declarator 判断是否符合语法。 现在回头看 ParseFunctionDefinition 部分。节选代码如下： Decl *Parser::ParseFunctionDefinition(ParsingDeclarator &amp;D, const ParsedTemplateInfo &amp;TemplateInfo, LateParsedAttrList *LateParsedAttrs) { // Enter a scope for the function body. ParseScope BodyScope(this, Scope::FnScope|Scope::DeclScope); // Tell the actions module that we have entered a function definition with the // specified Declarator for the function. Decl *Res = Actions.ActOnStartOfFunctionDef(getCurScope(), D, TemplateInfo.TemplateParams ? *TemplateInfo.TemplateParams : MultiTemplateParamsArg(), &amp;SkipBody); return ParseFunctionStatementBody(Res, BodyScope); } 首先进入函数作用域，执行相应的 Action，最后调用 ParseFunctionStatementBody 开始解析函数部分。 Decl *Parser::ParseFunctionStatementBody(Decl *Decl, ParseScope &amp;BodyScope) { // Do not enter a scope for the brace, as the arguments are in the same scope // (the function body) as the body itself. Instead, just read the statement // list and put it into a CompoundStmt for safe keeping. StmtResult FnBody(ParseCompoundStatementBody()); BodyScope.Exit(); return Actions.ActOnFinishFunctionBody(Decl, FnBody.get()); } ParseFunctionStatementBody 中最重要的一句是: StmtResult FnBody(ParseCompoundStatementBody()); 然后就是退出作用域，执行相应的 Action。继续跟进 ParseCompoundStatementBody。 在 ParseCompoundStatementBody 中，暂时忽略 kw__extension__ 的情况，于是，实际的调用为 ParseStatementOrDeclaration，其中又调用了 ParseStatementOrDeclarationAfterAttributes，这个函数就是正式进行分析的代码部分： StmtResult Parser::ParseStatementOrDeclarationAfterAttributes(StmtVector &amp;Stmts, AllowedContsructsKind Allowed, SourceLocation *TrailingElseLoc, ParsedAttributesWithRange &amp;Attrs) { switch (Kind) { case tok::identifier: { Token Next = NextToken(); if (Next.is(tok::colon)) { // C99 6.8.1: labeled-statement // identifier &#39;:&#39; statement return ParseLabeledStatement(Attrs); } // Look up the identifier, and typo-correct it to a keyword if it&#39;s not // found. if (Next.isNot(tok::coloncolon)) { // Try to limit which sets of keywords should be included in typo // correction based on what the next token is. if (TryAnnotateName(/*IsAddressOfOperand*/ false, llvm::make_unique&lt;StatementFilterCCC&gt;(Next)) == ANK_Error) { // Handle errors here by skipping up to the next semicolon or &#39;}&#39;, and // eat the semicolon if that&#39;s what stopped us. SkipUntil(tok::r_brace, StopAtSemi | StopBeforeMatch); if (Tok.is(tok::semi)) ConsumeToken(); return StmtError(); } // If the identifier was typo-corrected, try again. if (Tok.isNot(tok::identifier)) goto Retry; } // Fall through } default: { if ((getLangOpts().CPlusPlus || Allowed == ACK_Any) &amp;&amp; isDeclarationStatement()) { SourceLocation DeclStart = Tok.getLocation(), DeclEnd; DeclGroupPtrTy Decl = ParseDeclaration(Declarator::BlockContext, DeclEnd, Attrs); return Actions.ActOnDeclStmt(Decl, DeclStart, DeclEnd); } if (Tok.is(tok::r_brace)) { Diag(Tok, diag::err_expected_statement); return StmtError(); } return ParseExprStatement(); } case tok::kw_case: // C99 6.8.1: labeled-statement return ParseCaseStatement(); case tok::kw_default: // C99 6.8.1: labeled-statement return ParseDefaultStatement(); case tok::l_brace: // C99 6.8.2: compound-statement return ParseCompoundStatement(); case tok::semi: { // C99 6.8.3p3: expression[opt] &#39;;&#39; bool HasLeadingEmptyMacro = Tok.hasLeadingEmptyMacro(); return Actions.ActOnNullStmt(ConsumeToken(), HasLeadingEmptyMacro); } case tok::kw_if: // C99 6.8.4.1: if-statement return ParseIfStatement(TrailingElseLoc); case tok::kw_switch: // C99 6.8.4.2: switch-statement return ParseSwitchStatement(TrailingElseLoc); case tok::kw_while: // C99 6.8.5.1: while-statement return ParseWhileStatement(TrailingElseLoc); case tok::kw_do: // C99 6.8.5.2: do-statement Res = ParseDoStatement(); SemiError = &quot;do/while&quot;; break; case tok::kw_for: // C99 6.8.5.3: for-statement return ParseForStatement(TrailingElseLoc); case tok::kw_goto: // C99 6.8.6.1: goto-statement Res = ParseGotoStatement(); SemiError = &quot;goto&quot;; break; case tok::kw_continue: // C99 6.8.6.2: continue-statement Res = ParseContinueStatement(); SemiError = &quot;continue&quot;; break; case tok::kw_break: // C99 6.8.6.3: break-statement Res = ParseBreakStatement(); SemiError = &quot;break&quot;; break; case tok::kw_return: // C99 6.8.6.4: return-statement Res = ParseReturnStatement(); SemiError = &quot;return&quot;; break; } return Res; } 关键代码如上，可以看到针对对应的关键字，调用对应的 Parse。这里就不继续跟踪了，有兴趣可以深入了解。 可以发现的是，Action 穿插在代码中，Parse 到指定位置，则调用相应的语义动作进行检查，这样就不需要在 Parse 完成后，遍历一次语法树，且代码简介易于编写。" />
<link rel="canonical" href="/clang/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2016/07/01/Clang-Source-Code-Analysis-2.html" />
<meta property="og:url" content="/clang/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2016/07/01/Clang-Source-Code-Analysis-2.html" />
<meta property="og:site_name" content="W41ter’s Bistro" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-07-01T23:05:21+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Clang Source Code Analysis (2)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-07-01T23:05:21+08:00","datePublished":"2016-07-01T23:05:21+08:00","description":"前面部分分析了初始化流程，紧接着分析的是 Parse 部分。 所有 Action 的基类是 FrontendAction，在 FrontendAction 的 Execute 中发现： bool FrontendAction::Execute() { CompilerInstance &amp;CI = getCompilerInstance(); if (CI.hasFrontendTimer()) { llvm::TimeRegion Timer(CI.getFrontendTimer()); ExecuteAction(); } else ExecuteAction(); // .... return true; } 流程转入了 ExecuteAction 中，目前的 Act 是 EmitLLVMAction： class EmitLLVMAction : public CodeGenAction { virtual void anchor(); public: EmitLLVMAction(llvm::LLVMContext *_VMContext = nullptr); }; 实际上 EmitLLVMAction 只是 CodeGenAction 的一个子类。所以应该在 CodeGenAction 中找 Execute 的逻辑。 void CodeGenAction::ExecuteAction() { // If this is an IR file, we have to treat it specially. if (getCurrentFileKind() == IK_LLVM_IR) { // other codes. } // Otherwise follow the normal AST path. this-&gt;ASTFrontendAction::ExecuteAction(); } 所以在 CodeGenAction::ExecuteAction 中，直接使用了 ASTFrontendAction::ExecuteAction 的实现。找到 ASTFrontendAction 对应的 ExecuteAction： void ASTFrontendAction::ExecuteAction() { ParseAST(CI.getSema(), CI.getFrontendOpts().ShowStats, CI.getFrontendOpts().SkipFunctionBodies); } 这里截取了重要的部分代码。跟踪 ParseAST，截取代码如下： void clang::ParseAST(Sema &amp;S, bool PrintStats, bool SkipFunctionBodies) { ASTConsumer *Consumer = &amp;S.getASTConsumer(); std::unique_ptr&lt;Parser&gt; ParseOP( new Parser(S.getPreprocessor(), S, SkipFunctionBodies)); Parser &amp;P = *ParseOP.get(); S.getPreprocessor().EnterMainSourceFile(); P.Initialize(); if (P.ParseTopLevelDecl(ADecl)) { if (!External &amp;&amp; !S.getLangOpts().CPlusPlus) P.Diag(diag::ext_empty_translation_unit); } else { do { // If we got a null return and something *was* parsed, ignore it. This // is due to a top-level semicolon, an action override, or a parse error // skipping something. if (ADecl &amp;&amp; !Consumer-&gt;HandleTopLevelDecl(ADecl.get())) return; } while (!P.ParseTopLevelDecl(ADecl)); } // Process any TopLevelDecls generated by #pragma weak. for (Decl *D : S.WeakTopLevelDecls()) Consumer-&gt;HandleTopLevelDecl(DeclGroupRef(D)); Consumer-&gt;HandleTranslationUnit(S.getASTContext()); } Parse 通过 ParseTopLevelDecl 得到 Decl ，然后通过 ASTConsumer 的 HandleTopLevelDecl 处理。忽略其他现在并不关心的部分，在 ParseTopLevelDecl 内部调用 ParseExternalDeclaration 开始。而 ParseExternalDeclaration 内部，我们只关心下面一行代码： return ParseDeclarationOrFunctionDefinition(attrs, DS); 这里处理声明或者函数定义，内部有一个 Internal 包含。这其中分为两部分，一部分是 ParseDeclarationSpecifiers；另一部分是最后的 ParseDeclGroup。 第一部分用于获取类型说明符，第二部分则是具体声明部分，这里重点看第二部分： Parser::DeclGroupPtrTy Parser::ParseDeclGroup(ParsingDeclSpec &amp;DS, unsigned Context, SourceLocation *DeclEnd, ForRangeInit *FRI) { // Parse the first declarator. ParsingDeclarator D(*this, DS, static_cast&lt;Declarator::TheContext&gt;(Context)); ParseDeclarator(D); // Check to see if we have a function *definition* which must have a body. if (D.isFunctionDeclarator() &amp;&amp; !isDeclarationAfterDeclarator()) { Decl *TheDecl = ParseFunctionDefinition(D, ParsedTemplateInfo(), &amp;LateParsedAttrs); return Actions.ConvertDeclToDeclGroup(TheDecl); } SmallVector&lt;Decl *, 8&gt; DeclsInGroup; Decl *FirstDecl = ParseDeclarationAfterDeclaratorAndAttributes( D, ParsedTemplateInfo(), FRI); // If we don&#39;t have a comma, it is either the end of the list (a &#39;;&#39;) or an // error, bail out. SourceLocation CommaLoc; while (TryConsumeToken(tok::comma, CommaLoc)) { ParseDeclarator(D); if (!D.isInvalidType()) { Decl *ThisDecl = ParseDeclarationAfterDeclarator(D); } } } ParseDeclGroup 的结构大致如上，首先使用 ParseDeclarator 获取一个声明，比如 int i; 这里得到的就是 i，然后判断是否紧接 ()，如果是，则调用 ParseFunctionDefinition 分析函数定义，否则循环调用 ParseDeclarator 获取所有声明的变量。 对于声明而言，需要调用 ParseDeclarationAfterDeclarator 将类型与 declarator 结合，形成一个完整的声明。ParseDeclarationAfterDeclarator 中调用了 ParseDeclarationAfterDeclaratorAndAttributes, 而 ParseDeclarationAfterDeclaratorAndAttributes 中实际调用了 Actions.ActOnDeclarator，ActOnDeclarator 实际调用了 HandleDeclarator。 在 HandleDeclarator 中，实际的工作有三个，首先调用 GetTypeForDeclarator; 得到类型信息，因为各个类型实际上只有一个实例，所以这里需要映射过程。其次调用以下几个中的某一个: ActOnTypedefDeclarator ActOnFunctionDeclarator ActOnVariableDeclarator 最后，调用 PushOnScopeChains 将声明存起来。保存起来的 declarator 的信息可以用于处理下一次遇到 declarator 判断是否符合语法。 现在回头看 ParseFunctionDefinition 部分。节选代码如下： Decl *Parser::ParseFunctionDefinition(ParsingDeclarator &amp;D, const ParsedTemplateInfo &amp;TemplateInfo, LateParsedAttrList *LateParsedAttrs) { // Enter a scope for the function body. ParseScope BodyScope(this, Scope::FnScope|Scope::DeclScope); // Tell the actions module that we have entered a function definition with the // specified Declarator for the function. Decl *Res = Actions.ActOnStartOfFunctionDef(getCurScope(), D, TemplateInfo.TemplateParams ? *TemplateInfo.TemplateParams : MultiTemplateParamsArg(), &amp;SkipBody); return ParseFunctionStatementBody(Res, BodyScope); } 首先进入函数作用域，执行相应的 Action，最后调用 ParseFunctionStatementBody 开始解析函数部分。 Decl *Parser::ParseFunctionStatementBody(Decl *Decl, ParseScope &amp;BodyScope) { // Do not enter a scope for the brace, as the arguments are in the same scope // (the function body) as the body itself. Instead, just read the statement // list and put it into a CompoundStmt for safe keeping. StmtResult FnBody(ParseCompoundStatementBody()); BodyScope.Exit(); return Actions.ActOnFinishFunctionBody(Decl, FnBody.get()); } ParseFunctionStatementBody 中最重要的一句是: StmtResult FnBody(ParseCompoundStatementBody()); 然后就是退出作用域，执行相应的 Action。继续跟进 ParseCompoundStatementBody。 在 ParseCompoundStatementBody 中，暂时忽略 kw__extension__ 的情况，于是，实际的调用为 ParseStatementOrDeclaration，其中又调用了 ParseStatementOrDeclarationAfterAttributes，这个函数就是正式进行分析的代码部分： StmtResult Parser::ParseStatementOrDeclarationAfterAttributes(StmtVector &amp;Stmts, AllowedContsructsKind Allowed, SourceLocation *TrailingElseLoc, ParsedAttributesWithRange &amp;Attrs) { switch (Kind) { case tok::identifier: { Token Next = NextToken(); if (Next.is(tok::colon)) { // C99 6.8.1: labeled-statement // identifier &#39;:&#39; statement return ParseLabeledStatement(Attrs); } // Look up the identifier, and typo-correct it to a keyword if it&#39;s not // found. if (Next.isNot(tok::coloncolon)) { // Try to limit which sets of keywords should be included in typo // correction based on what the next token is. if (TryAnnotateName(/*IsAddressOfOperand*/ false, llvm::make_unique&lt;StatementFilterCCC&gt;(Next)) == ANK_Error) { // Handle errors here by skipping up to the next semicolon or &#39;}&#39;, and // eat the semicolon if that&#39;s what stopped us. SkipUntil(tok::r_brace, StopAtSemi | StopBeforeMatch); if (Tok.is(tok::semi)) ConsumeToken(); return StmtError(); } // If the identifier was typo-corrected, try again. if (Tok.isNot(tok::identifier)) goto Retry; } // Fall through } default: { if ((getLangOpts().CPlusPlus || Allowed == ACK_Any) &amp;&amp; isDeclarationStatement()) { SourceLocation DeclStart = Tok.getLocation(), DeclEnd; DeclGroupPtrTy Decl = ParseDeclaration(Declarator::BlockContext, DeclEnd, Attrs); return Actions.ActOnDeclStmt(Decl, DeclStart, DeclEnd); } if (Tok.is(tok::r_brace)) { Diag(Tok, diag::err_expected_statement); return StmtError(); } return ParseExprStatement(); } case tok::kw_case: // C99 6.8.1: labeled-statement return ParseCaseStatement(); case tok::kw_default: // C99 6.8.1: labeled-statement return ParseDefaultStatement(); case tok::l_brace: // C99 6.8.2: compound-statement return ParseCompoundStatement(); case tok::semi: { // C99 6.8.3p3: expression[opt] &#39;;&#39; bool HasLeadingEmptyMacro = Tok.hasLeadingEmptyMacro(); return Actions.ActOnNullStmt(ConsumeToken(), HasLeadingEmptyMacro); } case tok::kw_if: // C99 6.8.4.1: if-statement return ParseIfStatement(TrailingElseLoc); case tok::kw_switch: // C99 6.8.4.2: switch-statement return ParseSwitchStatement(TrailingElseLoc); case tok::kw_while: // C99 6.8.5.1: while-statement return ParseWhileStatement(TrailingElseLoc); case tok::kw_do: // C99 6.8.5.2: do-statement Res = ParseDoStatement(); SemiError = &quot;do/while&quot;; break; case tok::kw_for: // C99 6.8.5.3: for-statement return ParseForStatement(TrailingElseLoc); case tok::kw_goto: // C99 6.8.6.1: goto-statement Res = ParseGotoStatement(); SemiError = &quot;goto&quot;; break; case tok::kw_continue: // C99 6.8.6.2: continue-statement Res = ParseContinueStatement(); SemiError = &quot;continue&quot;; break; case tok::kw_break: // C99 6.8.6.3: break-statement Res = ParseBreakStatement(); SemiError = &quot;break&quot;; break; case tok::kw_return: // C99 6.8.6.4: return-statement Res = ParseReturnStatement(); SemiError = &quot;return&quot;; break; } return Res; } 关键代码如上，可以看到针对对应的关键字，调用对应的 Parse。这里就不继续跟踪了，有兴趣可以深入了解。 可以发现的是，Action 穿插在代码中，Parse 到指定位置，则调用相应的语义动作进行检查，这样就不需要在 Parse 完成后，遍历一次语法树，且代码简介易于编写。","headline":"Clang Source Code Analysis (2)","mainEntityOfPage":{"@type":"WebPage","@id":"/clang/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2016/07/01/Clang-Source-Code-Analysis-2.html"},"url":"/clang/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2016/07/01/Clang-Source-Code-Analysis-2.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="W41ter's Bistro" /><!-- for mathjax support -->
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">W41ter&#39;s Bistro</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Clang Source Code Analysis (2)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-07-01T23:05:21+08:00" itemprop="datePublished">Jul 1, 2016
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>前面部分分析了初始化流程，紧接着分析的是 Parse 部分。</p>

<p>所有 <code class="language-plaintext highlighter-rouge">Action</code> 的基类是 <code class="language-plaintext highlighter-rouge">FrontendAction</code>，在 <code class="language-plaintext highlighter-rouge">FrontendAction</code> 的 <code class="language-plaintext highlighter-rouge">Execute</code> 中发现：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool FrontendAction::Execute() {
  CompilerInstance &amp;CI = getCompilerInstance();

  if (CI.hasFrontendTimer()) {
    llvm::TimeRegion Timer(CI.getFrontendTimer());
    ExecuteAction();
  }
  else ExecuteAction();

  // ....

  return true;
}
</code></pre></div></div>

<p>流程转入了 <code class="language-plaintext highlighter-rouge">ExecuteAction</code> 中，目前的 <code class="language-plaintext highlighter-rouge">Act</code> 是 <code class="language-plaintext highlighter-rouge">EmitLLVMAction</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class EmitLLVMAction : public CodeGenAction {
  virtual void anchor();
public:
  EmitLLVMAction(llvm::LLVMContext *_VMContext = nullptr);
};
</code></pre></div></div>

<p>实际上 <code class="language-plaintext highlighter-rouge">EmitLLVMAction</code> 只是 <code class="language-plaintext highlighter-rouge">CodeGenAction</code> 的一个子类。所以应该在 <code class="language-plaintext highlighter-rouge">CodeGenAction</code> 中找 <code class="language-plaintext highlighter-rouge">Execute</code> 的逻辑。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void CodeGenAction::ExecuteAction() {
  // If this is an IR file, we have to treat it specially.
  if (getCurrentFileKind() == IK_LLVM_IR) {
    // other codes.
  }

  // Otherwise follow the normal AST path.
  this-&gt;ASTFrontendAction::ExecuteAction();
}
</code></pre></div></div>

<p>所以在 <code class="language-plaintext highlighter-rouge">CodeGenAction::ExecuteAction</code> 中，直接使用了 <code class="language-plaintext highlighter-rouge">ASTFrontendAction::ExecuteAction</code> 的实现。找到 <code class="language-plaintext highlighter-rouge">ASTFrontendAction</code> 对应的 <code class="language-plaintext highlighter-rouge">ExecuteAction</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void ASTFrontendAction::ExecuteAction() {
  ParseAST(CI.getSema(), CI.getFrontendOpts().ShowStats,
           CI.getFrontendOpts().SkipFunctionBodies);
}
</code></pre></div></div>

<p>这里截取了重要的部分代码。跟踪 <code class="language-plaintext highlighter-rouge">ParseAST</code>，截取代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void clang::ParseAST(Sema &amp;S, bool PrintStats, bool SkipFunctionBodies) {
  ASTConsumer *Consumer = &amp;S.getASTConsumer();

  std::unique_ptr&lt;Parser&gt; ParseOP(
      new Parser(S.getPreprocessor(), S, SkipFunctionBodies));
  Parser &amp;P = *ParseOP.get();

  S.getPreprocessor().EnterMainSourceFile();
  P.Initialize();

  if (P.ParseTopLevelDecl(ADecl)) {
    if (!External &amp;&amp; !S.getLangOpts().CPlusPlus)
      P.Diag(diag::ext_empty_translation_unit);
  } else {
    do {
      // If we got a null return and something *was* parsed, ignore it.  This
      // is due to a top-level semicolon, an action override, or a parse error
      // skipping something.
      if (ADecl &amp;&amp; !Consumer-&gt;HandleTopLevelDecl(ADecl.get()))
        return;
    } while (!P.ParseTopLevelDecl(ADecl));
  }

  // Process any TopLevelDecls generated by #pragma weak.
  for (Decl *D : S.WeakTopLevelDecls())
    Consumer-&gt;HandleTopLevelDecl(DeclGroupRef(D));
  
  Consumer-&gt;HandleTranslationUnit(S.getASTContext());
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Parse</code> 通过 <code class="language-plaintext highlighter-rouge">ParseTopLevelDecl</code> 得到 Decl ，然后通过 <code class="language-plaintext highlighter-rouge">ASTConsumer</code> 的 <code class="language-plaintext highlighter-rouge">HandleTopLevelDecl</code> 处理。忽略其他现在并不关心的部分，在 <code class="language-plaintext highlighter-rouge">ParseTopLevelDecl</code> 内部调用 <code class="language-plaintext highlighter-rouge">ParseExternalDeclaration</code> 开始。而 <code class="language-plaintext highlighter-rouge">ParseExternalDeclaration</code> 内部，我们只关心下面一行代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return ParseDeclarationOrFunctionDefinition(attrs, DS);
</code></pre></div></div>

<p>这里处理声明或者函数定义，内部有一个 Internal 包含。这其中分为两部分，一部分是 <code class="language-plaintext highlighter-rouge">ParseDeclarationSpecifiers</code>；另一部分是最后的 <code class="language-plaintext highlighter-rouge">ParseDeclGroup</code>。 第一部分用于获取类型说明符，第二部分则是具体声明部分，这里重点看第二部分：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Parser::DeclGroupPtrTy Parser::ParseDeclGroup(ParsingDeclSpec &amp;DS,
                                              unsigned Context,
                                              SourceLocation *DeclEnd,
                                              ForRangeInit *FRI) {
  // Parse the first declarator.
  ParsingDeclarator D(*this, DS, static_cast&lt;Declarator::TheContext&gt;(Context));
  ParseDeclarator(D);

  // Check to see if we have a function *definition* which must have a body.
  if (D.isFunctionDeclarator() &amp;&amp; !isDeclarationAfterDeclarator()) {
      Decl *TheDecl =
          ParseFunctionDefinition(D, ParsedTemplateInfo(), &amp;LateParsedAttrs);
        return Actions.ConvertDeclToDeclGroup(TheDecl);
  }

  SmallVector&lt;Decl *, 8&gt; DeclsInGroup;
  Decl *FirstDecl = ParseDeclarationAfterDeclaratorAndAttributes(
      D, ParsedTemplateInfo(), FRI);

  // If we don't have a comma, it is either the end of the list (a ';') or an
  // error, bail out.
  SourceLocation CommaLoc;
  while (TryConsumeToken(tok::comma, CommaLoc)) {
    ParseDeclarator(D);
    if (!D.isInvalidType()) {
      Decl *ThisDecl = ParseDeclarationAfterDeclarator(D);
    }
  }
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ParseDeclGroup</code> 的结构大致如上，首先使用 <code class="language-plaintext highlighter-rouge">ParseDeclarator</code> 获取一个声明，比如 <code class="language-plaintext highlighter-rouge">int i;</code> 这里得到的就是 <code class="language-plaintext highlighter-rouge">i</code>，然后判断是否紧接 <code class="language-plaintext highlighter-rouge">()</code>，如果是，则调用 <code class="language-plaintext highlighter-rouge">ParseFunctionDefinition</code> 分析函数定义，否则循环调用 <code class="language-plaintext highlighter-rouge">ParseDeclarator</code> 获取所有声明的变量。</p>

<p>对于声明而言，需要调用 <code class="language-plaintext highlighter-rouge">ParseDeclarationAfterDeclarator</code> 将类型与 <code class="language-plaintext highlighter-rouge">declarator</code> 结合，形成一个完整的声明。<code class="language-plaintext highlighter-rouge">ParseDeclarationAfterDeclarator</code> 中调用了 <code class="language-plaintext highlighter-rouge">ParseDeclarationAfterDeclaratorAndAttributes</code>, 而 <code class="language-plaintext highlighter-rouge">ParseDeclarationAfterDeclaratorAndAttributes</code> 中实际调用了 <code class="language-plaintext highlighter-rouge">Actions.ActOnDeclarator</code>，<code class="language-plaintext highlighter-rouge">ActOnDeclarator</code> 实际调用了 <code class="language-plaintext highlighter-rouge">HandleDeclarator</code>。</p>

<p>在 <code class="language-plaintext highlighter-rouge">HandleDeclarator</code> 中，实际的工作有三个，首先调用 <code class="language-plaintext highlighter-rouge">GetTypeForDeclarator</code>; 得到类型信息，因为各个类型实际上只有一个实例，所以这里需要映射过程。其次调用以下几个中的某一个:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ActOnTypedefDeclarator
ActOnFunctionDeclarator
ActOnVariableDeclarator
</code></pre></div></div>

<p>最后，调用 <code class="language-plaintext highlighter-rouge">PushOnScopeChains</code> 将声明存起来。保存起来的 <code class="language-plaintext highlighter-rouge">declarator</code> 的信息可以用于处理下一次遇到 <code class="language-plaintext highlighter-rouge">declarator</code> 判断是否符合语法。</p>

<p>现在回头看 <code class="language-plaintext highlighter-rouge">ParseFunctionDefinition</code> 部分。节选代码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Decl *Parser::ParseFunctionDefinition(ParsingDeclarator &amp;D,
                                      const ParsedTemplateInfo &amp;TemplateInfo,
                                      LateParsedAttrList *LateParsedAttrs) {
  // Enter a scope for the function body.
  ParseScope BodyScope(this, Scope::FnScope|Scope::DeclScope);

  // Tell the actions module that we have entered a function definition with the
  // specified Declarator for the function.
  Decl *Res = Actions.ActOnStartOfFunctionDef(getCurScope(), D,
                                              TemplateInfo.TemplateParams
                                                  ? *TemplateInfo.TemplateParams
                                                  : MultiTemplateParamsArg(),
                                              &amp;SkipBody);

  return ParseFunctionStatementBody(Res, BodyScope);
}
</code></pre></div></div>

<p>首先进入函数作用域，执行相应的 <code class="language-plaintext highlighter-rouge">Action</code>，最后调用 <code class="language-plaintext highlighter-rouge">ParseFunctionStatementBody</code> 开始解析函数部分。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Decl *Parser::ParseFunctionStatementBody(Decl *Decl, ParseScope &amp;BodyScope) {
  // Do not enter a scope for the brace, as the arguments are in the same scope
  // (the function body) as the body itself.  Instead, just read the statement
  // list and put it into a CompoundStmt for safe keeping.
  StmtResult FnBody(ParseCompoundStatementBody());

  BodyScope.Exit();
  return Actions.ActOnFinishFunctionBody(Decl, FnBody.get());
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ParseFunctionStatementBody</code> 中最重要的一句是:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>StmtResult FnBody(ParseCompoundStatementBody());
</code></pre></div></div>

<p>然后就是退出作用域，执行相应的 <code class="language-plaintext highlighter-rouge">Action</code>。继续跟进 <code class="language-plaintext highlighter-rouge">ParseCompoundStatementBody</code>。</p>

<p>在 <code class="language-plaintext highlighter-rouge">ParseCompoundStatementBody</code> 中，暂时忽略 <code class="language-plaintext highlighter-rouge">kw__extension__</code> 的情况，于是，实际的调用为 <code class="language-plaintext highlighter-rouge">ParseStatementOrDeclaration</code>，其中又调用了 <code class="language-plaintext highlighter-rouge">ParseStatementOrDeclarationAfterAttributes</code>，这个函数就是正式进行分析的代码部分：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>StmtResult
Parser::ParseStatementOrDeclarationAfterAttributes(StmtVector &amp;Stmts,
          AllowedContsructsKind Allowed, SourceLocation *TrailingElseLoc,
          ParsedAttributesWithRange &amp;Attrs) {
  switch (Kind) {
  case tok::identifier: {
    Token Next = NextToken();
    if (Next.is(tok::colon)) { // C99 6.8.1: labeled-statement
      // identifier ':' statement
      return ParseLabeledStatement(Attrs);
    }

    // Look up the identifier, and typo-correct it to a keyword if it's not
    // found.
    if (Next.isNot(tok::coloncolon)) {
      // Try to limit which sets of keywords should be included in typo
      // correction based on what the next token is.
      if (TryAnnotateName(/*IsAddressOfOperand*/ false,
                          llvm::make_unique&lt;StatementFilterCCC&gt;(Next)) ==
          ANK_Error) {
        // Handle errors here by skipping up to the next semicolon or '}', and
        // eat the semicolon if that's what stopped us.
        SkipUntil(tok::r_brace, StopAtSemi | StopBeforeMatch);
        if (Tok.is(tok::semi))
          ConsumeToken();
        return StmtError();
      }

      // If the identifier was typo-corrected, try again.
      if (Tok.isNot(tok::identifier))
        goto Retry;
    }

    // Fall through
  }

  default: {
    if ((getLangOpts().CPlusPlus || Allowed == ACK_Any) &amp;&amp;
        isDeclarationStatement()) {
      SourceLocation DeclStart = Tok.getLocation(), DeclEnd;
      DeclGroupPtrTy Decl = ParseDeclaration(Declarator::BlockContext,
                                             DeclEnd, Attrs);
      return Actions.ActOnDeclStmt(Decl, DeclStart, DeclEnd);
    }

    if (Tok.is(tok::r_brace)) {
      Diag(Tok, diag::err_expected_statement);
      return StmtError();
    }

    return ParseExprStatement();
  }

  case tok::kw_case:                // C99 6.8.1: labeled-statement
    return ParseCaseStatement();
  case tok::kw_default:             // C99 6.8.1: labeled-statement
    return ParseDefaultStatement();

  case tok::l_brace:                // C99 6.8.2: compound-statement
    return ParseCompoundStatement();
  case tok::semi: {                 // C99 6.8.3p3: expression[opt] ';'
    bool HasLeadingEmptyMacro = Tok.hasLeadingEmptyMacro();
    return Actions.ActOnNullStmt(ConsumeToken(), HasLeadingEmptyMacro);
  }

  case tok::kw_if:                  // C99 6.8.4.1: if-statement
    return ParseIfStatement(TrailingElseLoc);
  case tok::kw_switch:              // C99 6.8.4.2: switch-statement
    return ParseSwitchStatement(TrailingElseLoc);

  case tok::kw_while:               // C99 6.8.5.1: while-statement
    return ParseWhileStatement(TrailingElseLoc);
  case tok::kw_do:                  // C99 6.8.5.2: do-statement
    Res = ParseDoStatement();
    SemiError = "do/while";
    break;
  case tok::kw_for:                 // C99 6.8.5.3: for-statement
    return ParseForStatement(TrailingElseLoc);

  case tok::kw_goto:                // C99 6.8.6.1: goto-statement
    Res = ParseGotoStatement();
    SemiError = "goto";
    break;
  case tok::kw_continue:            // C99 6.8.6.2: continue-statement
    Res = ParseContinueStatement();
    SemiError = "continue";
    break;
  case tok::kw_break:               // C99 6.8.6.3: break-statement
    Res = ParseBreakStatement();
    SemiError = "break";
    break;
  case tok::kw_return:              // C99 6.8.6.4: return-statement
    Res = ParseReturnStatement();
    SemiError = "return";
    break;
  }

  return Res;
}
</code></pre></div></div>

<p>关键代码如上，可以看到针对对应的关键字，调用对应的 <code class="language-plaintext highlighter-rouge">Parse</code>。这里就不继续跟踪了，有兴趣可以深入了解。</p>

<p>可以发现的是，<code class="language-plaintext highlighter-rouge">Action</code> 穿插在代码中，<code class="language-plaintext highlighter-rouge">Parse</code> 到指定位置，则调用相应的语义动作进行检查，这样就不需要在 <code class="language-plaintext highlighter-rouge">Parse</code> 完成后，遍历一次语法树，且代码简介易于编写。</p>

  </div><a class="u-url" href="/clang/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2016/07/01/Clang-Source-Code-Analysis-2.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">W41ter&#39;s Bistro</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">W41ter&#39;s Bistro</li><li><a class="u-email" href="mailto:w41ter.l@gmail.com">w41ter.l@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/w41ter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">w41ter</span></a></li><li><a href="https://www.twitter.com/WalterM56697798"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WalterM56697798</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Focus on distributed storage system, compiler.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
