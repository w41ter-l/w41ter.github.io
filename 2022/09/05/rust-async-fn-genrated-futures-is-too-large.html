<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Rust - The async fn generated Future is too large? | W41ter’s Bistro</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Rust - The async fn generated Future is too large?" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="背景 最近开始对 engula 进行性能测试，发现 async fn 的性能损耗非常大，这不符合 zero overhead abstraction，因此开始对 async fn 的性能做一些研究。 通过增加参数 -Z print-type-size，可以输出每种类型的大小。发现很多 generator 内存大小非常大，其中最不符合直觉的是下面这几个： print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:39:69: 44:6]&gt;`: 1248 bytes, alignment: 8 bytes print-type-size field `.0`: 1248 bytes print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:79:52: 83:6]&gt;`: 1408 bytes, alignment: 8 bytes print-type-size field `.0`: 1408 bytes print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:88:51: 92:6]&gt;`: 1408 bytes, alignment: 8 bytes print-type-size field `.0`: 1408 bytes node_client.rs 是 tonic grpc client 的简单封装: use tonic::transport::Channel; #[derive(Debug, Clone)] pub struct Client { client: node_client::NodeClient&lt;Channel&gt;, } pub async fn root_heartbeat( &amp;self, req: HeartbeatRequest, ) -&gt; Result&lt;HeartbeatResponse, tonic::Status&gt; { let mut client = self.client.clone(); let res = client.root_heartbeat(req).await?; Ok(res.into_inner()) } node_client::NodeClient 是 tonic_build 生成的代码： impl&lt;T&gt; NodeClient&lt;T&gt; where T: tonic::client::GrpcService&lt;tonic::body::BoxBody&gt;, T::Error: Into&lt;StdError&gt;, T::ResponseBody: Body&lt;Data = Bytes&gt; + Send + &#39;static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;StdError&gt; + Send, { pub fn new(inner: T) -&gt; Self { let inner = tonic::client::Grpc::new(inner); Self { inner } } } pub async fn root_heartbeat( &amp;mut self, request: impl tonic::IntoRequest&lt;super::HeartbeatRequest&gt;, ) -&gt; Result&lt;tonic::Response&lt;super::HeartbeatResponse&gt;, tonic::Status&gt; { self.inner .ready() .await .map_err(|e| { tonic::Status::new( tonic::Code::Unknown, format!(&quot;Service was not ready: {}&quot;, e.into()), ) })?; let codec = tonic::codec::ProstCodec::default(); let path = http::uri::PathAndQuery::from_static( &quot;/engula.server.v1.Node/RootHeartbeat&quot;, ); self.inner.unary(request.into_request(), path, codec).await } 也就是说，每次调用 Grpc::unary 需要在栈上开辟 1K+ 的空间。如果最后使用了 tokio::spawn，那么还需要将它复制到堆上。无论是内存分配还是复制上的开销，对于一个高性能存储服务都是不可接受的。并且随着 async fn 的调用层数增加，Future 大小还会呈现指数增长，这一点我后面会分析。 Grpc::unary 的 memory layout 是怎样的？ 那么，为何 Grpc::unary 返回的 Future 需要消耗 1K+ 的内存空间呢？ 在 tonic/src/client/grpc.rs 中，unary 最终被委托给 Grpc::streaming，后者调用 Channel::call 并返回 ResponseFuture。 /// Send a single unary gRPC request. pub async fn unary&lt;M1, M2, C&gt;( &amp;mut self, request: Request&lt;M1&gt;, path: PathAndQuery, codec: C, ) -&gt; Result&lt;Response&lt;M2&gt;, Status&gt; where T: GrpcService&lt;BoxBody&gt;, T::ResponseBody: Body + Send + &#39;static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;, C: Codec&lt;Encode = M1, Decode = M2&gt;, M1: Send + Sync + &#39;static, M2: Send + Sync + &#39;static, { let request = request.map(|m| stream::once(future::ready(m))); self.client_streaming(request, path, codec).await } /// Send a client side streaming gRPC request. pub async fn client_streaming&lt;S, M1, M2, C&gt;( &amp;mut self, request: Request&lt;S&gt;, path: PathAndQuery, codec: C, ) -&gt; Result&lt;Response&lt;M2&gt;, Status&gt; where T: GrpcService&lt;BoxBody&gt;, T::ResponseBody: Body + Send + &#39;static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;, S: Stream&lt;Item = M1&gt; + Send + &#39;static, C: Codec&lt;Encode = M1, Decode = M2&gt;, M1: Send + Sync + &#39;static, M2: Send + Sync + &#39;static, { let (mut parts, body, extensions) = self.streaming(request, path, codec).await?.into_parts(); futures_util::pin_mut!(body); let message = body .try_next() .await .map_err(|mut status| { status.metadata_mut().merge(parts.clone()); status })? .ok_or_else(|| Status::new(Code::Internal, &quot;Missing response message.&quot;))?; if let Some(trailers) = body.trailers().await? { parts.merge(trailers); } Ok(Response::from_parts(parts, message, extensions)) } /// Send a bi-directional streaming gRPC request. pub async fn streaming&lt;S, M1, M2, C&gt;( &amp;mut self, request: Request&lt;S&gt;, path: PathAndQuery, mut codec: C, ) -&gt; Result&lt;Response&lt;Streaming&lt;M2&gt;&gt;, Status&gt; where T: GrpcService&lt;BoxBody&gt;, T::ResponseBody: Body + Send + &#39;static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;, S: Stream&lt;Item = M1&gt; + Send + &#39;static, C: Codec&lt;Encode = M1, Decode = M2&gt;, M1: Send + Sync + &#39;static, M2: Send + Sync + &#39;static, { let mut parts = Parts::default(); parts.path_and_query = Some(path); let uri = Uri::from_parts(parts).expect(&quot;path_and_query only is valid Uri&quot;); let request = request .map(|s| { encode_client( codec.encoder(), s, #[cfg(feature = &quot;compression&quot;)] self.send_compression_encodings, ) }) .map(BoxBody::new); let mut request = request.into_http( uri, http::Method::POST, http::Version::HTTP_2, SanitizeHeaders::Yes, ); // Add the gRPC related HTTP headers request .headers_mut() .insert(TE, HeaderValue::from_static(&quot;trailers&quot;)); // Set the content type request .headers_mut() .insert(CONTENT_TYPE, HeaderValue::from_static(&quot;application/grpc&quot;)); #[cfg(feature = &quot;compression&quot;)] { if let Some(encoding) = self.send_compression_encodings { request.headers_mut().insert( crate::codec::compression::ENCODING_HEADER, encoding.into_header_value(), ); } if let Some(header_value) = self .accept_compression_encodings .into_accept_encoding_header_value() { request.headers_mut().insert( crate::codec::compression::ACCEPT_ENCODING_HEADER, header_value, ); } } let response = self .inner .call(request) .await .map_err(|err| Status::from_error(err.into()))?; #[cfg(feature = &quot;compression&quot;)] let encoding = CompressionEncoding::from_encoding_header( response.headers(), self.accept_compression_encodings, )?; let status_code = response.status(); let trailers_only_status = Status::from_header_map(response.headers()); // We do not need to check for trailers if the `grpc-status` header is present // with a valid code. let expect_additional_trailers = if let Some(status) = trailers_only_status { if status.code() != Code::Ok { return Err(status); } false } else { true }; let response = response.map(|body| { if expect_additional_trailers { Streaming::new_response( codec.decoder(), body, status_code, #[cfg(feature = &quot;compression&quot;)] encoding, ) } else { Streaming::new_empty(codec.decoder(), body) } }); Ok(Response::from_http(response)) } 以前面的 root_heartbeat 为例，最终实例化的 streaming 的签名为： tonic::client::Grpc&lt;tonic::transport::Channel&gt;::streaming&lt; futures::stream::Once&lt; futures::future::Ready&lt; engula_api::server::v1::HeartbeatRequest&gt;&gt;, engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse, tonic::codec::ProstCodec&lt; engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt;&gt; 而 async fn streaming() 脱糖后，经过 transform 生成的状态机的内存布局为： generator layout ([static generator@tonic::client::Grpc&lt;tonic::transport::Channel&gt;::streaming&lt;futures::stream::Once&lt;futures::future::Ready&lt;engula_api::server::v1::HeartbeatRequest&gt;&gt;, engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse, tonic::codec::ProstCodec&lt;engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt;&gt;::{closure#0}]): Layout { size: Size(560 bytes), align: AbiAndPrefAlign { abi: Align(8 bytes), pref: Align(8 bytes), }, abi: Aggregate { sized: true, }, fields: Arbitrary { offsets: [ Size(0 bytes), Size(8 bytes), Size(152 bytes), Size(0 bytes), Size(552 bytes), ], } } 仔细分析 streaming 的代码可以发现，跨过 suspend point 的变量只有本地变量 request，预留空间 response: request: http::request::Request&lt;http_body::combinators::box_body::UnsyncBoxBody&lt;prost::bytes::Bytes, tonic::Status&gt;&gt; size = 240 bytes response: tonic::transport::channel::ResponseFuture size = 32 bytes 那么 request + response + tag （手写状态机的理论值）应该是远小于 560 bytes。到了 client_streaming 这里，内存空间就增长到了 1056 bytes。 async fn 的 layout 是如何计算的？ 这里进一步分析编译器内部是如何处理 async, await 和产生状态机的，看看不符合直觉的结果是如何产生的。 实际上 async fn 是 generator 的语法糖 async 和 await 都是语法糖，rust compiler 在 ast lowering 过程中进行了 desugar，并生成 hir。其中 async fn 会被替换为 generator (compiler/rustc_ast_lowering/src/item.rs)： fn lower_maybe_async_body( &amp;mut self, span: Span, decl: &amp;FnDecl, asyncness: Async, body: Option&lt;&amp;Block&gt;, ) -&gt; hir::BodyId { let closure_id = match asyncness { Async::Yes { closure_id, .. } =&gt; closure_id, Async::No =&gt; return self.lower_fn_body_block(span, decl, body), }; self.lower_body(|this| { let mut parameters: Vec&lt;hir::Param&lt;&#39;_&gt;&gt; = Vec::new(); let mut statements: Vec&lt;hir::Stmt&lt;&#39;_&gt;&gt; = Vec::new(); // Async function parameters are lowered into the closure body so that they are // captured and so that the drop order matches the equivalent non-async functions. // // from: // // async fn foo(&lt;pattern&gt;: &lt;ty&gt;, &lt;pattern&gt;: &lt;ty&gt;, &lt;pattern&gt;: &lt;ty&gt;) { // &lt;body&gt; // } // // into: // // fn foo(__arg0: &lt;ty&gt;, __arg1: &lt;ty&gt;, __arg2: &lt;ty&gt;) { // async move { // let __arg2 = __arg2; // let &lt;pattern&gt; = __arg2; // let __arg1 = __arg1; // let &lt;pattern&gt; = __arg1; // let __arg0 = __arg0; // let &lt;pattern&gt; = __arg0; // drop-temps { &lt;body&gt; } // see comments later in fn for details // } // } // // If `&lt;pattern&gt;` is a simple ident, then it is lowered to a single // `let &lt;pattern&gt; = &lt;pattern&gt;;` statement as an optimization. // // Note that the body is embedded in `drop-temps`; an // equivalent desugaring would be `return { &lt;body&gt; // };`. The key point is that we wish to drop all the // let-bound variables and temporaries created in the body // (and its tail expression!) before we drop the // parameters (c.f. rust-lang/rust#64512). for (index, parameter) in decl.inputs.iter().enumerate() { let parameter = this.lower_param(parameter); let span = parameter.pat.span; // Check if this is a binding pattern, if so, we can optimize and avoid adding a // `let &lt;pat&gt; = __argN;` statement. In this case, we do not rename the parameter. let (ident, is_simple_parameter) = match parameter.pat.kind { hir::PatKind::Binding( hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable, _, ident, _, ) =&gt; (ident, true), // For `ref mut` or wildcard arguments, we can&#39;t reuse the binding, but // we can keep the same name for the parameter. // This lets rustdoc render it correctly in documentation. hir::PatKind::Binding(_, _, ident, _) =&gt; (ident, false), hir::PatKind::Wild =&gt; { (Ident::with_dummy_span(rustc_span::symbol::kw::Underscore), false) } _ =&gt; { // Replace the ident for bindings that aren&#39;t simple. let name = format!(&quot;__arg{}&quot;, index); let ident = Ident::from_str(&amp;name); (ident, false) } }; let desugared_span = this.mark_span_with_reason(DesugaringKind::Async, span, None); // Construct a parameter representing `__argN: &lt;ty&gt;` to replace the parameter of the // async function. // // If this is the simple case, this parameter will end up being the same as the // original parameter, but with a different pattern id. let stmt_attrs = this.attrs.get(&amp;parameter.hir_id.local_id).copied(); let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident); let new_parameter = hir::Param { hir_id: parameter.hir_id, pat: new_parameter_pat, ty_span: this.lower_span(parameter.ty_span), span: this.lower_span(parameter.span), }; if is_simple_parameter { // If this is the simple case, then we only insert one statement that is // `let &lt;pat&gt; = &lt;pat&gt;;`. We re-use the original argument&#39;s pattern so that // `HirId`s are densely assigned. let expr = this.expr_ident(desugared_span, ident, new_parameter_id); let stmt = this.stmt_let_pat( stmt_attrs, desugared_span, Some(expr), parameter.pat, hir::LocalSource::AsyncFn, ); statements.push(stmt); } else { // If this is not the simple case, then we construct two statements: // // ``` // let __argN = __argN; // let &lt;pat&gt; = __argN; // ``` // // The first statement moves the parameter into the closure and thus ensures // that the drop order is correct. // // The second statement creates the bindings that the user wrote. // Construct the `let mut __argN = __argN;` statement. It must be a mut binding // because the user may have specified a `ref mut` binding in the next // statement. let (move_pat, move_id) = this.pat_ident_binding_mode( desugared_span, ident, hir::BindingAnnotation::Mutable, ); let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id); let move_stmt = this.stmt_let_pat( None, desugared_span, Some(move_expr), move_pat, hir::LocalSource::AsyncFn, ); // Construct the `let &lt;pat&gt; = __argN;` statement. We re-use the original // parameter&#39;s pattern so that `HirId`s are densely assigned. let pattern_expr = this.expr_ident(desugared_span, ident, move_id); let pattern_stmt = this.stmt_let_pat( stmt_attrs, desugared_span, Some(pattern_expr), parameter.pat, hir::LocalSource::AsyncFn, ); statements.push(move_stmt); statements.push(pattern_stmt); }; parameters.push(new_parameter); } let body_span = body.map_or(span, |b| b.span); let async_expr = this.make_async_expr( CaptureBy::Value, closure_id, None, body_span, hir::AsyncGeneratorKind::Fn, |this| { // Create a block from the user&#39;s function body: let user_body = this.lower_block_expr_opt(body_span, body); // Transform into `drop-temps { &lt;user-body&gt; }`, an expression: let desugared_span = this.mark_span_with_reason(DesugaringKind::Async, user_body.span, None); let user_body = this.expr_drop_temps( desugared_span, this.arena.alloc(user_body), AttrVec::new(), ); // As noted above, create the final block like // // ``` // { // let $param_pattern = $raw_param; // ... // drop-temps { &lt;user-body&gt; } // } // ``` let body = this.block_all( desugared_span, this.arena.alloc_from_iter(statements), Some(user_body), ); this.expr_block(body, AttrVec::new()) }, ); ( this.arena.alloc_from_iter(parameters), this.expr(body_span, async_expr, AttrVec::new()), ) }) } async fn 被替换为 generator 后，它的参数作为 captured variable 保存在 closure 中，后续称它为 upvars，在计算 Layout 是会使用到。 await 则会被替换为 poll()(compiler/rustc_ast_lowering/src/expr.rs): /// Desugar `&lt;expr&gt;.await` into: /// ```ignore (pseudo-rust) /// match ::std::future::IntoFuture::into_future(&lt;expr&gt;) { /// mut __awaitee =&gt; loop { /// match unsafe { ::std::future::Future::poll( /// &lt;::std::pin::Pin&gt;::new_unchecked(&amp;mut __awaitee), /// ::std::future::get_context(task_context), /// ) } { /// ::std::task::Poll::Ready(result) =&gt; break result, /// ::std::task::Poll::Pending =&gt; {} /// } /// task_context = yield (); /// } /// } /// ``` fn lower_expr_await(&amp;mut self, dot_await_span: Span, expr: &amp;Expr) -&gt; hir::ExprKind&lt;&#39;hir&gt; { let full_span = expr.span.to(dot_await_span); match self.generator_kind { Some(hir::GeneratorKind::Async(_)) =&gt; {} Some(hir::GeneratorKind::Gen) | None =&gt; { self.tcx.sess.emit_err(AwaitOnlyInAsyncFnAndBlocks { dot_await_span, item_span: self.current_item, }); } } let span = self.mark_span_with_reason(DesugaringKind::Await, dot_await_span, None); let gen_future_span = self.mark_span_with_reason( DesugaringKind::Await, full_span, self.allow_gen_future.clone(), ); let expr = self.lower_expr_mut(expr); let expr_hir_id = expr.hir_id; // Note that the name of this binding must not be changed to something else because // debuggers and debugger extensions expect it to be called `__awaitee`. They use // this name to identify what is being awaited by a suspended async functions. let awaitee_ident = Ident::with_dummy_span(sym::__awaitee); let (awaitee_pat, awaitee_pat_hid) = self.pat_ident_binding_mode(span, awaitee_ident, hir::BindingAnnotation::Mutable); let task_context_ident = Ident::with_dummy_span(sym::_task_context); // unsafe { // ::std::future::Future::poll( // ::std::pin::Pin::new_unchecked(&amp;mut __awaitee), // ::std::future::get_context(task_context), // ) // } let poll_expr = { let awaitee = self.expr_ident(span, awaitee_ident, awaitee_pat_hid); let ref_mut_awaitee = self.expr_mut_addr_of(span, awaitee); let task_context = if let Some(task_context_hid) = self.task_context { self.expr_ident_mut(span, task_context_ident, task_context_hid) } else { // Use of `await` outside of an async context, we cannot use `task_context` here. self.expr_err(span) }; let new_unchecked = self.expr_call_lang_item_fn_mut( span, hir::LangItem::PinNewUnchecked, arena_vec![self; ref_mut_awaitee], Some(expr_hir_id), ); let get_context = self.expr_call_lang_item_fn_mut( gen_future_span, hir::LangItem::GetContext, arena_vec![self; task_context], Some(expr_hir_id), ); let call = self.expr_call_lang_item_fn( span, hir::LangItem::FuturePoll, arena_vec![self; new_unchecked, get_context], Some(expr_hir_id), ); self.arena.alloc(self.expr_unsafe(call)) }; // `::std::task::Poll::Ready(result) =&gt; break result` let loop_node_id = self.next_node_id(); let loop_hir_id = self.lower_node_id(loop_node_id); let ready_arm = { let x_ident = Ident::with_dummy_span(sym::result); let (x_pat, x_pat_hid) = self.pat_ident(gen_future_span, x_ident); let x_expr = self.expr_ident(gen_future_span, x_ident, x_pat_hid); let ready_field = self.single_pat_field(gen_future_span, x_pat); let ready_pat = self.pat_lang_item_variant( span, hir::LangItem::PollReady, ready_field, Some(expr_hir_id), ); let break_x = self.with_loop_scope(loop_node_id, move |this| { let expr_break = hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr)); this.arena.alloc(this.expr(gen_future_span, expr_break, AttrVec::new())) }); self.arm(ready_pat, break_x) }; // `::std::task::Poll::Pending =&gt; {}` let pending_arm = { let pending_pat = self.pat_lang_item_variant( span, hir::LangItem::PollPending, &amp;[], Some(expr_hir_id), ); let empty_block = self.expr_block_empty(span); self.arm(pending_pat, empty_block) }; let inner_match_stmt = { let match_expr = self.expr_match( span, poll_expr, arena_vec![self; ready_arm, pending_arm], hir::MatchSource::AwaitDesugar, ); self.stmt_expr(span, match_expr) }; // task_context = yield (); let yield_stmt = { let unit = self.expr_unit(span); let yield_expr = self.expr( span, hir::ExprKind::Yield(unit, hir::YieldSource::Await { expr: Some(expr_hir_id) }), AttrVec::new(), ); let yield_expr = self.arena.alloc(yield_expr); if let Some(task_context_hid) = self.task_context { let lhs = self.expr_ident(span, task_context_ident, task_context_hid); let assign = self.expr( span, hir::ExprKind::Assign(lhs, yield_expr, self.lower_span(span)), AttrVec::new(), ); self.stmt_expr(span, assign) } else { // Use of `await` outside of an async context. Return `yield_expr` so that we can // proceed with type checking. self.stmt(span, hir::StmtKind::Semi(yield_expr)) } }; let loop_block = self.block_all(span, arena_vec![self; inner_match_stmt, yield_stmt], None); // loop { .. } let loop_expr = self.arena.alloc(hir::Expr { hir_id: loop_hir_id, kind: hir::ExprKind::Loop( loop_block, None, hir::LoopSource::Loop, self.lower_span(span), ), span: self.lower_span(span), }); // mut __awaitee =&gt; loop { ... } let awaitee_arm = self.arm(awaitee_pat, loop_expr); // `match ::std::future::IntoFuture::into_future(&lt;expr&gt;) { ... }` let into_future_span = self.mark_span_with_reason( DesugaringKind::Await, dot_await_span, self.allow_into_future.clone(), ); let into_future_expr = self.expr_call_lang_item_fn( into_future_span, hir::LangItem::IntoFutureIntoFuture, arena_vec![self; expr], Some(expr_hir_id), ); // match &lt;into_future_expr&gt; { // mut __awaitee =&gt; loop { .. } // } hir::ExprKind::Match( into_future_expr, arena_vec![self; awaitee_arm], hir::MatchSource::AwaitDesugar, ) } generator 会被替换为 GeneratorState 此后 hir 会转换为 mir，generator 在 mir_transform 中被替换为 GeneratorState(compiler/rustc_mir_transform/src/generator.rs): impl&lt;&#39;tcx&gt; MirPass&lt;&#39;tcx&gt; for StateTransform { fn run_pass(&amp;self, tcx: TyCtxt&lt;&#39;tcx&gt;, body: &amp;mut Body&lt;&#39;tcx&gt;) { let Some(yield_ty) = body.yield_ty() else { // This only applies to generators return; }; assert!(body.generator_drop().is_none()); dump_mir(tcx, None, &quot;generator_before&quot;, &amp;0, body, |_, _| Ok(())); // The first argument is the generator type passed by value let gen_ty = body.local_decls.raw[1].ty; // Get the interior types and substs which typeck computed let (upvars, interior, discr_ty, movable) = match *gen_ty.kind() { ty::Generator(_, substs, movability) =&gt; { let substs = substs.as_generator(); ( substs.upvar_tys().collect(), substs.witness(), substs.discr_ty(tcx), movability == hir::Movability::Movable, ) } _ =&gt; { tcx.sess .delay_span_bug(body.span, &amp;format!(&quot;unexpected generator type {}&quot;, gen_ty)); return; } }; // Compute GeneratorState&lt;yield_ty, return_ty&gt; let state_did = tcx.require_lang_item(LangItem::GeneratorState, None); let state_adt_ref = tcx.adt_def(state_did); let state_substs = tcx.intern_substs(&amp;[yield_ty.into(), body.return_ty().into()]); let ret_ty = tcx.mk_adt(state_adt_ref, state_substs); // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local // RETURN_PLACE then is a fresh unused local with type ret_ty. let new_ret_local = replace_local(RETURN_PLACE, ret_ty, body, tcx); // We also replace the resume argument and insert an `Assign`. // This is needed because the resume argument `_2` might be live across a `yield`, in which // case there is no `Assign` to it that the transform can turn into a store to the generator // state. After the yield the slot in the generator state would then be uninitialized. let resume_local = Local::new(2); let new_resume_local = replace_local(resume_local, body.local_decls[resume_local].ty, body, tcx); // When first entering the generator, move the resume argument into its new local. let source_info = SourceInfo::outermost(body.span); let stmts = &amp;mut body.basic_blocks_mut()[BasicBlock::new(0)].statements; stmts.insert( 0, Statement { source_info, kind: StatementKind::Assign(Box::new(( new_resume_local.into(), Rvalue::Use(Operand::Move(resume_local.into())), ))), }, ); let always_live_locals = always_storage_live_locals(&amp;body); let liveness_info = locals_live_across_suspend_points(tcx, body, &amp;always_live_locals, movable); sanitize_witness(tcx, body, interior, upvars, &amp;liveness_info.saved_locals); if tcx.sess.opts.unstable_opts.validate_mir { let mut vis = EnsureGeneratorFieldAssignmentsNeverAlias { assigned_local: None, saved_locals: &amp;liveness_info.saved_locals, storage_conflicts: &amp;liveness_info.storage_conflicts, }; vis.visit_body(body); } // Extract locals which are live across suspension point into `layout` // `remap` gives a mapping from local indices onto generator struct indices // `storage_liveness` tells us which locals have live storage at suspension points let (remap, layout, storage_liveness) = compute_layout(liveness_info, body); let can_return = can_return(tcx, body, tcx.param_env(body.source.def_id())); // Run the transformation which converts Places from Local to generator struct // accesses for locals in `remap`. // It also rewrites `return x` and `yield y` as writing a new generator state and returning // GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively. let mut transform = TransformVisitor { tcx, state_adt_ref, state_substs, remap, storage_liveness, always_live_locals, suspension_points: Vec::new(), new_ret_local, discr_ty, }; transform.visit_body(body); // Update our MIR struct to reflect the changes we&#39;ve made body.arg_count = 2; // self, resume arg body.spread_arg = None; body.generator.as_mut().unwrap().yield_ty = None; body.generator.as_mut().unwrap().generator_layout = Some(layout); // Insert `drop(generator_struct)` which is used to drop upvars for generators in // the unresumed state. // This is expanded to a drop ladder in `elaborate_generator_drops`. let drop_clean = insert_clean_drop(body); dump_mir(tcx, None, &quot;generator_pre-elab&quot;, &amp;0, body, |_, _| Ok(())); // Expand `drop(generator_struct)` to a drop ladder which destroys upvars. // If any upvars are moved out of, drop elaboration will handle upvar destruction. // However we need to also elaborate the code generated by `insert_clean_drop`. elaborate_generator_drops(tcx, body); dump_mir(tcx, None, &quot;generator_post-transform&quot;, &amp;0, body, |_, _| Ok(())); // Create a copy of our MIR and use it to create the drop shim for the generator let drop_shim = create_generator_drop_shim(tcx, &amp;transform, gen_ty, body, drop_clean); body.generator.as_mut().unwrap().generator_drop = Some(drop_shim); // Create the Generator::resume function create_generator_resume_function(tcx, transform, body, can_return); // Run derefer to fix Derefs that are not in the first place deref_finder(tcx, body); } } 第 85 行 compute_layout 计算出 GeneratorLayout，并在 111 行保存到 body.generator 中。这里的 GeneratorLayout 就是 GeneratorState 的内存空间，它分成两部分：prefix + variants。prefix 保存了会跨越 suspend point 的变量，variants 是不同的 state，其中保存了只会在当前 state 使用到的变量。 GeneratorState 的内存布局是如何计算的？ 编译器在代码生成阶段会根据前面计算得到的 GeneratorLayout 算出最终的内存布局 Layout(compiler/rustc_middle/src/ty/layout.rs): /// Compute the full generator layout. fn generator_layout( &amp;self, ty: Ty&lt;&#39;tcx&gt;, def_id: hir::def_id::DefId, substs: SubstsRef&lt;&#39;tcx&gt;, ) -&gt; Result&lt;Layout&lt;&#39;tcx&gt;, LayoutError&lt;&#39;tcx&gt;&gt; { use SavedLocalEligibility::*; let tcx = self.tcx; let subst_field = |ty: Ty&lt;&#39;tcx&gt;| EarlyBinder(ty).subst(tcx, substs); let Some(info) = tcx.generator_layout(def_id) else { return Err(LayoutError::Unknown(ty)); }; let (ineligible_locals, assignments) = self.generator_saved_local_eligibility(&amp;info); // Build a prefix layout, including &quot;promoting&quot; all ineligible // locals as part of the prefix. We compute the layout of all of // these fields at once to get optimal packing. let tag_index = substs.as_generator().prefix_tys().count(); // `info.variant_fields` already accounts for the reserved variants, so no need to add them. let max_discr = (info.variant_fields.len() - 1) as u128; let discr_int = Integer::fit_unsigned(max_discr); let discr_int_ty = discr_int.to_ty(tcx, false); let tag = Scalar::Initialized { value: Primitive::Int(discr_int, false), valid_range: WrappingRange { start: 0, end: max_discr }, }; let tag_layout = self.tcx.intern_layout(LayoutS::scalar(self, tag)); let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout }; let promoted_layouts = ineligible_locals .iter() .map(|local| subst_field(info.field_tys[local])) .map(|ty| tcx.mk_maybe_uninit(ty)) .map(|ty| self.layout_of(ty)); let prefix_layouts = substs .as_generator() .prefix_tys() .map(|ty| self.layout_of(ty)) .chain(iter::once(Ok(tag_layout))) .chain(promoted_layouts) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?; let prefix = self.univariant_uninterned( ty, &amp;prefix_layouts, &amp;ReprOptions::default(), StructKind::AlwaysSized, )?; let (prefix_size, prefix_align) = (prefix.size, prefix.align); // Split the prefix layout into the &quot;outer&quot; fields (upvars and // discriminant) and the &quot;promoted&quot; fields. Promoted fields will // get included in each variant that requested them in // GeneratorLayout. debug!(&quot;prefix = {:#?}&quot;, prefix); let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields { FieldsShape::Arbitrary { mut offsets, memory_index } =&gt; { let mut inverse_memory_index = invert_mapping(&amp;memory_index); // &quot;a&quot; (`0..b_start`) and &quot;b&quot; (`b_start..`) correspond to // &quot;outer&quot; and &quot;promoted&quot; fields respectively. let b_start = (tag_index + 1) as u32; let offsets_b = offsets.split_off(b_start as usize); let offsets_a = offsets; // Disentangle the &quot;a&quot; and &quot;b&quot; components of `inverse_memory_index` // by preserving the order but keeping only one disjoint &quot;half&quot; each. // FIXME(eddyb) build a better abstraction for permutations, if possible. let inverse_memory_index_b: Vec&lt;_&gt; = inverse_memory_index.iter().filter_map(|&amp;i| i.checked_sub(b_start)).collect(); inverse_memory_index.retain(|&amp;i| i &lt; b_start); let inverse_memory_index_a = inverse_memory_index; // Since `inverse_memory_index_{a,b}` each only refer to their // respective fields, they can be safely inverted let memory_index_a = invert_mapping(&amp;inverse_memory_index_a); let memory_index_b = invert_mapping(&amp;inverse_memory_index_b); let outer_fields = FieldsShape::Arbitrary { offsets: offsets_a, memory_index: memory_index_a }; (outer_fields, offsets_b, memory_index_b) } _ =&gt; bug!(), }; let mut size = prefix.size; let mut align = prefix.align; let variants = info .variant_fields .iter_enumerated() .map(|(index, variant_fields)| { // Only include overlap-eligible fields when we compute our variant layout. let variant_only_tys = variant_fields .iter() .filter(|local| match assignments[**local] { Unassigned =&gt; bug!(), Assigned(v) if v == index =&gt; true, Assigned(_) =&gt; bug!(&quot;assignment does not match variant&quot;), Ineligible(_) =&gt; false, }) .map(|local| subst_field(info.field_tys[*local])); let mut variant = self.univariant_uninterned( ty, &amp;variant_only_tys .map(|ty| self.layout_of(ty)) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?, &amp;ReprOptions::default(), StructKind::Prefixed(prefix_size, prefix_align.abi), )?; variant.variants = Variants::Single { index }; let FieldsShape::Arbitrary { offsets, memory_index } = variant.fields else { bug!(); }; // Now, stitch the promoted and variant-only fields back together in // the order they are mentioned by our GeneratorLayout. // Because we only use some subset (that can differ between variants) // of the promoted fields, we can&#39;t just pick those elements of the // `promoted_memory_index` (as we&#39;d end up with gaps). // So instead, we build an &quot;inverse memory_index&quot;, as if all of the // promoted fields were being used, but leave the elements not in the // subset as `INVALID_FIELD_IDX`, which we can filter out later to // obtain a valid (bijective) mapping. const INVALID_FIELD_IDX: u32 = !0; let mut combined_inverse_memory_index = vec![INVALID_FIELD_IDX; promoted_memory_index.len() + memory_index.len()]; let mut offsets_and_memory_index = iter::zip(offsets, memory_index); let combined_offsets = variant_fields .iter() .enumerate() .map(|(i, local)| { let (offset, memory_index) = match assignments[*local] { Unassigned =&gt; bug!(), Assigned(_) =&gt; { let (offset, memory_index) = offsets_and_memory_index.next().unwrap(); (offset, promoted_memory_index.len() as u32 + memory_index) } Ineligible(field_idx) =&gt; { let field_idx = field_idx.unwrap() as usize; (promoted_offsets[field_idx], promoted_memory_index[field_idx]) } }; combined_inverse_memory_index[memory_index as usize] = i as u32; offset }) .collect(); // Remove the unused slots and invert the mapping to obtain the // combined `memory_index` (also see previous comment). combined_inverse_memory_index.retain(|&amp;i| i != INVALID_FIELD_IDX); let combined_memory_index = invert_mapping(&amp;combined_inverse_memory_index); variant.fields = FieldsShape::Arbitrary { offsets: combined_offsets, memory_index: combined_memory_index, }; size = size.max(variant.size); align = align.max(variant.align); Ok(tcx.intern_layout(variant)) }) .collect::&lt;Result&lt;IndexVec&lt;VariantIdx, _&gt;, _&gt;&gt;()?; size = size.align_to(align.abi); let abi = if prefix.abi.is_uninhabited() || variants.iter().all(|v| v.abi().is_uninhabited()) { Abi::Uninhabited } else { Abi::Aggregate { sized: true } }; let layout = tcx.intern_layout(LayoutS { variants: Variants::Multiple { tag, tag_encoding: TagEncoding::Direct, tag_field: tag_index, variants, }, fields: outer_fields, abi, largest_niche: prefix.largest_niche, size, align, }); debug!(&quot;generator layout ({:?}): {:#?}&quot;, ty, layout); Ok(layout) } LayoutS 的定义为： #[derive(PartialEq, Eq, Hash, HashStable_Generic)] pub struct LayoutS&lt;&#39;a&gt; { /// Says where the fields are located within the layout. pub fields: FieldsShape, /// Encodes information about multi-variant layouts. /// Even with `Multiple` variants, a layout still has its own fields! Those are then /// shared between all variants. One of them will be the discriminant, /// but e.g. generators can have more. /// /// To access all fields of this layout, both `fields` and the fields of the active variant /// must be taken into account. pub variants: Variants&lt;&#39;a&gt;, /// The `abi` defines how this data is passed between functions, and it defines /// value restrictions via `valid_range`. /// /// Note that this is entirely orthogonal to the recursive structure defined by /// `variants` and `fields`; for example, `ManuallyDrop&lt;Result&lt;isize, isize&gt;&gt;` has /// `Abi::ScalarPair`! So, even with non-`Aggregate` `abi`, `fields` and `variants` /// have to be taken into account to find all fields of this layout. pub abi: Abi, /// The leaf scalar with the largest number of invalid values /// (i.e. outside of its `valid_range`), if it exists. pub largest_niche: Option&lt;Niche&gt;, pub align: AbiAndPrefAlign, pub size: Size, } 根据定义，fields + variants 组成了 GeneratorState 的内存布局： To access all fields of this layout, both `fields` and the fields of the active variant must be taken into account. 在 generator_layout 函数中，fields 是 outer_fields，variants 是 Variant::Multiple 的实例，其中保存了 variants 和一个 tag_field。outer_fields 和 variants 均由 prefix 计算得到： // Split the prefix layout into the &quot;outer&quot; fields (upvars and // discriminant) and the &quot;promoted&quot; fields. Promoted fields will // get included in each variant that requested them in // GeneratorLayout prefix 的计算方式为： let tag_layout = self.tcx.intern_layout(LayoutS::scalar(self, tag)); let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout }; let promoted_layouts = ineligible_locals .iter() .map(|local| subst_field(info.field_tys[local])) .map(|ty| tcx.mk_maybe_uninit(ty)) .map(|ty| self.layout_of(ty)); let prefix_layouts = substs .as_generator() .prefix_tys() .map(|ty| self.layout_of(ty)) .chain(iter::once(Ok(tag_layout))) .chain(promoted_layouts) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?; let prefix = self.univariant_uninterned( ty, &amp;prefix_layouts, &amp;ReprOptions::default(), StructKind::AlwaysSized, )?; 其中 prefix_tys() 返回的就是前面提到的 upvars： /// This is the types of the fields of a generator which are not stored in a /// variant. #[inline] pub fn prefix_tys(self) -&gt; impl Iterator&lt;Item = Ty&lt;&#39;tcx&gt;&gt; { self.upvar_tys() } 因此，一个 GeneratorState 的 Layout 中会包含一个 tag，upvars，以及由不同 state 组成的 variants。回到 root_heartbeat 的例子，streaming() 中，除了 request 和 response 外，还会保存下参数中的 request: Request&lt;S&gt;，path 和 codec。 codec: tonic::codec::ProstCodec&lt;engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt; size 0 bytes request: tonic::Request&lt;futures::stream::Once&lt;futures::future::Ready&lt;engula_api::server::v1::HeartbeatRequest&gt;&gt;&gt; size 144 bytes path: http::uri::path::PathAndQuery size 40 bytes tag: u8 最终的大小为：self(8 bytes) + request(144 bytes) + path(40 bytes) + uri(88 bytes) + request(240 bytes, http request) + response(32 bytes) + tag(1 byte, aligned to 8) = 560 此处 uri 是前面计算漏掉的变量。 由于 async fn 的参数作为 captured variable，会放置在 outer_fields 中。如果一个非常大的参数层层传递到内部的某个 async fn，会被一层层放大，最终导致 Future 大小呈现指数增长。 19 年有一个 issue 已经指出了这个问题1。 解决方案？ 对于普通开发者，临时的解决办法有两点： 避免 pass by value，可以使用 Arc 或者 reference 减少使用 async fn。对于 tail calling，可以直接使用 impl Future，避免无意义的 await。 cpp 提供了左值引用，这类层层传递的变量可以被自然地优化；而 rust 依靠编译器优化，就得依靠生成的代码能满足优化的前置条件。 当然，community 也有人提供了改进方案2。该方案可以简述如下：即将 upvars 保存到 GeneratorState 的 unresumed state 中 （每个 GenerateState 至少有三种 state: unresumed, finished, paniced, 以及用户定义的 suspent_x)。 不过因为 rust 编译器架构改成了 demand-deriven compilation，该方案碰到了 query 循环依赖的问题， 需要等待其他人先将修复 dest prop 3。 https://github.com/rust-lang/rust/issues/62958 &#8617; https://github.com/rust-lang/rust/pull/89213 &#8617; https://github.com/rust-lang/rust/pull/96451 &#8617;" />
<meta property="og:description" content="背景 最近开始对 engula 进行性能测试，发现 async fn 的性能损耗非常大，这不符合 zero overhead abstraction，因此开始对 async fn 的性能做一些研究。 通过增加参数 -Z print-type-size，可以输出每种类型的大小。发现很多 generator 内存大小非常大，其中最不符合直觉的是下面这几个： print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:39:69: 44:6]&gt;`: 1248 bytes, alignment: 8 bytes print-type-size field `.0`: 1248 bytes print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:79:52: 83:6]&gt;`: 1408 bytes, alignment: 8 bytes print-type-size field `.0`: 1408 bytes print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:88:51: 92:6]&gt;`: 1408 bytes, alignment: 8 bytes print-type-size field `.0`: 1408 bytes node_client.rs 是 tonic grpc client 的简单封装: use tonic::transport::Channel; #[derive(Debug, Clone)] pub struct Client { client: node_client::NodeClient&lt;Channel&gt;, } pub async fn root_heartbeat( &amp;self, req: HeartbeatRequest, ) -&gt; Result&lt;HeartbeatResponse, tonic::Status&gt; { let mut client = self.client.clone(); let res = client.root_heartbeat(req).await?; Ok(res.into_inner()) } node_client::NodeClient 是 tonic_build 生成的代码： impl&lt;T&gt; NodeClient&lt;T&gt; where T: tonic::client::GrpcService&lt;tonic::body::BoxBody&gt;, T::Error: Into&lt;StdError&gt;, T::ResponseBody: Body&lt;Data = Bytes&gt; + Send + &#39;static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;StdError&gt; + Send, { pub fn new(inner: T) -&gt; Self { let inner = tonic::client::Grpc::new(inner); Self { inner } } } pub async fn root_heartbeat( &amp;mut self, request: impl tonic::IntoRequest&lt;super::HeartbeatRequest&gt;, ) -&gt; Result&lt;tonic::Response&lt;super::HeartbeatResponse&gt;, tonic::Status&gt; { self.inner .ready() .await .map_err(|e| { tonic::Status::new( tonic::Code::Unknown, format!(&quot;Service was not ready: {}&quot;, e.into()), ) })?; let codec = tonic::codec::ProstCodec::default(); let path = http::uri::PathAndQuery::from_static( &quot;/engula.server.v1.Node/RootHeartbeat&quot;, ); self.inner.unary(request.into_request(), path, codec).await } 也就是说，每次调用 Grpc::unary 需要在栈上开辟 1K+ 的空间。如果最后使用了 tokio::spawn，那么还需要将它复制到堆上。无论是内存分配还是复制上的开销，对于一个高性能存储服务都是不可接受的。并且随着 async fn 的调用层数增加，Future 大小还会呈现指数增长，这一点我后面会分析。 Grpc::unary 的 memory layout 是怎样的？ 那么，为何 Grpc::unary 返回的 Future 需要消耗 1K+ 的内存空间呢？ 在 tonic/src/client/grpc.rs 中，unary 最终被委托给 Grpc::streaming，后者调用 Channel::call 并返回 ResponseFuture。 /// Send a single unary gRPC request. pub async fn unary&lt;M1, M2, C&gt;( &amp;mut self, request: Request&lt;M1&gt;, path: PathAndQuery, codec: C, ) -&gt; Result&lt;Response&lt;M2&gt;, Status&gt; where T: GrpcService&lt;BoxBody&gt;, T::ResponseBody: Body + Send + &#39;static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;, C: Codec&lt;Encode = M1, Decode = M2&gt;, M1: Send + Sync + &#39;static, M2: Send + Sync + &#39;static, { let request = request.map(|m| stream::once(future::ready(m))); self.client_streaming(request, path, codec).await } /// Send a client side streaming gRPC request. pub async fn client_streaming&lt;S, M1, M2, C&gt;( &amp;mut self, request: Request&lt;S&gt;, path: PathAndQuery, codec: C, ) -&gt; Result&lt;Response&lt;M2&gt;, Status&gt; where T: GrpcService&lt;BoxBody&gt;, T::ResponseBody: Body + Send + &#39;static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;, S: Stream&lt;Item = M1&gt; + Send + &#39;static, C: Codec&lt;Encode = M1, Decode = M2&gt;, M1: Send + Sync + &#39;static, M2: Send + Sync + &#39;static, { let (mut parts, body, extensions) = self.streaming(request, path, codec).await?.into_parts(); futures_util::pin_mut!(body); let message = body .try_next() .await .map_err(|mut status| { status.metadata_mut().merge(parts.clone()); status })? .ok_or_else(|| Status::new(Code::Internal, &quot;Missing response message.&quot;))?; if let Some(trailers) = body.trailers().await? { parts.merge(trailers); } Ok(Response::from_parts(parts, message, extensions)) } /// Send a bi-directional streaming gRPC request. pub async fn streaming&lt;S, M1, M2, C&gt;( &amp;mut self, request: Request&lt;S&gt;, path: PathAndQuery, mut codec: C, ) -&gt; Result&lt;Response&lt;Streaming&lt;M2&gt;&gt;, Status&gt; where T: GrpcService&lt;BoxBody&gt;, T::ResponseBody: Body + Send + &#39;static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;, S: Stream&lt;Item = M1&gt; + Send + &#39;static, C: Codec&lt;Encode = M1, Decode = M2&gt;, M1: Send + Sync + &#39;static, M2: Send + Sync + &#39;static, { let mut parts = Parts::default(); parts.path_and_query = Some(path); let uri = Uri::from_parts(parts).expect(&quot;path_and_query only is valid Uri&quot;); let request = request .map(|s| { encode_client( codec.encoder(), s, #[cfg(feature = &quot;compression&quot;)] self.send_compression_encodings, ) }) .map(BoxBody::new); let mut request = request.into_http( uri, http::Method::POST, http::Version::HTTP_2, SanitizeHeaders::Yes, ); // Add the gRPC related HTTP headers request .headers_mut() .insert(TE, HeaderValue::from_static(&quot;trailers&quot;)); // Set the content type request .headers_mut() .insert(CONTENT_TYPE, HeaderValue::from_static(&quot;application/grpc&quot;)); #[cfg(feature = &quot;compression&quot;)] { if let Some(encoding) = self.send_compression_encodings { request.headers_mut().insert( crate::codec::compression::ENCODING_HEADER, encoding.into_header_value(), ); } if let Some(header_value) = self .accept_compression_encodings .into_accept_encoding_header_value() { request.headers_mut().insert( crate::codec::compression::ACCEPT_ENCODING_HEADER, header_value, ); } } let response = self .inner .call(request) .await .map_err(|err| Status::from_error(err.into()))?; #[cfg(feature = &quot;compression&quot;)] let encoding = CompressionEncoding::from_encoding_header( response.headers(), self.accept_compression_encodings, )?; let status_code = response.status(); let trailers_only_status = Status::from_header_map(response.headers()); // We do not need to check for trailers if the `grpc-status` header is present // with a valid code. let expect_additional_trailers = if let Some(status) = trailers_only_status { if status.code() != Code::Ok { return Err(status); } false } else { true }; let response = response.map(|body| { if expect_additional_trailers { Streaming::new_response( codec.decoder(), body, status_code, #[cfg(feature = &quot;compression&quot;)] encoding, ) } else { Streaming::new_empty(codec.decoder(), body) } }); Ok(Response::from_http(response)) } 以前面的 root_heartbeat 为例，最终实例化的 streaming 的签名为： tonic::client::Grpc&lt;tonic::transport::Channel&gt;::streaming&lt; futures::stream::Once&lt; futures::future::Ready&lt; engula_api::server::v1::HeartbeatRequest&gt;&gt;, engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse, tonic::codec::ProstCodec&lt; engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt;&gt; 而 async fn streaming() 脱糖后，经过 transform 生成的状态机的内存布局为： generator layout ([static generator@tonic::client::Grpc&lt;tonic::transport::Channel&gt;::streaming&lt;futures::stream::Once&lt;futures::future::Ready&lt;engula_api::server::v1::HeartbeatRequest&gt;&gt;, engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse, tonic::codec::ProstCodec&lt;engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt;&gt;::{closure#0}]): Layout { size: Size(560 bytes), align: AbiAndPrefAlign { abi: Align(8 bytes), pref: Align(8 bytes), }, abi: Aggregate { sized: true, }, fields: Arbitrary { offsets: [ Size(0 bytes), Size(8 bytes), Size(152 bytes), Size(0 bytes), Size(552 bytes), ], } } 仔细分析 streaming 的代码可以发现，跨过 suspend point 的变量只有本地变量 request，预留空间 response: request: http::request::Request&lt;http_body::combinators::box_body::UnsyncBoxBody&lt;prost::bytes::Bytes, tonic::Status&gt;&gt; size = 240 bytes response: tonic::transport::channel::ResponseFuture size = 32 bytes 那么 request + response + tag （手写状态机的理论值）应该是远小于 560 bytes。到了 client_streaming 这里，内存空间就增长到了 1056 bytes。 async fn 的 layout 是如何计算的？ 这里进一步分析编译器内部是如何处理 async, await 和产生状态机的，看看不符合直觉的结果是如何产生的。 实际上 async fn 是 generator 的语法糖 async 和 await 都是语法糖，rust compiler 在 ast lowering 过程中进行了 desugar，并生成 hir。其中 async fn 会被替换为 generator (compiler/rustc_ast_lowering/src/item.rs)： fn lower_maybe_async_body( &amp;mut self, span: Span, decl: &amp;FnDecl, asyncness: Async, body: Option&lt;&amp;Block&gt;, ) -&gt; hir::BodyId { let closure_id = match asyncness { Async::Yes { closure_id, .. } =&gt; closure_id, Async::No =&gt; return self.lower_fn_body_block(span, decl, body), }; self.lower_body(|this| { let mut parameters: Vec&lt;hir::Param&lt;&#39;_&gt;&gt; = Vec::new(); let mut statements: Vec&lt;hir::Stmt&lt;&#39;_&gt;&gt; = Vec::new(); // Async function parameters are lowered into the closure body so that they are // captured and so that the drop order matches the equivalent non-async functions. // // from: // // async fn foo(&lt;pattern&gt;: &lt;ty&gt;, &lt;pattern&gt;: &lt;ty&gt;, &lt;pattern&gt;: &lt;ty&gt;) { // &lt;body&gt; // } // // into: // // fn foo(__arg0: &lt;ty&gt;, __arg1: &lt;ty&gt;, __arg2: &lt;ty&gt;) { // async move { // let __arg2 = __arg2; // let &lt;pattern&gt; = __arg2; // let __arg1 = __arg1; // let &lt;pattern&gt; = __arg1; // let __arg0 = __arg0; // let &lt;pattern&gt; = __arg0; // drop-temps { &lt;body&gt; } // see comments later in fn for details // } // } // // If `&lt;pattern&gt;` is a simple ident, then it is lowered to a single // `let &lt;pattern&gt; = &lt;pattern&gt;;` statement as an optimization. // // Note that the body is embedded in `drop-temps`; an // equivalent desugaring would be `return { &lt;body&gt; // };`. The key point is that we wish to drop all the // let-bound variables and temporaries created in the body // (and its tail expression!) before we drop the // parameters (c.f. rust-lang/rust#64512). for (index, parameter) in decl.inputs.iter().enumerate() { let parameter = this.lower_param(parameter); let span = parameter.pat.span; // Check if this is a binding pattern, if so, we can optimize and avoid adding a // `let &lt;pat&gt; = __argN;` statement. In this case, we do not rename the parameter. let (ident, is_simple_parameter) = match parameter.pat.kind { hir::PatKind::Binding( hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable, _, ident, _, ) =&gt; (ident, true), // For `ref mut` or wildcard arguments, we can&#39;t reuse the binding, but // we can keep the same name for the parameter. // This lets rustdoc render it correctly in documentation. hir::PatKind::Binding(_, _, ident, _) =&gt; (ident, false), hir::PatKind::Wild =&gt; { (Ident::with_dummy_span(rustc_span::symbol::kw::Underscore), false) } _ =&gt; { // Replace the ident for bindings that aren&#39;t simple. let name = format!(&quot;__arg{}&quot;, index); let ident = Ident::from_str(&amp;name); (ident, false) } }; let desugared_span = this.mark_span_with_reason(DesugaringKind::Async, span, None); // Construct a parameter representing `__argN: &lt;ty&gt;` to replace the parameter of the // async function. // // If this is the simple case, this parameter will end up being the same as the // original parameter, but with a different pattern id. let stmt_attrs = this.attrs.get(&amp;parameter.hir_id.local_id).copied(); let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident); let new_parameter = hir::Param { hir_id: parameter.hir_id, pat: new_parameter_pat, ty_span: this.lower_span(parameter.ty_span), span: this.lower_span(parameter.span), }; if is_simple_parameter { // If this is the simple case, then we only insert one statement that is // `let &lt;pat&gt; = &lt;pat&gt;;`. We re-use the original argument&#39;s pattern so that // `HirId`s are densely assigned. let expr = this.expr_ident(desugared_span, ident, new_parameter_id); let stmt = this.stmt_let_pat( stmt_attrs, desugared_span, Some(expr), parameter.pat, hir::LocalSource::AsyncFn, ); statements.push(stmt); } else { // If this is not the simple case, then we construct two statements: // // ``` // let __argN = __argN; // let &lt;pat&gt; = __argN; // ``` // // The first statement moves the parameter into the closure and thus ensures // that the drop order is correct. // // The second statement creates the bindings that the user wrote. // Construct the `let mut __argN = __argN;` statement. It must be a mut binding // because the user may have specified a `ref mut` binding in the next // statement. let (move_pat, move_id) = this.pat_ident_binding_mode( desugared_span, ident, hir::BindingAnnotation::Mutable, ); let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id); let move_stmt = this.stmt_let_pat( None, desugared_span, Some(move_expr), move_pat, hir::LocalSource::AsyncFn, ); // Construct the `let &lt;pat&gt; = __argN;` statement. We re-use the original // parameter&#39;s pattern so that `HirId`s are densely assigned. let pattern_expr = this.expr_ident(desugared_span, ident, move_id); let pattern_stmt = this.stmt_let_pat( stmt_attrs, desugared_span, Some(pattern_expr), parameter.pat, hir::LocalSource::AsyncFn, ); statements.push(move_stmt); statements.push(pattern_stmt); }; parameters.push(new_parameter); } let body_span = body.map_or(span, |b| b.span); let async_expr = this.make_async_expr( CaptureBy::Value, closure_id, None, body_span, hir::AsyncGeneratorKind::Fn, |this| { // Create a block from the user&#39;s function body: let user_body = this.lower_block_expr_opt(body_span, body); // Transform into `drop-temps { &lt;user-body&gt; }`, an expression: let desugared_span = this.mark_span_with_reason(DesugaringKind::Async, user_body.span, None); let user_body = this.expr_drop_temps( desugared_span, this.arena.alloc(user_body), AttrVec::new(), ); // As noted above, create the final block like // // ``` // { // let $param_pattern = $raw_param; // ... // drop-temps { &lt;user-body&gt; } // } // ``` let body = this.block_all( desugared_span, this.arena.alloc_from_iter(statements), Some(user_body), ); this.expr_block(body, AttrVec::new()) }, ); ( this.arena.alloc_from_iter(parameters), this.expr(body_span, async_expr, AttrVec::new()), ) }) } async fn 被替换为 generator 后，它的参数作为 captured variable 保存在 closure 中，后续称它为 upvars，在计算 Layout 是会使用到。 await 则会被替换为 poll()(compiler/rustc_ast_lowering/src/expr.rs): /// Desugar `&lt;expr&gt;.await` into: /// ```ignore (pseudo-rust) /// match ::std::future::IntoFuture::into_future(&lt;expr&gt;) { /// mut __awaitee =&gt; loop { /// match unsafe { ::std::future::Future::poll( /// &lt;::std::pin::Pin&gt;::new_unchecked(&amp;mut __awaitee), /// ::std::future::get_context(task_context), /// ) } { /// ::std::task::Poll::Ready(result) =&gt; break result, /// ::std::task::Poll::Pending =&gt; {} /// } /// task_context = yield (); /// } /// } /// ``` fn lower_expr_await(&amp;mut self, dot_await_span: Span, expr: &amp;Expr) -&gt; hir::ExprKind&lt;&#39;hir&gt; { let full_span = expr.span.to(dot_await_span); match self.generator_kind { Some(hir::GeneratorKind::Async(_)) =&gt; {} Some(hir::GeneratorKind::Gen) | None =&gt; { self.tcx.sess.emit_err(AwaitOnlyInAsyncFnAndBlocks { dot_await_span, item_span: self.current_item, }); } } let span = self.mark_span_with_reason(DesugaringKind::Await, dot_await_span, None); let gen_future_span = self.mark_span_with_reason( DesugaringKind::Await, full_span, self.allow_gen_future.clone(), ); let expr = self.lower_expr_mut(expr); let expr_hir_id = expr.hir_id; // Note that the name of this binding must not be changed to something else because // debuggers and debugger extensions expect it to be called `__awaitee`. They use // this name to identify what is being awaited by a suspended async functions. let awaitee_ident = Ident::with_dummy_span(sym::__awaitee); let (awaitee_pat, awaitee_pat_hid) = self.pat_ident_binding_mode(span, awaitee_ident, hir::BindingAnnotation::Mutable); let task_context_ident = Ident::with_dummy_span(sym::_task_context); // unsafe { // ::std::future::Future::poll( // ::std::pin::Pin::new_unchecked(&amp;mut __awaitee), // ::std::future::get_context(task_context), // ) // } let poll_expr = { let awaitee = self.expr_ident(span, awaitee_ident, awaitee_pat_hid); let ref_mut_awaitee = self.expr_mut_addr_of(span, awaitee); let task_context = if let Some(task_context_hid) = self.task_context { self.expr_ident_mut(span, task_context_ident, task_context_hid) } else { // Use of `await` outside of an async context, we cannot use `task_context` here. self.expr_err(span) }; let new_unchecked = self.expr_call_lang_item_fn_mut( span, hir::LangItem::PinNewUnchecked, arena_vec![self; ref_mut_awaitee], Some(expr_hir_id), ); let get_context = self.expr_call_lang_item_fn_mut( gen_future_span, hir::LangItem::GetContext, arena_vec![self; task_context], Some(expr_hir_id), ); let call = self.expr_call_lang_item_fn( span, hir::LangItem::FuturePoll, arena_vec![self; new_unchecked, get_context], Some(expr_hir_id), ); self.arena.alloc(self.expr_unsafe(call)) }; // `::std::task::Poll::Ready(result) =&gt; break result` let loop_node_id = self.next_node_id(); let loop_hir_id = self.lower_node_id(loop_node_id); let ready_arm = { let x_ident = Ident::with_dummy_span(sym::result); let (x_pat, x_pat_hid) = self.pat_ident(gen_future_span, x_ident); let x_expr = self.expr_ident(gen_future_span, x_ident, x_pat_hid); let ready_field = self.single_pat_field(gen_future_span, x_pat); let ready_pat = self.pat_lang_item_variant( span, hir::LangItem::PollReady, ready_field, Some(expr_hir_id), ); let break_x = self.with_loop_scope(loop_node_id, move |this| { let expr_break = hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr)); this.arena.alloc(this.expr(gen_future_span, expr_break, AttrVec::new())) }); self.arm(ready_pat, break_x) }; // `::std::task::Poll::Pending =&gt; {}` let pending_arm = { let pending_pat = self.pat_lang_item_variant( span, hir::LangItem::PollPending, &amp;[], Some(expr_hir_id), ); let empty_block = self.expr_block_empty(span); self.arm(pending_pat, empty_block) }; let inner_match_stmt = { let match_expr = self.expr_match( span, poll_expr, arena_vec![self; ready_arm, pending_arm], hir::MatchSource::AwaitDesugar, ); self.stmt_expr(span, match_expr) }; // task_context = yield (); let yield_stmt = { let unit = self.expr_unit(span); let yield_expr = self.expr( span, hir::ExprKind::Yield(unit, hir::YieldSource::Await { expr: Some(expr_hir_id) }), AttrVec::new(), ); let yield_expr = self.arena.alloc(yield_expr); if let Some(task_context_hid) = self.task_context { let lhs = self.expr_ident(span, task_context_ident, task_context_hid); let assign = self.expr( span, hir::ExprKind::Assign(lhs, yield_expr, self.lower_span(span)), AttrVec::new(), ); self.stmt_expr(span, assign) } else { // Use of `await` outside of an async context. Return `yield_expr` so that we can // proceed with type checking. self.stmt(span, hir::StmtKind::Semi(yield_expr)) } }; let loop_block = self.block_all(span, arena_vec![self; inner_match_stmt, yield_stmt], None); // loop { .. } let loop_expr = self.arena.alloc(hir::Expr { hir_id: loop_hir_id, kind: hir::ExprKind::Loop( loop_block, None, hir::LoopSource::Loop, self.lower_span(span), ), span: self.lower_span(span), }); // mut __awaitee =&gt; loop { ... } let awaitee_arm = self.arm(awaitee_pat, loop_expr); // `match ::std::future::IntoFuture::into_future(&lt;expr&gt;) { ... }` let into_future_span = self.mark_span_with_reason( DesugaringKind::Await, dot_await_span, self.allow_into_future.clone(), ); let into_future_expr = self.expr_call_lang_item_fn( into_future_span, hir::LangItem::IntoFutureIntoFuture, arena_vec![self; expr], Some(expr_hir_id), ); // match &lt;into_future_expr&gt; { // mut __awaitee =&gt; loop { .. } // } hir::ExprKind::Match( into_future_expr, arena_vec![self; awaitee_arm], hir::MatchSource::AwaitDesugar, ) } generator 会被替换为 GeneratorState 此后 hir 会转换为 mir，generator 在 mir_transform 中被替换为 GeneratorState(compiler/rustc_mir_transform/src/generator.rs): impl&lt;&#39;tcx&gt; MirPass&lt;&#39;tcx&gt; for StateTransform { fn run_pass(&amp;self, tcx: TyCtxt&lt;&#39;tcx&gt;, body: &amp;mut Body&lt;&#39;tcx&gt;) { let Some(yield_ty) = body.yield_ty() else { // This only applies to generators return; }; assert!(body.generator_drop().is_none()); dump_mir(tcx, None, &quot;generator_before&quot;, &amp;0, body, |_, _| Ok(())); // The first argument is the generator type passed by value let gen_ty = body.local_decls.raw[1].ty; // Get the interior types and substs which typeck computed let (upvars, interior, discr_ty, movable) = match *gen_ty.kind() { ty::Generator(_, substs, movability) =&gt; { let substs = substs.as_generator(); ( substs.upvar_tys().collect(), substs.witness(), substs.discr_ty(tcx), movability == hir::Movability::Movable, ) } _ =&gt; { tcx.sess .delay_span_bug(body.span, &amp;format!(&quot;unexpected generator type {}&quot;, gen_ty)); return; } }; // Compute GeneratorState&lt;yield_ty, return_ty&gt; let state_did = tcx.require_lang_item(LangItem::GeneratorState, None); let state_adt_ref = tcx.adt_def(state_did); let state_substs = tcx.intern_substs(&amp;[yield_ty.into(), body.return_ty().into()]); let ret_ty = tcx.mk_adt(state_adt_ref, state_substs); // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local // RETURN_PLACE then is a fresh unused local with type ret_ty. let new_ret_local = replace_local(RETURN_PLACE, ret_ty, body, tcx); // We also replace the resume argument and insert an `Assign`. // This is needed because the resume argument `_2` might be live across a `yield`, in which // case there is no `Assign` to it that the transform can turn into a store to the generator // state. After the yield the slot in the generator state would then be uninitialized. let resume_local = Local::new(2); let new_resume_local = replace_local(resume_local, body.local_decls[resume_local].ty, body, tcx); // When first entering the generator, move the resume argument into its new local. let source_info = SourceInfo::outermost(body.span); let stmts = &amp;mut body.basic_blocks_mut()[BasicBlock::new(0)].statements; stmts.insert( 0, Statement { source_info, kind: StatementKind::Assign(Box::new(( new_resume_local.into(), Rvalue::Use(Operand::Move(resume_local.into())), ))), }, ); let always_live_locals = always_storage_live_locals(&amp;body); let liveness_info = locals_live_across_suspend_points(tcx, body, &amp;always_live_locals, movable); sanitize_witness(tcx, body, interior, upvars, &amp;liveness_info.saved_locals); if tcx.sess.opts.unstable_opts.validate_mir { let mut vis = EnsureGeneratorFieldAssignmentsNeverAlias { assigned_local: None, saved_locals: &amp;liveness_info.saved_locals, storage_conflicts: &amp;liveness_info.storage_conflicts, }; vis.visit_body(body); } // Extract locals which are live across suspension point into `layout` // `remap` gives a mapping from local indices onto generator struct indices // `storage_liveness` tells us which locals have live storage at suspension points let (remap, layout, storage_liveness) = compute_layout(liveness_info, body); let can_return = can_return(tcx, body, tcx.param_env(body.source.def_id())); // Run the transformation which converts Places from Local to generator struct // accesses for locals in `remap`. // It also rewrites `return x` and `yield y` as writing a new generator state and returning // GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively. let mut transform = TransformVisitor { tcx, state_adt_ref, state_substs, remap, storage_liveness, always_live_locals, suspension_points: Vec::new(), new_ret_local, discr_ty, }; transform.visit_body(body); // Update our MIR struct to reflect the changes we&#39;ve made body.arg_count = 2; // self, resume arg body.spread_arg = None; body.generator.as_mut().unwrap().yield_ty = None; body.generator.as_mut().unwrap().generator_layout = Some(layout); // Insert `drop(generator_struct)` which is used to drop upvars for generators in // the unresumed state. // This is expanded to a drop ladder in `elaborate_generator_drops`. let drop_clean = insert_clean_drop(body); dump_mir(tcx, None, &quot;generator_pre-elab&quot;, &amp;0, body, |_, _| Ok(())); // Expand `drop(generator_struct)` to a drop ladder which destroys upvars. // If any upvars are moved out of, drop elaboration will handle upvar destruction. // However we need to also elaborate the code generated by `insert_clean_drop`. elaborate_generator_drops(tcx, body); dump_mir(tcx, None, &quot;generator_post-transform&quot;, &amp;0, body, |_, _| Ok(())); // Create a copy of our MIR and use it to create the drop shim for the generator let drop_shim = create_generator_drop_shim(tcx, &amp;transform, gen_ty, body, drop_clean); body.generator.as_mut().unwrap().generator_drop = Some(drop_shim); // Create the Generator::resume function create_generator_resume_function(tcx, transform, body, can_return); // Run derefer to fix Derefs that are not in the first place deref_finder(tcx, body); } } 第 85 行 compute_layout 计算出 GeneratorLayout，并在 111 行保存到 body.generator 中。这里的 GeneratorLayout 就是 GeneratorState 的内存空间，它分成两部分：prefix + variants。prefix 保存了会跨越 suspend point 的变量，variants 是不同的 state，其中保存了只会在当前 state 使用到的变量。 GeneratorState 的内存布局是如何计算的？ 编译器在代码生成阶段会根据前面计算得到的 GeneratorLayout 算出最终的内存布局 Layout(compiler/rustc_middle/src/ty/layout.rs): /// Compute the full generator layout. fn generator_layout( &amp;self, ty: Ty&lt;&#39;tcx&gt;, def_id: hir::def_id::DefId, substs: SubstsRef&lt;&#39;tcx&gt;, ) -&gt; Result&lt;Layout&lt;&#39;tcx&gt;, LayoutError&lt;&#39;tcx&gt;&gt; { use SavedLocalEligibility::*; let tcx = self.tcx; let subst_field = |ty: Ty&lt;&#39;tcx&gt;| EarlyBinder(ty).subst(tcx, substs); let Some(info) = tcx.generator_layout(def_id) else { return Err(LayoutError::Unknown(ty)); }; let (ineligible_locals, assignments) = self.generator_saved_local_eligibility(&amp;info); // Build a prefix layout, including &quot;promoting&quot; all ineligible // locals as part of the prefix. We compute the layout of all of // these fields at once to get optimal packing. let tag_index = substs.as_generator().prefix_tys().count(); // `info.variant_fields` already accounts for the reserved variants, so no need to add them. let max_discr = (info.variant_fields.len() - 1) as u128; let discr_int = Integer::fit_unsigned(max_discr); let discr_int_ty = discr_int.to_ty(tcx, false); let tag = Scalar::Initialized { value: Primitive::Int(discr_int, false), valid_range: WrappingRange { start: 0, end: max_discr }, }; let tag_layout = self.tcx.intern_layout(LayoutS::scalar(self, tag)); let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout }; let promoted_layouts = ineligible_locals .iter() .map(|local| subst_field(info.field_tys[local])) .map(|ty| tcx.mk_maybe_uninit(ty)) .map(|ty| self.layout_of(ty)); let prefix_layouts = substs .as_generator() .prefix_tys() .map(|ty| self.layout_of(ty)) .chain(iter::once(Ok(tag_layout))) .chain(promoted_layouts) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?; let prefix = self.univariant_uninterned( ty, &amp;prefix_layouts, &amp;ReprOptions::default(), StructKind::AlwaysSized, )?; let (prefix_size, prefix_align) = (prefix.size, prefix.align); // Split the prefix layout into the &quot;outer&quot; fields (upvars and // discriminant) and the &quot;promoted&quot; fields. Promoted fields will // get included in each variant that requested them in // GeneratorLayout. debug!(&quot;prefix = {:#?}&quot;, prefix); let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields { FieldsShape::Arbitrary { mut offsets, memory_index } =&gt; { let mut inverse_memory_index = invert_mapping(&amp;memory_index); // &quot;a&quot; (`0..b_start`) and &quot;b&quot; (`b_start..`) correspond to // &quot;outer&quot; and &quot;promoted&quot; fields respectively. let b_start = (tag_index + 1) as u32; let offsets_b = offsets.split_off(b_start as usize); let offsets_a = offsets; // Disentangle the &quot;a&quot; and &quot;b&quot; components of `inverse_memory_index` // by preserving the order but keeping only one disjoint &quot;half&quot; each. // FIXME(eddyb) build a better abstraction for permutations, if possible. let inverse_memory_index_b: Vec&lt;_&gt; = inverse_memory_index.iter().filter_map(|&amp;i| i.checked_sub(b_start)).collect(); inverse_memory_index.retain(|&amp;i| i &lt; b_start); let inverse_memory_index_a = inverse_memory_index; // Since `inverse_memory_index_{a,b}` each only refer to their // respective fields, they can be safely inverted let memory_index_a = invert_mapping(&amp;inverse_memory_index_a); let memory_index_b = invert_mapping(&amp;inverse_memory_index_b); let outer_fields = FieldsShape::Arbitrary { offsets: offsets_a, memory_index: memory_index_a }; (outer_fields, offsets_b, memory_index_b) } _ =&gt; bug!(), }; let mut size = prefix.size; let mut align = prefix.align; let variants = info .variant_fields .iter_enumerated() .map(|(index, variant_fields)| { // Only include overlap-eligible fields when we compute our variant layout. let variant_only_tys = variant_fields .iter() .filter(|local| match assignments[**local] { Unassigned =&gt; bug!(), Assigned(v) if v == index =&gt; true, Assigned(_) =&gt; bug!(&quot;assignment does not match variant&quot;), Ineligible(_) =&gt; false, }) .map(|local| subst_field(info.field_tys[*local])); let mut variant = self.univariant_uninterned( ty, &amp;variant_only_tys .map(|ty| self.layout_of(ty)) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?, &amp;ReprOptions::default(), StructKind::Prefixed(prefix_size, prefix_align.abi), )?; variant.variants = Variants::Single { index }; let FieldsShape::Arbitrary { offsets, memory_index } = variant.fields else { bug!(); }; // Now, stitch the promoted and variant-only fields back together in // the order they are mentioned by our GeneratorLayout. // Because we only use some subset (that can differ between variants) // of the promoted fields, we can&#39;t just pick those elements of the // `promoted_memory_index` (as we&#39;d end up with gaps). // So instead, we build an &quot;inverse memory_index&quot;, as if all of the // promoted fields were being used, but leave the elements not in the // subset as `INVALID_FIELD_IDX`, which we can filter out later to // obtain a valid (bijective) mapping. const INVALID_FIELD_IDX: u32 = !0; let mut combined_inverse_memory_index = vec![INVALID_FIELD_IDX; promoted_memory_index.len() + memory_index.len()]; let mut offsets_and_memory_index = iter::zip(offsets, memory_index); let combined_offsets = variant_fields .iter() .enumerate() .map(|(i, local)| { let (offset, memory_index) = match assignments[*local] { Unassigned =&gt; bug!(), Assigned(_) =&gt; { let (offset, memory_index) = offsets_and_memory_index.next().unwrap(); (offset, promoted_memory_index.len() as u32 + memory_index) } Ineligible(field_idx) =&gt; { let field_idx = field_idx.unwrap() as usize; (promoted_offsets[field_idx], promoted_memory_index[field_idx]) } }; combined_inverse_memory_index[memory_index as usize] = i as u32; offset }) .collect(); // Remove the unused slots and invert the mapping to obtain the // combined `memory_index` (also see previous comment). combined_inverse_memory_index.retain(|&amp;i| i != INVALID_FIELD_IDX); let combined_memory_index = invert_mapping(&amp;combined_inverse_memory_index); variant.fields = FieldsShape::Arbitrary { offsets: combined_offsets, memory_index: combined_memory_index, }; size = size.max(variant.size); align = align.max(variant.align); Ok(tcx.intern_layout(variant)) }) .collect::&lt;Result&lt;IndexVec&lt;VariantIdx, _&gt;, _&gt;&gt;()?; size = size.align_to(align.abi); let abi = if prefix.abi.is_uninhabited() || variants.iter().all(|v| v.abi().is_uninhabited()) { Abi::Uninhabited } else { Abi::Aggregate { sized: true } }; let layout = tcx.intern_layout(LayoutS { variants: Variants::Multiple { tag, tag_encoding: TagEncoding::Direct, tag_field: tag_index, variants, }, fields: outer_fields, abi, largest_niche: prefix.largest_niche, size, align, }); debug!(&quot;generator layout ({:?}): {:#?}&quot;, ty, layout); Ok(layout) } LayoutS 的定义为： #[derive(PartialEq, Eq, Hash, HashStable_Generic)] pub struct LayoutS&lt;&#39;a&gt; { /// Says where the fields are located within the layout. pub fields: FieldsShape, /// Encodes information about multi-variant layouts. /// Even with `Multiple` variants, a layout still has its own fields! Those are then /// shared between all variants. One of them will be the discriminant, /// but e.g. generators can have more. /// /// To access all fields of this layout, both `fields` and the fields of the active variant /// must be taken into account. pub variants: Variants&lt;&#39;a&gt;, /// The `abi` defines how this data is passed between functions, and it defines /// value restrictions via `valid_range`. /// /// Note that this is entirely orthogonal to the recursive structure defined by /// `variants` and `fields`; for example, `ManuallyDrop&lt;Result&lt;isize, isize&gt;&gt;` has /// `Abi::ScalarPair`! So, even with non-`Aggregate` `abi`, `fields` and `variants` /// have to be taken into account to find all fields of this layout. pub abi: Abi, /// The leaf scalar with the largest number of invalid values /// (i.e. outside of its `valid_range`), if it exists. pub largest_niche: Option&lt;Niche&gt;, pub align: AbiAndPrefAlign, pub size: Size, } 根据定义，fields + variants 组成了 GeneratorState 的内存布局： To access all fields of this layout, both `fields` and the fields of the active variant must be taken into account. 在 generator_layout 函数中，fields 是 outer_fields，variants 是 Variant::Multiple 的实例，其中保存了 variants 和一个 tag_field。outer_fields 和 variants 均由 prefix 计算得到： // Split the prefix layout into the &quot;outer&quot; fields (upvars and // discriminant) and the &quot;promoted&quot; fields. Promoted fields will // get included in each variant that requested them in // GeneratorLayout prefix 的计算方式为： let tag_layout = self.tcx.intern_layout(LayoutS::scalar(self, tag)); let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout }; let promoted_layouts = ineligible_locals .iter() .map(|local| subst_field(info.field_tys[local])) .map(|ty| tcx.mk_maybe_uninit(ty)) .map(|ty| self.layout_of(ty)); let prefix_layouts = substs .as_generator() .prefix_tys() .map(|ty| self.layout_of(ty)) .chain(iter::once(Ok(tag_layout))) .chain(promoted_layouts) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?; let prefix = self.univariant_uninterned( ty, &amp;prefix_layouts, &amp;ReprOptions::default(), StructKind::AlwaysSized, )?; 其中 prefix_tys() 返回的就是前面提到的 upvars： /// This is the types of the fields of a generator which are not stored in a /// variant. #[inline] pub fn prefix_tys(self) -&gt; impl Iterator&lt;Item = Ty&lt;&#39;tcx&gt;&gt; { self.upvar_tys() } 因此，一个 GeneratorState 的 Layout 中会包含一个 tag，upvars，以及由不同 state 组成的 variants。回到 root_heartbeat 的例子，streaming() 中，除了 request 和 response 外，还会保存下参数中的 request: Request&lt;S&gt;，path 和 codec。 codec: tonic::codec::ProstCodec&lt;engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt; size 0 bytes request: tonic::Request&lt;futures::stream::Once&lt;futures::future::Ready&lt;engula_api::server::v1::HeartbeatRequest&gt;&gt;&gt; size 144 bytes path: http::uri::path::PathAndQuery size 40 bytes tag: u8 最终的大小为：self(8 bytes) + request(144 bytes) + path(40 bytes) + uri(88 bytes) + request(240 bytes, http request) + response(32 bytes) + tag(1 byte, aligned to 8) = 560 此处 uri 是前面计算漏掉的变量。 由于 async fn 的参数作为 captured variable，会放置在 outer_fields 中。如果一个非常大的参数层层传递到内部的某个 async fn，会被一层层放大，最终导致 Future 大小呈现指数增长。 19 年有一个 issue 已经指出了这个问题1。 解决方案？ 对于普通开发者，临时的解决办法有两点： 避免 pass by value，可以使用 Arc 或者 reference 减少使用 async fn。对于 tail calling，可以直接使用 impl Future，避免无意义的 await。 cpp 提供了左值引用，这类层层传递的变量可以被自然地优化；而 rust 依靠编译器优化，就得依靠生成的代码能满足优化的前置条件。 当然，community 也有人提供了改进方案2。该方案可以简述如下：即将 upvars 保存到 GeneratorState 的 unresumed state 中 （每个 GenerateState 至少有三种 state: unresumed, finished, paniced, 以及用户定义的 suspent_x)。 不过因为 rust 编译器架构改成了 demand-deriven compilation，该方案碰到了 query 循环依赖的问题， 需要等待其他人先将修复 dest prop 3。 https://github.com/rust-lang/rust/issues/62958 &#8617; https://github.com/rust-lang/rust/pull/89213 &#8617; https://github.com/rust-lang/rust/pull/96451 &#8617;" />
<link rel="canonical" href="/2022/09/05/rust-async-fn-genrated-futures-is-too-large.html" />
<meta property="og:url" content="/2022/09/05/rust-async-fn-genrated-futures-is-too-large.html" />
<meta property="og:site_name" content="W41ter’s Bistro" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-05T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Rust - The async fn generated Future is too large?" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-05T00:00:00+08:00","datePublished":"2022-09-05T00:00:00+08:00","description":"背景 最近开始对 engula 进行性能测试，发现 async fn 的性能损耗非常大，这不符合 zero overhead abstraction，因此开始对 async fn 的性能做一些研究。 通过增加参数 -Z print-type-size，可以输出每种类型的大小。发现很多 generator 内存大小非常大，其中最不符合直觉的是下面这几个： print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:39:69: 44:6]&gt;`: 1248 bytes, alignment: 8 bytes print-type-size field `.0`: 1248 bytes print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:79:52: 83:6]&gt;`: 1408 bytes, alignment: 8 bytes print-type-size field `.0`: 1408 bytes print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:88:51: 92:6]&gt;`: 1408 bytes, alignment: 8 bytes print-type-size field `.0`: 1408 bytes node_client.rs 是 tonic grpc client 的简单封装: use tonic::transport::Channel; #[derive(Debug, Clone)] pub struct Client { client: node_client::NodeClient&lt;Channel&gt;, } pub async fn root_heartbeat( &amp;self, req: HeartbeatRequest, ) -&gt; Result&lt;HeartbeatResponse, tonic::Status&gt; { let mut client = self.client.clone(); let res = client.root_heartbeat(req).await?; Ok(res.into_inner()) } node_client::NodeClient 是 tonic_build 生成的代码： impl&lt;T&gt; NodeClient&lt;T&gt; where T: tonic::client::GrpcService&lt;tonic::body::BoxBody&gt;, T::Error: Into&lt;StdError&gt;, T::ResponseBody: Body&lt;Data = Bytes&gt; + Send + &#39;static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;StdError&gt; + Send, { pub fn new(inner: T) -&gt; Self { let inner = tonic::client::Grpc::new(inner); Self { inner } } } pub async fn root_heartbeat( &amp;mut self, request: impl tonic::IntoRequest&lt;super::HeartbeatRequest&gt;, ) -&gt; Result&lt;tonic::Response&lt;super::HeartbeatResponse&gt;, tonic::Status&gt; { self.inner .ready() .await .map_err(|e| { tonic::Status::new( tonic::Code::Unknown, format!(&quot;Service was not ready: {}&quot;, e.into()), ) })?; let codec = tonic::codec::ProstCodec::default(); let path = http::uri::PathAndQuery::from_static( &quot;/engula.server.v1.Node/RootHeartbeat&quot;, ); self.inner.unary(request.into_request(), path, codec).await } 也就是说，每次调用 Grpc::unary 需要在栈上开辟 1K+ 的空间。如果最后使用了 tokio::spawn，那么还需要将它复制到堆上。无论是内存分配还是复制上的开销，对于一个高性能存储服务都是不可接受的。并且随着 async fn 的调用层数增加，Future 大小还会呈现指数增长，这一点我后面会分析。 Grpc::unary 的 memory layout 是怎样的？ 那么，为何 Grpc::unary 返回的 Future 需要消耗 1K+ 的内存空间呢？ 在 tonic/src/client/grpc.rs 中，unary 最终被委托给 Grpc::streaming，后者调用 Channel::call 并返回 ResponseFuture。 /// Send a single unary gRPC request. pub async fn unary&lt;M1, M2, C&gt;( &amp;mut self, request: Request&lt;M1&gt;, path: PathAndQuery, codec: C, ) -&gt; Result&lt;Response&lt;M2&gt;, Status&gt; where T: GrpcService&lt;BoxBody&gt;, T::ResponseBody: Body + Send + &#39;static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;, C: Codec&lt;Encode = M1, Decode = M2&gt;, M1: Send + Sync + &#39;static, M2: Send + Sync + &#39;static, { let request = request.map(|m| stream::once(future::ready(m))); self.client_streaming(request, path, codec).await } /// Send a client side streaming gRPC request. pub async fn client_streaming&lt;S, M1, M2, C&gt;( &amp;mut self, request: Request&lt;S&gt;, path: PathAndQuery, codec: C, ) -&gt; Result&lt;Response&lt;M2&gt;, Status&gt; where T: GrpcService&lt;BoxBody&gt;, T::ResponseBody: Body + Send + &#39;static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;, S: Stream&lt;Item = M1&gt; + Send + &#39;static, C: Codec&lt;Encode = M1, Decode = M2&gt;, M1: Send + Sync + &#39;static, M2: Send + Sync + &#39;static, { let (mut parts, body, extensions) = self.streaming(request, path, codec).await?.into_parts(); futures_util::pin_mut!(body); let message = body .try_next() .await .map_err(|mut status| { status.metadata_mut().merge(parts.clone()); status })? .ok_or_else(|| Status::new(Code::Internal, &quot;Missing response message.&quot;))?; if let Some(trailers) = body.trailers().await? { parts.merge(trailers); } Ok(Response::from_parts(parts, message, extensions)) } /// Send a bi-directional streaming gRPC request. pub async fn streaming&lt;S, M1, M2, C&gt;( &amp;mut self, request: Request&lt;S&gt;, path: PathAndQuery, mut codec: C, ) -&gt; Result&lt;Response&lt;Streaming&lt;M2&gt;&gt;, Status&gt; where T: GrpcService&lt;BoxBody&gt;, T::ResponseBody: Body + Send + &#39;static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;, S: Stream&lt;Item = M1&gt; + Send + &#39;static, C: Codec&lt;Encode = M1, Decode = M2&gt;, M1: Send + Sync + &#39;static, M2: Send + Sync + &#39;static, { let mut parts = Parts::default(); parts.path_and_query = Some(path); let uri = Uri::from_parts(parts).expect(&quot;path_and_query only is valid Uri&quot;); let request = request .map(|s| { encode_client( codec.encoder(), s, #[cfg(feature = &quot;compression&quot;)] self.send_compression_encodings, ) }) .map(BoxBody::new); let mut request = request.into_http( uri, http::Method::POST, http::Version::HTTP_2, SanitizeHeaders::Yes, ); // Add the gRPC related HTTP headers request .headers_mut() .insert(TE, HeaderValue::from_static(&quot;trailers&quot;)); // Set the content type request .headers_mut() .insert(CONTENT_TYPE, HeaderValue::from_static(&quot;application/grpc&quot;)); #[cfg(feature = &quot;compression&quot;)] { if let Some(encoding) = self.send_compression_encodings { request.headers_mut().insert( crate::codec::compression::ENCODING_HEADER, encoding.into_header_value(), ); } if let Some(header_value) = self .accept_compression_encodings .into_accept_encoding_header_value() { request.headers_mut().insert( crate::codec::compression::ACCEPT_ENCODING_HEADER, header_value, ); } } let response = self .inner .call(request) .await .map_err(|err| Status::from_error(err.into()))?; #[cfg(feature = &quot;compression&quot;)] let encoding = CompressionEncoding::from_encoding_header( response.headers(), self.accept_compression_encodings, )?; let status_code = response.status(); let trailers_only_status = Status::from_header_map(response.headers()); // We do not need to check for trailers if the `grpc-status` header is present // with a valid code. let expect_additional_trailers = if let Some(status) = trailers_only_status { if status.code() != Code::Ok { return Err(status); } false } else { true }; let response = response.map(|body| { if expect_additional_trailers { Streaming::new_response( codec.decoder(), body, status_code, #[cfg(feature = &quot;compression&quot;)] encoding, ) } else { Streaming::new_empty(codec.decoder(), body) } }); Ok(Response::from_http(response)) } 以前面的 root_heartbeat 为例，最终实例化的 streaming 的签名为： tonic::client::Grpc&lt;tonic::transport::Channel&gt;::streaming&lt; futures::stream::Once&lt; futures::future::Ready&lt; engula_api::server::v1::HeartbeatRequest&gt;&gt;, engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse, tonic::codec::ProstCodec&lt; engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt;&gt; 而 async fn streaming() 脱糖后，经过 transform 生成的状态机的内存布局为： generator layout ([static generator@tonic::client::Grpc&lt;tonic::transport::Channel&gt;::streaming&lt;futures::stream::Once&lt;futures::future::Ready&lt;engula_api::server::v1::HeartbeatRequest&gt;&gt;, engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse, tonic::codec::ProstCodec&lt;engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt;&gt;::{closure#0}]): Layout { size: Size(560 bytes), align: AbiAndPrefAlign { abi: Align(8 bytes), pref: Align(8 bytes), }, abi: Aggregate { sized: true, }, fields: Arbitrary { offsets: [ Size(0 bytes), Size(8 bytes), Size(152 bytes), Size(0 bytes), Size(552 bytes), ], } } 仔细分析 streaming 的代码可以发现，跨过 suspend point 的变量只有本地变量 request，预留空间 response: request: http::request::Request&lt;http_body::combinators::box_body::UnsyncBoxBody&lt;prost::bytes::Bytes, tonic::Status&gt;&gt; size = 240 bytes response: tonic::transport::channel::ResponseFuture size = 32 bytes 那么 request + response + tag （手写状态机的理论值）应该是远小于 560 bytes。到了 client_streaming 这里，内存空间就增长到了 1056 bytes。 async fn 的 layout 是如何计算的？ 这里进一步分析编译器内部是如何处理 async, await 和产生状态机的，看看不符合直觉的结果是如何产生的。 实际上 async fn 是 generator 的语法糖 async 和 await 都是语法糖，rust compiler 在 ast lowering 过程中进行了 desugar，并生成 hir。其中 async fn 会被替换为 generator (compiler/rustc_ast_lowering/src/item.rs)： fn lower_maybe_async_body( &amp;mut self, span: Span, decl: &amp;FnDecl, asyncness: Async, body: Option&lt;&amp;Block&gt;, ) -&gt; hir::BodyId { let closure_id = match asyncness { Async::Yes { closure_id, .. } =&gt; closure_id, Async::No =&gt; return self.lower_fn_body_block(span, decl, body), }; self.lower_body(|this| { let mut parameters: Vec&lt;hir::Param&lt;&#39;_&gt;&gt; = Vec::new(); let mut statements: Vec&lt;hir::Stmt&lt;&#39;_&gt;&gt; = Vec::new(); // Async function parameters are lowered into the closure body so that they are // captured and so that the drop order matches the equivalent non-async functions. // // from: // // async fn foo(&lt;pattern&gt;: &lt;ty&gt;, &lt;pattern&gt;: &lt;ty&gt;, &lt;pattern&gt;: &lt;ty&gt;) { // &lt;body&gt; // } // // into: // // fn foo(__arg0: &lt;ty&gt;, __arg1: &lt;ty&gt;, __arg2: &lt;ty&gt;) { // async move { // let __arg2 = __arg2; // let &lt;pattern&gt; = __arg2; // let __arg1 = __arg1; // let &lt;pattern&gt; = __arg1; // let __arg0 = __arg0; // let &lt;pattern&gt; = __arg0; // drop-temps { &lt;body&gt; } // see comments later in fn for details // } // } // // If `&lt;pattern&gt;` is a simple ident, then it is lowered to a single // `let &lt;pattern&gt; = &lt;pattern&gt;;` statement as an optimization. // // Note that the body is embedded in `drop-temps`; an // equivalent desugaring would be `return { &lt;body&gt; // };`. The key point is that we wish to drop all the // let-bound variables and temporaries created in the body // (and its tail expression!) before we drop the // parameters (c.f. rust-lang/rust#64512). for (index, parameter) in decl.inputs.iter().enumerate() { let parameter = this.lower_param(parameter); let span = parameter.pat.span; // Check if this is a binding pattern, if so, we can optimize and avoid adding a // `let &lt;pat&gt; = __argN;` statement. In this case, we do not rename the parameter. let (ident, is_simple_parameter) = match parameter.pat.kind { hir::PatKind::Binding( hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable, _, ident, _, ) =&gt; (ident, true), // For `ref mut` or wildcard arguments, we can&#39;t reuse the binding, but // we can keep the same name for the parameter. // This lets rustdoc render it correctly in documentation. hir::PatKind::Binding(_, _, ident, _) =&gt; (ident, false), hir::PatKind::Wild =&gt; { (Ident::with_dummy_span(rustc_span::symbol::kw::Underscore), false) } _ =&gt; { // Replace the ident for bindings that aren&#39;t simple. let name = format!(&quot;__arg{}&quot;, index); let ident = Ident::from_str(&amp;name); (ident, false) } }; let desugared_span = this.mark_span_with_reason(DesugaringKind::Async, span, None); // Construct a parameter representing `__argN: &lt;ty&gt;` to replace the parameter of the // async function. // // If this is the simple case, this parameter will end up being the same as the // original parameter, but with a different pattern id. let stmt_attrs = this.attrs.get(&amp;parameter.hir_id.local_id).copied(); let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident); let new_parameter = hir::Param { hir_id: parameter.hir_id, pat: new_parameter_pat, ty_span: this.lower_span(parameter.ty_span), span: this.lower_span(parameter.span), }; if is_simple_parameter { // If this is the simple case, then we only insert one statement that is // `let &lt;pat&gt; = &lt;pat&gt;;`. We re-use the original argument&#39;s pattern so that // `HirId`s are densely assigned. let expr = this.expr_ident(desugared_span, ident, new_parameter_id); let stmt = this.stmt_let_pat( stmt_attrs, desugared_span, Some(expr), parameter.pat, hir::LocalSource::AsyncFn, ); statements.push(stmt); } else { // If this is not the simple case, then we construct two statements: // // ``` // let __argN = __argN; // let &lt;pat&gt; = __argN; // ``` // // The first statement moves the parameter into the closure and thus ensures // that the drop order is correct. // // The second statement creates the bindings that the user wrote. // Construct the `let mut __argN = __argN;` statement. It must be a mut binding // because the user may have specified a `ref mut` binding in the next // statement. let (move_pat, move_id) = this.pat_ident_binding_mode( desugared_span, ident, hir::BindingAnnotation::Mutable, ); let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id); let move_stmt = this.stmt_let_pat( None, desugared_span, Some(move_expr), move_pat, hir::LocalSource::AsyncFn, ); // Construct the `let &lt;pat&gt; = __argN;` statement. We re-use the original // parameter&#39;s pattern so that `HirId`s are densely assigned. let pattern_expr = this.expr_ident(desugared_span, ident, move_id); let pattern_stmt = this.stmt_let_pat( stmt_attrs, desugared_span, Some(pattern_expr), parameter.pat, hir::LocalSource::AsyncFn, ); statements.push(move_stmt); statements.push(pattern_stmt); }; parameters.push(new_parameter); } let body_span = body.map_or(span, |b| b.span); let async_expr = this.make_async_expr( CaptureBy::Value, closure_id, None, body_span, hir::AsyncGeneratorKind::Fn, |this| { // Create a block from the user&#39;s function body: let user_body = this.lower_block_expr_opt(body_span, body); // Transform into `drop-temps { &lt;user-body&gt; }`, an expression: let desugared_span = this.mark_span_with_reason(DesugaringKind::Async, user_body.span, None); let user_body = this.expr_drop_temps( desugared_span, this.arena.alloc(user_body), AttrVec::new(), ); // As noted above, create the final block like // // ``` // { // let $param_pattern = $raw_param; // ... // drop-temps { &lt;user-body&gt; } // } // ``` let body = this.block_all( desugared_span, this.arena.alloc_from_iter(statements), Some(user_body), ); this.expr_block(body, AttrVec::new()) }, ); ( this.arena.alloc_from_iter(parameters), this.expr(body_span, async_expr, AttrVec::new()), ) }) } async fn 被替换为 generator 后，它的参数作为 captured variable 保存在 closure 中，后续称它为 upvars，在计算 Layout 是会使用到。 await 则会被替换为 poll()(compiler/rustc_ast_lowering/src/expr.rs): /// Desugar `&lt;expr&gt;.await` into: /// ```ignore (pseudo-rust) /// match ::std::future::IntoFuture::into_future(&lt;expr&gt;) { /// mut __awaitee =&gt; loop { /// match unsafe { ::std::future::Future::poll( /// &lt;::std::pin::Pin&gt;::new_unchecked(&amp;mut __awaitee), /// ::std::future::get_context(task_context), /// ) } { /// ::std::task::Poll::Ready(result) =&gt; break result, /// ::std::task::Poll::Pending =&gt; {} /// } /// task_context = yield (); /// } /// } /// ``` fn lower_expr_await(&amp;mut self, dot_await_span: Span, expr: &amp;Expr) -&gt; hir::ExprKind&lt;&#39;hir&gt; { let full_span = expr.span.to(dot_await_span); match self.generator_kind { Some(hir::GeneratorKind::Async(_)) =&gt; {} Some(hir::GeneratorKind::Gen) | None =&gt; { self.tcx.sess.emit_err(AwaitOnlyInAsyncFnAndBlocks { dot_await_span, item_span: self.current_item, }); } } let span = self.mark_span_with_reason(DesugaringKind::Await, dot_await_span, None); let gen_future_span = self.mark_span_with_reason( DesugaringKind::Await, full_span, self.allow_gen_future.clone(), ); let expr = self.lower_expr_mut(expr); let expr_hir_id = expr.hir_id; // Note that the name of this binding must not be changed to something else because // debuggers and debugger extensions expect it to be called `__awaitee`. They use // this name to identify what is being awaited by a suspended async functions. let awaitee_ident = Ident::with_dummy_span(sym::__awaitee); let (awaitee_pat, awaitee_pat_hid) = self.pat_ident_binding_mode(span, awaitee_ident, hir::BindingAnnotation::Mutable); let task_context_ident = Ident::with_dummy_span(sym::_task_context); // unsafe { // ::std::future::Future::poll( // ::std::pin::Pin::new_unchecked(&amp;mut __awaitee), // ::std::future::get_context(task_context), // ) // } let poll_expr = { let awaitee = self.expr_ident(span, awaitee_ident, awaitee_pat_hid); let ref_mut_awaitee = self.expr_mut_addr_of(span, awaitee); let task_context = if let Some(task_context_hid) = self.task_context { self.expr_ident_mut(span, task_context_ident, task_context_hid) } else { // Use of `await` outside of an async context, we cannot use `task_context` here. self.expr_err(span) }; let new_unchecked = self.expr_call_lang_item_fn_mut( span, hir::LangItem::PinNewUnchecked, arena_vec![self; ref_mut_awaitee], Some(expr_hir_id), ); let get_context = self.expr_call_lang_item_fn_mut( gen_future_span, hir::LangItem::GetContext, arena_vec![self; task_context], Some(expr_hir_id), ); let call = self.expr_call_lang_item_fn( span, hir::LangItem::FuturePoll, arena_vec![self; new_unchecked, get_context], Some(expr_hir_id), ); self.arena.alloc(self.expr_unsafe(call)) }; // `::std::task::Poll::Ready(result) =&gt; break result` let loop_node_id = self.next_node_id(); let loop_hir_id = self.lower_node_id(loop_node_id); let ready_arm = { let x_ident = Ident::with_dummy_span(sym::result); let (x_pat, x_pat_hid) = self.pat_ident(gen_future_span, x_ident); let x_expr = self.expr_ident(gen_future_span, x_ident, x_pat_hid); let ready_field = self.single_pat_field(gen_future_span, x_pat); let ready_pat = self.pat_lang_item_variant( span, hir::LangItem::PollReady, ready_field, Some(expr_hir_id), ); let break_x = self.with_loop_scope(loop_node_id, move |this| { let expr_break = hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr)); this.arena.alloc(this.expr(gen_future_span, expr_break, AttrVec::new())) }); self.arm(ready_pat, break_x) }; // `::std::task::Poll::Pending =&gt; {}` let pending_arm = { let pending_pat = self.pat_lang_item_variant( span, hir::LangItem::PollPending, &amp;[], Some(expr_hir_id), ); let empty_block = self.expr_block_empty(span); self.arm(pending_pat, empty_block) }; let inner_match_stmt = { let match_expr = self.expr_match( span, poll_expr, arena_vec![self; ready_arm, pending_arm], hir::MatchSource::AwaitDesugar, ); self.stmt_expr(span, match_expr) }; // task_context = yield (); let yield_stmt = { let unit = self.expr_unit(span); let yield_expr = self.expr( span, hir::ExprKind::Yield(unit, hir::YieldSource::Await { expr: Some(expr_hir_id) }), AttrVec::new(), ); let yield_expr = self.arena.alloc(yield_expr); if let Some(task_context_hid) = self.task_context { let lhs = self.expr_ident(span, task_context_ident, task_context_hid); let assign = self.expr( span, hir::ExprKind::Assign(lhs, yield_expr, self.lower_span(span)), AttrVec::new(), ); self.stmt_expr(span, assign) } else { // Use of `await` outside of an async context. Return `yield_expr` so that we can // proceed with type checking. self.stmt(span, hir::StmtKind::Semi(yield_expr)) } }; let loop_block = self.block_all(span, arena_vec![self; inner_match_stmt, yield_stmt], None); // loop { .. } let loop_expr = self.arena.alloc(hir::Expr { hir_id: loop_hir_id, kind: hir::ExprKind::Loop( loop_block, None, hir::LoopSource::Loop, self.lower_span(span), ), span: self.lower_span(span), }); // mut __awaitee =&gt; loop { ... } let awaitee_arm = self.arm(awaitee_pat, loop_expr); // `match ::std::future::IntoFuture::into_future(&lt;expr&gt;) { ... }` let into_future_span = self.mark_span_with_reason( DesugaringKind::Await, dot_await_span, self.allow_into_future.clone(), ); let into_future_expr = self.expr_call_lang_item_fn( into_future_span, hir::LangItem::IntoFutureIntoFuture, arena_vec![self; expr], Some(expr_hir_id), ); // match &lt;into_future_expr&gt; { // mut __awaitee =&gt; loop { .. } // } hir::ExprKind::Match( into_future_expr, arena_vec![self; awaitee_arm], hir::MatchSource::AwaitDesugar, ) } generator 会被替换为 GeneratorState 此后 hir 会转换为 mir，generator 在 mir_transform 中被替换为 GeneratorState(compiler/rustc_mir_transform/src/generator.rs): impl&lt;&#39;tcx&gt; MirPass&lt;&#39;tcx&gt; for StateTransform { fn run_pass(&amp;self, tcx: TyCtxt&lt;&#39;tcx&gt;, body: &amp;mut Body&lt;&#39;tcx&gt;) { let Some(yield_ty) = body.yield_ty() else { // This only applies to generators return; }; assert!(body.generator_drop().is_none()); dump_mir(tcx, None, &quot;generator_before&quot;, &amp;0, body, |_, _| Ok(())); // The first argument is the generator type passed by value let gen_ty = body.local_decls.raw[1].ty; // Get the interior types and substs which typeck computed let (upvars, interior, discr_ty, movable) = match *gen_ty.kind() { ty::Generator(_, substs, movability) =&gt; { let substs = substs.as_generator(); ( substs.upvar_tys().collect(), substs.witness(), substs.discr_ty(tcx), movability == hir::Movability::Movable, ) } _ =&gt; { tcx.sess .delay_span_bug(body.span, &amp;format!(&quot;unexpected generator type {}&quot;, gen_ty)); return; } }; // Compute GeneratorState&lt;yield_ty, return_ty&gt; let state_did = tcx.require_lang_item(LangItem::GeneratorState, None); let state_adt_ref = tcx.adt_def(state_did); let state_substs = tcx.intern_substs(&amp;[yield_ty.into(), body.return_ty().into()]); let ret_ty = tcx.mk_adt(state_adt_ref, state_substs); // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local // RETURN_PLACE then is a fresh unused local with type ret_ty. let new_ret_local = replace_local(RETURN_PLACE, ret_ty, body, tcx); // We also replace the resume argument and insert an `Assign`. // This is needed because the resume argument `_2` might be live across a `yield`, in which // case there is no `Assign` to it that the transform can turn into a store to the generator // state. After the yield the slot in the generator state would then be uninitialized. let resume_local = Local::new(2); let new_resume_local = replace_local(resume_local, body.local_decls[resume_local].ty, body, tcx); // When first entering the generator, move the resume argument into its new local. let source_info = SourceInfo::outermost(body.span); let stmts = &amp;mut body.basic_blocks_mut()[BasicBlock::new(0)].statements; stmts.insert( 0, Statement { source_info, kind: StatementKind::Assign(Box::new(( new_resume_local.into(), Rvalue::Use(Operand::Move(resume_local.into())), ))), }, ); let always_live_locals = always_storage_live_locals(&amp;body); let liveness_info = locals_live_across_suspend_points(tcx, body, &amp;always_live_locals, movable); sanitize_witness(tcx, body, interior, upvars, &amp;liveness_info.saved_locals); if tcx.sess.opts.unstable_opts.validate_mir { let mut vis = EnsureGeneratorFieldAssignmentsNeverAlias { assigned_local: None, saved_locals: &amp;liveness_info.saved_locals, storage_conflicts: &amp;liveness_info.storage_conflicts, }; vis.visit_body(body); } // Extract locals which are live across suspension point into `layout` // `remap` gives a mapping from local indices onto generator struct indices // `storage_liveness` tells us which locals have live storage at suspension points let (remap, layout, storage_liveness) = compute_layout(liveness_info, body); let can_return = can_return(tcx, body, tcx.param_env(body.source.def_id())); // Run the transformation which converts Places from Local to generator struct // accesses for locals in `remap`. // It also rewrites `return x` and `yield y` as writing a new generator state and returning // GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively. let mut transform = TransformVisitor { tcx, state_adt_ref, state_substs, remap, storage_liveness, always_live_locals, suspension_points: Vec::new(), new_ret_local, discr_ty, }; transform.visit_body(body); // Update our MIR struct to reflect the changes we&#39;ve made body.arg_count = 2; // self, resume arg body.spread_arg = None; body.generator.as_mut().unwrap().yield_ty = None; body.generator.as_mut().unwrap().generator_layout = Some(layout); // Insert `drop(generator_struct)` which is used to drop upvars for generators in // the unresumed state. // This is expanded to a drop ladder in `elaborate_generator_drops`. let drop_clean = insert_clean_drop(body); dump_mir(tcx, None, &quot;generator_pre-elab&quot;, &amp;0, body, |_, _| Ok(())); // Expand `drop(generator_struct)` to a drop ladder which destroys upvars. // If any upvars are moved out of, drop elaboration will handle upvar destruction. // However we need to also elaborate the code generated by `insert_clean_drop`. elaborate_generator_drops(tcx, body); dump_mir(tcx, None, &quot;generator_post-transform&quot;, &amp;0, body, |_, _| Ok(())); // Create a copy of our MIR and use it to create the drop shim for the generator let drop_shim = create_generator_drop_shim(tcx, &amp;transform, gen_ty, body, drop_clean); body.generator.as_mut().unwrap().generator_drop = Some(drop_shim); // Create the Generator::resume function create_generator_resume_function(tcx, transform, body, can_return); // Run derefer to fix Derefs that are not in the first place deref_finder(tcx, body); } } 第 85 行 compute_layout 计算出 GeneratorLayout，并在 111 行保存到 body.generator 中。这里的 GeneratorLayout 就是 GeneratorState 的内存空间，它分成两部分：prefix + variants。prefix 保存了会跨越 suspend point 的变量，variants 是不同的 state，其中保存了只会在当前 state 使用到的变量。 GeneratorState 的内存布局是如何计算的？ 编译器在代码生成阶段会根据前面计算得到的 GeneratorLayout 算出最终的内存布局 Layout(compiler/rustc_middle/src/ty/layout.rs): /// Compute the full generator layout. fn generator_layout( &amp;self, ty: Ty&lt;&#39;tcx&gt;, def_id: hir::def_id::DefId, substs: SubstsRef&lt;&#39;tcx&gt;, ) -&gt; Result&lt;Layout&lt;&#39;tcx&gt;, LayoutError&lt;&#39;tcx&gt;&gt; { use SavedLocalEligibility::*; let tcx = self.tcx; let subst_field = |ty: Ty&lt;&#39;tcx&gt;| EarlyBinder(ty).subst(tcx, substs); let Some(info) = tcx.generator_layout(def_id) else { return Err(LayoutError::Unknown(ty)); }; let (ineligible_locals, assignments) = self.generator_saved_local_eligibility(&amp;info); // Build a prefix layout, including &quot;promoting&quot; all ineligible // locals as part of the prefix. We compute the layout of all of // these fields at once to get optimal packing. let tag_index = substs.as_generator().prefix_tys().count(); // `info.variant_fields` already accounts for the reserved variants, so no need to add them. let max_discr = (info.variant_fields.len() - 1) as u128; let discr_int = Integer::fit_unsigned(max_discr); let discr_int_ty = discr_int.to_ty(tcx, false); let tag = Scalar::Initialized { value: Primitive::Int(discr_int, false), valid_range: WrappingRange { start: 0, end: max_discr }, }; let tag_layout = self.tcx.intern_layout(LayoutS::scalar(self, tag)); let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout }; let promoted_layouts = ineligible_locals .iter() .map(|local| subst_field(info.field_tys[local])) .map(|ty| tcx.mk_maybe_uninit(ty)) .map(|ty| self.layout_of(ty)); let prefix_layouts = substs .as_generator() .prefix_tys() .map(|ty| self.layout_of(ty)) .chain(iter::once(Ok(tag_layout))) .chain(promoted_layouts) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?; let prefix = self.univariant_uninterned( ty, &amp;prefix_layouts, &amp;ReprOptions::default(), StructKind::AlwaysSized, )?; let (prefix_size, prefix_align) = (prefix.size, prefix.align); // Split the prefix layout into the &quot;outer&quot; fields (upvars and // discriminant) and the &quot;promoted&quot; fields. Promoted fields will // get included in each variant that requested them in // GeneratorLayout. debug!(&quot;prefix = {:#?}&quot;, prefix); let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields { FieldsShape::Arbitrary { mut offsets, memory_index } =&gt; { let mut inverse_memory_index = invert_mapping(&amp;memory_index); // &quot;a&quot; (`0..b_start`) and &quot;b&quot; (`b_start..`) correspond to // &quot;outer&quot; and &quot;promoted&quot; fields respectively. let b_start = (tag_index + 1) as u32; let offsets_b = offsets.split_off(b_start as usize); let offsets_a = offsets; // Disentangle the &quot;a&quot; and &quot;b&quot; components of `inverse_memory_index` // by preserving the order but keeping only one disjoint &quot;half&quot; each. // FIXME(eddyb) build a better abstraction for permutations, if possible. let inverse_memory_index_b: Vec&lt;_&gt; = inverse_memory_index.iter().filter_map(|&amp;i| i.checked_sub(b_start)).collect(); inverse_memory_index.retain(|&amp;i| i &lt; b_start); let inverse_memory_index_a = inverse_memory_index; // Since `inverse_memory_index_{a,b}` each only refer to their // respective fields, they can be safely inverted let memory_index_a = invert_mapping(&amp;inverse_memory_index_a); let memory_index_b = invert_mapping(&amp;inverse_memory_index_b); let outer_fields = FieldsShape::Arbitrary { offsets: offsets_a, memory_index: memory_index_a }; (outer_fields, offsets_b, memory_index_b) } _ =&gt; bug!(), }; let mut size = prefix.size; let mut align = prefix.align; let variants = info .variant_fields .iter_enumerated() .map(|(index, variant_fields)| { // Only include overlap-eligible fields when we compute our variant layout. let variant_only_tys = variant_fields .iter() .filter(|local| match assignments[**local] { Unassigned =&gt; bug!(), Assigned(v) if v == index =&gt; true, Assigned(_) =&gt; bug!(&quot;assignment does not match variant&quot;), Ineligible(_) =&gt; false, }) .map(|local| subst_field(info.field_tys[*local])); let mut variant = self.univariant_uninterned( ty, &amp;variant_only_tys .map(|ty| self.layout_of(ty)) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?, &amp;ReprOptions::default(), StructKind::Prefixed(prefix_size, prefix_align.abi), )?; variant.variants = Variants::Single { index }; let FieldsShape::Arbitrary { offsets, memory_index } = variant.fields else { bug!(); }; // Now, stitch the promoted and variant-only fields back together in // the order they are mentioned by our GeneratorLayout. // Because we only use some subset (that can differ between variants) // of the promoted fields, we can&#39;t just pick those elements of the // `promoted_memory_index` (as we&#39;d end up with gaps). // So instead, we build an &quot;inverse memory_index&quot;, as if all of the // promoted fields were being used, but leave the elements not in the // subset as `INVALID_FIELD_IDX`, which we can filter out later to // obtain a valid (bijective) mapping. const INVALID_FIELD_IDX: u32 = !0; let mut combined_inverse_memory_index = vec![INVALID_FIELD_IDX; promoted_memory_index.len() + memory_index.len()]; let mut offsets_and_memory_index = iter::zip(offsets, memory_index); let combined_offsets = variant_fields .iter() .enumerate() .map(|(i, local)| { let (offset, memory_index) = match assignments[*local] { Unassigned =&gt; bug!(), Assigned(_) =&gt; { let (offset, memory_index) = offsets_and_memory_index.next().unwrap(); (offset, promoted_memory_index.len() as u32 + memory_index) } Ineligible(field_idx) =&gt; { let field_idx = field_idx.unwrap() as usize; (promoted_offsets[field_idx], promoted_memory_index[field_idx]) } }; combined_inverse_memory_index[memory_index as usize] = i as u32; offset }) .collect(); // Remove the unused slots and invert the mapping to obtain the // combined `memory_index` (also see previous comment). combined_inverse_memory_index.retain(|&amp;i| i != INVALID_FIELD_IDX); let combined_memory_index = invert_mapping(&amp;combined_inverse_memory_index); variant.fields = FieldsShape::Arbitrary { offsets: combined_offsets, memory_index: combined_memory_index, }; size = size.max(variant.size); align = align.max(variant.align); Ok(tcx.intern_layout(variant)) }) .collect::&lt;Result&lt;IndexVec&lt;VariantIdx, _&gt;, _&gt;&gt;()?; size = size.align_to(align.abi); let abi = if prefix.abi.is_uninhabited() || variants.iter().all(|v| v.abi().is_uninhabited()) { Abi::Uninhabited } else { Abi::Aggregate { sized: true } }; let layout = tcx.intern_layout(LayoutS { variants: Variants::Multiple { tag, tag_encoding: TagEncoding::Direct, tag_field: tag_index, variants, }, fields: outer_fields, abi, largest_niche: prefix.largest_niche, size, align, }); debug!(&quot;generator layout ({:?}): {:#?}&quot;, ty, layout); Ok(layout) } LayoutS 的定义为： #[derive(PartialEq, Eq, Hash, HashStable_Generic)] pub struct LayoutS&lt;&#39;a&gt; { /// Says where the fields are located within the layout. pub fields: FieldsShape, /// Encodes information about multi-variant layouts. /// Even with `Multiple` variants, a layout still has its own fields! Those are then /// shared between all variants. One of them will be the discriminant, /// but e.g. generators can have more. /// /// To access all fields of this layout, both `fields` and the fields of the active variant /// must be taken into account. pub variants: Variants&lt;&#39;a&gt;, /// The `abi` defines how this data is passed between functions, and it defines /// value restrictions via `valid_range`. /// /// Note that this is entirely orthogonal to the recursive structure defined by /// `variants` and `fields`; for example, `ManuallyDrop&lt;Result&lt;isize, isize&gt;&gt;` has /// `Abi::ScalarPair`! So, even with non-`Aggregate` `abi`, `fields` and `variants` /// have to be taken into account to find all fields of this layout. pub abi: Abi, /// The leaf scalar with the largest number of invalid values /// (i.e. outside of its `valid_range`), if it exists. pub largest_niche: Option&lt;Niche&gt;, pub align: AbiAndPrefAlign, pub size: Size, } 根据定义，fields + variants 组成了 GeneratorState 的内存布局： To access all fields of this layout, both `fields` and the fields of the active variant must be taken into account. 在 generator_layout 函数中，fields 是 outer_fields，variants 是 Variant::Multiple 的实例，其中保存了 variants 和一个 tag_field。outer_fields 和 variants 均由 prefix 计算得到： // Split the prefix layout into the &quot;outer&quot; fields (upvars and // discriminant) and the &quot;promoted&quot; fields. Promoted fields will // get included in each variant that requested them in // GeneratorLayout prefix 的计算方式为： let tag_layout = self.tcx.intern_layout(LayoutS::scalar(self, tag)); let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout }; let promoted_layouts = ineligible_locals .iter() .map(|local| subst_field(info.field_tys[local])) .map(|ty| tcx.mk_maybe_uninit(ty)) .map(|ty| self.layout_of(ty)); let prefix_layouts = substs .as_generator() .prefix_tys() .map(|ty| self.layout_of(ty)) .chain(iter::once(Ok(tag_layout))) .chain(promoted_layouts) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?; let prefix = self.univariant_uninterned( ty, &amp;prefix_layouts, &amp;ReprOptions::default(), StructKind::AlwaysSized, )?; 其中 prefix_tys() 返回的就是前面提到的 upvars： /// This is the types of the fields of a generator which are not stored in a /// variant. #[inline] pub fn prefix_tys(self) -&gt; impl Iterator&lt;Item = Ty&lt;&#39;tcx&gt;&gt; { self.upvar_tys() } 因此，一个 GeneratorState 的 Layout 中会包含一个 tag，upvars，以及由不同 state 组成的 variants。回到 root_heartbeat 的例子，streaming() 中，除了 request 和 response 外，还会保存下参数中的 request: Request&lt;S&gt;，path 和 codec。 codec: tonic::codec::ProstCodec&lt;engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt; size 0 bytes request: tonic::Request&lt;futures::stream::Once&lt;futures::future::Ready&lt;engula_api::server::v1::HeartbeatRequest&gt;&gt;&gt; size 144 bytes path: http::uri::path::PathAndQuery size 40 bytes tag: u8 最终的大小为：self(8 bytes) + request(144 bytes) + path(40 bytes) + uri(88 bytes) + request(240 bytes, http request) + response(32 bytes) + tag(1 byte, aligned to 8) = 560 此处 uri 是前面计算漏掉的变量。 由于 async fn 的参数作为 captured variable，会放置在 outer_fields 中。如果一个非常大的参数层层传递到内部的某个 async fn，会被一层层放大，最终导致 Future 大小呈现指数增长。 19 年有一个 issue 已经指出了这个问题1。 解决方案？ 对于普通开发者，临时的解决办法有两点： 避免 pass by value，可以使用 Arc 或者 reference 减少使用 async fn。对于 tail calling，可以直接使用 impl Future，避免无意义的 await。 cpp 提供了左值引用，这类层层传递的变量可以被自然地优化；而 rust 依靠编译器优化，就得依靠生成的代码能满足优化的前置条件。 当然，community 也有人提供了改进方案2。该方案可以简述如下：即将 upvars 保存到 GeneratorState 的 unresumed state 中 （每个 GenerateState 至少有三种 state: unresumed, finished, paniced, 以及用户定义的 suspent_x)。 不过因为 rust 编译器架构改成了 demand-deriven compilation，该方案碰到了 query 循环依赖的问题， 需要等待其他人先将修复 dest prop 3。 https://github.com/rust-lang/rust/issues/62958 &#8617; https://github.com/rust-lang/rust/pull/89213 &#8617; https://github.com/rust-lang/rust/pull/96451 &#8617;","headline":"Rust - The async fn generated Future is too large?","mainEntityOfPage":{"@type":"WebPage","@id":"/2022/09/05/rust-async-fn-genrated-futures-is-too-large.html"},"url":"/2022/09/05/rust-async-fn-genrated-futures-is-too-large.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="W41ter's Bistro" /><!-- for mathjax support -->
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">W41ter&#39;s Bistro</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Rust - The `async fn` generated `Future` is too large?</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-09-05T00:00:00+08:00" itemprop="datePublished">Sep 5, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="背景">背景</h1>

<p>最近开始对 engula 进行性能测试，发现 async fn 的性能损耗非常大，这不符合 zero overhead abstraction，因此开始对 async fn 的性能做一些研究。</p>

<p>通过增加参数 <code class="language-plaintext highlighter-rouge">-Z print-type-size</code>，可以输出每种类型的大小。发现很多 generator 内存大小非常大，其中最不符合直觉的是下面这几个：</p>

<pre><code class="language-log">print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:39:69: 44:6]&gt;`: 1248 bytes, alignment: 8 bytes
print-type-size     field `.0`: 1248 bytes
print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:79:52: 83:6]&gt;`: 1408 bytes, alignment: 8 bytes
print-type-size     field `.0`: 1408 bytes
print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:88:51: 92:6]&gt;`: 1408 bytes, alignment: 8 bytes
print-type-size     field `.0`: 1408 bytes
</code></pre>

<p>node_client.rs 是 tonic grpc client 的简单封装:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">tonic</span><span class="p">::</span><span class="nn">transport</span><span class="p">::</span><span class="n">Channel</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Client</span> <span class="p">{</span>
    <span class="n">client</span><span class="p">:</span> <span class="nn">node_client</span><span class="p">::</span><span class="n">NodeClient</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">root_heartbeat</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">req</span><span class="p">:</span> <span class="n">HeartbeatRequest</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">HeartbeatResponse</span><span class="p">,</span> <span class="nn">tonic</span><span class="p">::</span><span class="n">Status</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">client</span> <span class="o">=</span> <span class="k">self</span><span class="py">.client</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">client</span><span class="nf">.root_heartbeat</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">res</span><span class="nf">.into_inner</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">node_client::NodeClient</code> 是 tonic_build 生成的代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">NodeClient</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nn">tonic</span><span class="p">::</span><span class="nn">client</span><span class="p">::</span><span class="n">GrpcService</span><span class="o">&lt;</span><span class="nn">tonic</span><span class="p">::</span><span class="nn">body</span><span class="p">::</span><span class="n">BoxBody</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nn">T</span><span class="p">::</span><span class="n">Error</span><span class="p">:</span> <span class="nb">Into</span><span class="o">&lt;</span><span class="n">StdError</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nn">T</span><span class="p">::</span><span class="n">ResponseBody</span><span class="p">:</span> <span class="n">Body</span><span class="o">&lt;</span><span class="n">Data</span> <span class="o">=</span> <span class="n">Bytes</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span>
    <span class="o">&lt;</span><span class="nn">T</span><span class="p">::</span><span class="n">ResponseBody</span> <span class="k">as</span> <span class="n">Body</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Error</span><span class="p">:</span> <span class="nb">Into</span><span class="o">&lt;</span><span class="n">StdError</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Send</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">inner</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">inner</span> <span class="o">=</span> <span class="nn">tonic</span><span class="p">::</span><span class="nn">client</span><span class="p">::</span><span class="nn">Grpc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">inner</span><span class="p">);</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">inner</span> <span class="p">}</span>
    <span class="p">}</span>    
<span class="p">}</span>

<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">root_heartbeat</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
    <span class="n">request</span><span class="p">:</span> <span class="k">impl</span> <span class="nn">tonic</span><span class="p">::</span><span class="n">IntoRequest</span><span class="o">&lt;</span><span class="k">super</span><span class="p">::</span><span class="n">HeartbeatRequest</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nn">tonic</span><span class="p">::</span><span class="n">Response</span><span class="o">&lt;</span><span class="k">super</span><span class="p">::</span><span class="n">HeartbeatResponse</span><span class="o">&gt;</span><span class="p">,</span> <span class="nn">tonic</span><span class="p">::</span><span class="n">Status</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.inner</span>
        <span class="nf">.ready</span><span class="p">()</span>
        <span class="k">.await</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="p">{</span>
            <span class="nn">tonic</span><span class="p">::</span><span class="nn">Status</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
                <span class="nn">tonic</span><span class="p">::</span><span class="nn">Code</span><span class="p">::</span><span class="n">Unknown</span><span class="p">,</span>
                <span class="nd">format!</span><span class="p">(</span><span class="s">"Service was not ready: {}"</span><span class="p">,</span> <span class="n">e</span><span class="nf">.into</span><span class="p">()),</span>
            <span class="p">)</span>
        <span class="p">})</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">codec</span> <span class="o">=</span> <span class="nn">tonic</span><span class="p">::</span><span class="nn">codec</span><span class="p">::</span><span class="nn">ProstCodec</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nn">http</span><span class="p">::</span><span class="nn">uri</span><span class="p">::</span><span class="nn">PathAndQuery</span><span class="p">::</span><span class="nf">from_static</span><span class="p">(</span>
        <span class="s">"/engula.server.v1.Node/RootHeartbeat"</span><span class="p">,</span>
    <span class="p">);</span>
    <span class="k">self</span><span class="py">.inner</span><span class="nf">.unary</span><span class="p">(</span><span class="n">request</span><span class="nf">.into_request</span><span class="p">(),</span> <span class="n">path</span><span class="p">,</span> <span class="n">codec</span><span class="p">)</span><span class="k">.await</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也就是说，每次调用 <code class="language-plaintext highlighter-rouge">Grpc::unary</code> 需要在栈上开辟 1K+ 的空间。如果最后使用了 <code class="language-plaintext highlighter-rouge">tokio::spawn</code>，那么还需要将它复制到堆上。无论是内存分配还是复制上的开销，对于一个高性能存储服务都是不可接受的。并且随着 <code class="language-plaintext highlighter-rouge">async fn</code> 的调用层数增加，<code class="language-plaintext highlighter-rouge">Future</code> 大小还会呈现指数增长，这一点我后面会分析。</p>

<h1 id="grpcunary-的-memory-layout-是怎样的">Grpc::unary 的 memory layout 是怎样的？</h1>

<p>那么，为何 <code class="language-plaintext highlighter-rouge">Grpc::unary</code> 返回的 <code class="language-plaintext highlighter-rouge">Future</code> 需要消耗 1K+ 的内存空间呢？</p>

<p>在 tonic/src/client/grpc.rs 中，<code class="language-plaintext highlighter-rouge">unary</code> 最终被委托给 <code class="language-plaintext highlighter-rouge">Grpc::streaming</code>，后者调用 <code class="language-plaintext highlighter-rouge">Channel::call</code> 并返回 <code class="language-plaintext highlighter-rouge">ResponseFuture</code>。</p>

<pre><code class="language-Rust">/// Send a single unary gRPC request.
pub async fn unary&lt;M1, M2, C&gt;(
    &amp;mut self,
    request: Request&lt;M1&gt;,
    path: PathAndQuery,
    codec: C,
) -&gt; Result&lt;Response&lt;M2&gt;, Status&gt;
where
    T: GrpcService&lt;BoxBody&gt;,
    T::ResponseBody: Body + Send + 'static,
    &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;,
    C: Codec&lt;Encode = M1, Decode = M2&gt;,
    M1: Send + Sync + 'static,
    M2: Send + Sync + 'static,
{
    let request = request.map(|m| stream::once(future::ready(m)));
    self.client_streaming(request, path, codec).await
}

/// Send a client side streaming gRPC request.
pub async fn client_streaming&lt;S, M1, M2, C&gt;(
    &amp;mut self,
    request: Request&lt;S&gt;,
    path: PathAndQuery,
    codec: C,
) -&gt; Result&lt;Response&lt;M2&gt;, Status&gt;
where
    T: GrpcService&lt;BoxBody&gt;,
    T::ResponseBody: Body + Send + 'static,
    &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;,
    S: Stream&lt;Item = M1&gt; + Send + 'static,
    C: Codec&lt;Encode = M1, Decode = M2&gt;,
    M1: Send + Sync + 'static,
    M2: Send + Sync + 'static,
{
    let (mut parts, body, extensions) =
        self.streaming(request, path, codec).await?.into_parts();

    futures_util::pin_mut!(body);

    let message = body
        .try_next()
        .await
        .map_err(|mut status| {
            status.metadata_mut().merge(parts.clone());
            status
        })?
        .ok_or_else(|| Status::new(Code::Internal, "Missing response message."))?;

    if let Some(trailers) = body.trailers().await? {
        parts.merge(trailers);
    }

    Ok(Response::from_parts(parts, message, extensions))
}

/// Send a bi-directional streaming gRPC request.
pub async fn streaming&lt;S, M1, M2, C&gt;(
    &amp;mut self,
    request: Request&lt;S&gt;,
    path: PathAndQuery,
    mut codec: C,
) -&gt; Result&lt;Response&lt;Streaming&lt;M2&gt;&gt;, Status&gt;
where
    T: GrpcService&lt;BoxBody&gt;,
    T::ResponseBody: Body + Send + 'static,
    &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;,
    S: Stream&lt;Item = M1&gt; + Send + 'static,
    C: Codec&lt;Encode = M1, Decode = M2&gt;,
    M1: Send + Sync + 'static,
    M2: Send + Sync + 'static,
{
    let mut parts = Parts::default();
    parts.path_and_query = Some(path);

    let uri = Uri::from_parts(parts).expect("path_and_query only is valid Uri");

    let request = request
        .map(|s| {
            encode_client(
                codec.encoder(),
                s,
                #[cfg(feature = "compression")]
                self.send_compression_encodings,
            )
        })
        .map(BoxBody::new);

    let mut request = request.into_http(
        uri,
        http::Method::POST,
        http::Version::HTTP_2,
        SanitizeHeaders::Yes,
    );

    // Add the gRPC related HTTP headers
    request
        .headers_mut()
        .insert(TE, HeaderValue::from_static("trailers"));

    // Set the content type
    request
        .headers_mut()
        .insert(CONTENT_TYPE, HeaderValue::from_static("application/grpc"));

    #[cfg(feature = "compression")]
    {
        if let Some(encoding) = self.send_compression_encodings {
            request.headers_mut().insert(
                crate::codec::compression::ENCODING_HEADER,
                encoding.into_header_value(),
            );
        }

        if let Some(header_value) = self
            .accept_compression_encodings
            .into_accept_encoding_header_value()
        {
            request.headers_mut().insert(
                crate::codec::compression::ACCEPT_ENCODING_HEADER,
                header_value,
            );
        }
    }

    let response = self
        .inner
        .call(request)
        .await
        .map_err(|err| Status::from_error(err.into()))?;

    #[cfg(feature = "compression")]
    let encoding = CompressionEncoding::from_encoding_header(
        response.headers(),
        self.accept_compression_encodings,
    )?;

    let status_code = response.status();
    let trailers_only_status = Status::from_header_map(response.headers());

    // We do not need to check for trailers if the `grpc-status` header is present
    // with a valid code.
    let expect_additional_trailers = if let Some(status) = trailers_only_status {
        if status.code() != Code::Ok {
            return Err(status);
        }

        false
    } else {
        true
    };

    let response = response.map(|body| {
        if expect_additional_trailers {
            Streaming::new_response(
                codec.decoder(),
                body,
                status_code,
                #[cfg(feature = "compression")]
                encoding,
            )
        } else {
            Streaming::new_empty(codec.decoder(), body)
        }
    });

    Ok(Response::from_http(response))
}
</code></pre>

<p>以前面的 <code class="language-plaintext highlighter-rouge">root_heartbeat</code> 为例，最终实例化的 <code class="language-plaintext highlighter-rouge">streaming</code> 的签名为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tonic::client::Grpc&lt;tonic::transport::Channel&gt;::streaming&lt;
    futures::stream::Once&lt;
        futures::future::Ready&lt;
            engula_api::server::v1::HeartbeatRequest&gt;&gt;,
    engula_api::server::v1::HeartbeatRequest,
    engula_api::server::v1::HeartbeatResponse,
    tonic::codec::ProstCodec&lt;
        engula_api::server::v1::HeartbeatRequest,
        engula_api::server::v1::HeartbeatResponse&gt;&gt;
</code></pre></div></div>

<p>而 <code class="language-plaintext highlighter-rouge">async fn streaming()</code> 脱糖后，经过 transform 生成的状态机的内存布局为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>generator layout ([static generator@tonic::client::Grpc&lt;tonic::transport::Channel&gt;::streaming&lt;futures::stream::Once&lt;futures::future::Ready&lt;engula_api::server::v1::HeartbeatRequest&gt;&gt;, engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse, tonic::codec::ProstCodec&lt;engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt;&gt;::{closure#0}]): Layout {
    size: Size(560 bytes),
    align: AbiAndPrefAlign {
        abi: Align(8 bytes),
        pref: Align(8 bytes),
    },
    abi: Aggregate {
        sized: true,
    },
    fields: Arbitrary {
        offsets: [
        Size(0 bytes),
        Size(8 bytes),
        Size(152 bytes),
        Size(0 bytes),
        Size(552 bytes),
        ],
    }
}
</code></pre></div></div>

<p>仔细分析 <code class="language-plaintext highlighter-rouge">streaming</code> 的代码可以发现，跨过 <code class="language-plaintext highlighter-rouge">suspend point</code> 的变量只有本地变量 <code class="language-plaintext highlighter-rouge">request</code>，预留空间 <code class="language-plaintext highlighter-rouge">response</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">request</code>: <code class="language-plaintext highlighter-rouge">http::request::Request&lt;http_body::combinators::box_body::UnsyncBoxBody&lt;prost::bytes::Bytes, tonic::Status&gt;&gt;</code> size = 240 bytes</li>
  <li><code class="language-plaintext highlighter-rouge">response</code>: <code class="language-plaintext highlighter-rouge">tonic::transport::channel::ResponseFuture</code> size = 32 bytes</li>
</ul>

<p>那么 <code class="language-plaintext highlighter-rouge">request</code> + <code class="language-plaintext highlighter-rouge">response</code> + <code class="language-plaintext highlighter-rouge">tag</code> （手写状态机的理论值）应该是远小于 560 bytes。到了 <code class="language-plaintext highlighter-rouge">client_streaming</code> 这里，内存空间就增长到了 1056 bytes。</p>

<h1 id="async-fn-的-layout-是如何计算的">async fn 的 layout 是如何计算的？</h1>

<p>这里进一步分析编译器内部是如何处理 <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code> 和产生状态机的，看看不符合直觉的结果是如何产生的。</p>

<h2 id="实际上-async-fn-是-generator-的语法糖">实际上 async fn 是 generator 的语法糖</h2>

<p><code class="language-plaintext highlighter-rouge">async</code> 和 <code class="language-plaintext highlighter-rouge">await</code> 都是语法糖，rust compiler 在 ast lowering 过程中进行了 desugar，并生成 hir。其中 <code class="language-plaintext highlighter-rouge">async fn</code> 会被替换为 generator (compiler/rustc_ast_lowering/src/item.rs)：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">lower_maybe_async_body</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
    <span class="n">span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">decl</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">FnDecl</span><span class="p">,</span>
    <span class="n">asyncness</span><span class="p">:</span> <span class="n">Async</span><span class="p">,</span>
    <span class="n">body</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Block</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">hir</span><span class="p">::</span><span class="n">BodyId</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">closure_id</span> <span class="o">=</span> <span class="k">match</span> <span class="n">asyncness</span> <span class="p">{</span>
        <span class="nn">Async</span><span class="p">::</span><span class="n">Yes</span> <span class="p">{</span> <span class="n">closure_id</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="n">closure_id</span><span class="p">,</span>
        <span class="nn">Async</span><span class="p">::</span><span class="n">No</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="k">self</span><span class="nf">.lower_fn_body_block</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">decl</span><span class="p">,</span> <span class="n">body</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="k">self</span><span class="nf">.lower_body</span><span class="p">(|</span><span class="n">this</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">parameters</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">hir</span><span class="p">::</span><span class="n">Param</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">statements</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">hir</span><span class="p">::</span><span class="n">Stmt</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="c1">// Async function parameters are lowered into the closure body so that they are</span>
        <span class="c1">// captured and so that the drop order matches the equivalent non-async functions.</span>
        <span class="c1">//</span>
        <span class="c1">// from:</span>
        <span class="c1">//</span>
        <span class="c1">//     async fn foo(&lt;pattern&gt;: &lt;ty&gt;, &lt;pattern&gt;: &lt;ty&gt;, &lt;pattern&gt;: &lt;ty&gt;) {</span>
        <span class="c1">//         &lt;body&gt;</span>
        <span class="c1">//     }</span>
        <span class="c1">//</span>
        <span class="c1">// into:</span>
        <span class="c1">//</span>
        <span class="c1">//     fn foo(__arg0: &lt;ty&gt;, __arg1: &lt;ty&gt;, __arg2: &lt;ty&gt;) {</span>
        <span class="c1">//       async move {</span>
        <span class="c1">//         let __arg2 = __arg2;</span>
        <span class="c1">//         let &lt;pattern&gt; = __arg2;</span>
        <span class="c1">//         let __arg1 = __arg1;</span>
        <span class="c1">//         let &lt;pattern&gt; = __arg1;</span>
        <span class="c1">//         let __arg0 = __arg0;</span>
        <span class="c1">//         let &lt;pattern&gt; = __arg0;</span>
        <span class="c1">//         drop-temps { &lt;body&gt; } // see comments later in fn for details</span>
        <span class="c1">//       }</span>
        <span class="c1">//     }</span>
        <span class="c1">//</span>
        <span class="c1">// If `&lt;pattern&gt;` is a simple ident, then it is lowered to a single</span>
        <span class="c1">// `let &lt;pattern&gt; = &lt;pattern&gt;;` statement as an optimization.</span>
        <span class="c1">//</span>
        <span class="c1">// Note that the body is embedded in `drop-temps`; an</span>
        <span class="c1">// equivalent desugaring would be `return { &lt;body&gt;</span>
        <span class="c1">// };`. The key point is that we wish to drop all the</span>
        <span class="c1">// let-bound variables and temporaries created in the body</span>
        <span class="c1">// (and its tail expression!) before we drop the</span>
        <span class="c1">// parameters (c.f. rust-lang/rust#64512).</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">parameter</span><span class="p">)</span> <span class="k">in</span> <span class="n">decl</span><span class="py">.inputs</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">parameter</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.lower_param</span><span class="p">(</span><span class="n">parameter</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">span</span> <span class="o">=</span> <span class="n">parameter</span><span class="py">.pat.span</span><span class="p">;</span>

            <span class="c1">// Check if this is a binding pattern, if so, we can optimize and avoid adding a</span>
            <span class="c1">// `let &lt;pat&gt; = __argN;` statement. In this case, we do not rename the parameter.</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="n">is_simple_parameter</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">parameter</span><span class="py">.pat.kind</span> <span class="p">{</span>
                <span class="nn">hir</span><span class="p">::</span><span class="nn">PatKind</span><span class="p">::</span><span class="nf">Binding</span><span class="p">(</span>
                    <span class="nn">hir</span><span class="p">::</span><span class="nn">BindingAnnotation</span><span class="p">::</span><span class="n">Unannotated</span> <span class="p">|</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">BindingAnnotation</span><span class="p">::</span><span class="n">Mutable</span><span class="p">,</span>
                    <span class="n">_</span><span class="p">,</span>
                    <span class="n">ident</span><span class="p">,</span>
                    <span class="n">_</span><span class="p">,</span>
                <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="k">true</span><span class="p">),</span>
                <span class="c1">// For `ref mut` or wildcard arguments, we can't reuse the binding, but</span>
                <span class="c1">// we can keep the same name for the parameter.</span>
                <span class="c1">// This lets rustdoc render it correctly in documentation.</span>
                <span class="nn">hir</span><span class="p">::</span><span class="nn">PatKind</span><span class="p">::</span><span class="nf">Binding</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="k">false</span><span class="p">),</span>
                <span class="nn">hir</span><span class="p">::</span><span class="nn">PatKind</span><span class="p">::</span><span class="n">Wild</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nn">Ident</span><span class="p">::</span><span class="nf">with_dummy_span</span><span class="p">(</span><span class="nn">rustc_span</span><span class="p">::</span><span class="nn">symbol</span><span class="p">::</span><span class="nn">kw</span><span class="p">::</span><span class="n">Underscore</span><span class="p">),</span> <span class="k">false</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// Replace the ident for bindings that aren't simple.</span>
                    <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"__arg{}"</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
                    <span class="k">let</span> <span class="n">ident</span> <span class="o">=</span> <span class="nn">Ident</span><span class="p">::</span><span class="nf">from_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>

                    <span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">};</span>

            <span class="k">let</span> <span class="n">desugared_span</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.mark_span_with_reason</span><span class="p">(</span><span class="nn">DesugaringKind</span><span class="p">::</span><span class="n">Async</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>

            <span class="c1">// Construct a parameter representing `__argN: &lt;ty&gt;` to replace the parameter of the</span>
            <span class="c1">// async function.</span>
            <span class="c1">//</span>
            <span class="c1">// If this is the simple case, this parameter will end up being the same as the</span>
            <span class="c1">// original parameter, but with a different pattern id.</span>
            <span class="k">let</span> <span class="n">stmt_attrs</span> <span class="o">=</span> <span class="n">this</span><span class="py">.attrs</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parameter</span><span class="py">.hir_id.local_id</span><span class="p">)</span><span class="nf">.copied</span><span class="p">();</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">new_parameter_pat</span><span class="p">,</span> <span class="n">new_parameter_id</span><span class="p">)</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.pat_ident</span><span class="p">(</span><span class="n">desugared_span</span><span class="p">,</span> <span class="n">ident</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">new_parameter</span> <span class="o">=</span> <span class="nn">hir</span><span class="p">::</span><span class="n">Param</span> <span class="p">{</span>
                <span class="n">hir_id</span><span class="p">:</span> <span class="n">parameter</span><span class="py">.hir_id</span><span class="p">,</span>
                <span class="n">pat</span><span class="p">:</span> <span class="n">new_parameter_pat</span><span class="p">,</span>
                <span class="n">ty_span</span><span class="p">:</span> <span class="n">this</span><span class="nf">.lower_span</span><span class="p">(</span><span class="n">parameter</span><span class="py">.ty_span</span><span class="p">),</span>
                <span class="n">span</span><span class="p">:</span> <span class="n">this</span><span class="nf">.lower_span</span><span class="p">(</span><span class="n">parameter</span><span class="py">.span</span><span class="p">),</span>
            <span class="p">};</span>

            <span class="k">if</span> <span class="n">is_simple_parameter</span> <span class="p">{</span>
                <span class="c1">// If this is the simple case, then we only insert one statement that is</span>
                <span class="c1">// `let &lt;pat&gt; = &lt;pat&gt;;`. We re-use the original argument's pattern so that</span>
                <span class="c1">// `HirId`s are densely assigned.</span>
                <span class="k">let</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.expr_ident</span><span class="p">(</span><span class="n">desugared_span</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">new_parameter_id</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.stmt_let_pat</span><span class="p">(</span>
                    <span class="n">stmt_attrs</span><span class="p">,</span>
                    <span class="n">desugared_span</span><span class="p">,</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span>
                    <span class="n">parameter</span><span class="py">.pat</span><span class="p">,</span>
                    <span class="nn">hir</span><span class="p">::</span><span class="nn">LocalSource</span><span class="p">::</span><span class="n">AsyncFn</span><span class="p">,</span>
                <span class="p">);</span>
                <span class="n">statements</span><span class="nf">.push</span><span class="p">(</span><span class="n">stmt</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// If this is not the simple case, then we construct two statements:</span>
                <span class="c1">//</span>
                <span class="c1">// ```</span>
                <span class="c1">// let __argN = __argN;</span>
                <span class="c1">// let &lt;pat&gt; = __argN;</span>
                <span class="c1">// ```</span>
                <span class="c1">//</span>
                <span class="c1">// The first statement moves the parameter into the closure and thus ensures</span>
                <span class="c1">// that the drop order is correct.</span>
                <span class="c1">//</span>
                <span class="c1">// The second statement creates the bindings that the user wrote.</span>

                <span class="c1">// Construct the `let mut __argN = __argN;` statement. It must be a mut binding</span>
                <span class="c1">// because the user may have specified a `ref mut` binding in the next</span>
                <span class="c1">// statement.</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">move_pat</span><span class="p">,</span> <span class="n">move_id</span><span class="p">)</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.pat_ident_binding_mode</span><span class="p">(</span>
                    <span class="n">desugared_span</span><span class="p">,</span>
                    <span class="n">ident</span><span class="p">,</span>
                    <span class="nn">hir</span><span class="p">::</span><span class="nn">BindingAnnotation</span><span class="p">::</span><span class="n">Mutable</span><span class="p">,</span>
                <span class="p">);</span>
                <span class="k">let</span> <span class="n">move_expr</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.expr_ident</span><span class="p">(</span><span class="n">desugared_span</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">new_parameter_id</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">move_stmt</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.stmt_let_pat</span><span class="p">(</span>
                    <span class="nb">None</span><span class="p">,</span>
                    <span class="n">desugared_span</span><span class="p">,</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">move_expr</span><span class="p">),</span>
                    <span class="n">move_pat</span><span class="p">,</span>
                    <span class="nn">hir</span><span class="p">::</span><span class="nn">LocalSource</span><span class="p">::</span><span class="n">AsyncFn</span><span class="p">,</span>
                <span class="p">);</span>

                <span class="c1">// Construct the `let &lt;pat&gt; = __argN;` statement. We re-use the original</span>
                <span class="c1">// parameter's pattern so that `HirId`s are densely assigned.</span>
                <span class="k">let</span> <span class="n">pattern_expr</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.expr_ident</span><span class="p">(</span><span class="n">desugared_span</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">move_id</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">pattern_stmt</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.stmt_let_pat</span><span class="p">(</span>
                    <span class="n">stmt_attrs</span><span class="p">,</span>
                    <span class="n">desugared_span</span><span class="p">,</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">pattern_expr</span><span class="p">),</span>
                    <span class="n">parameter</span><span class="py">.pat</span><span class="p">,</span>
                    <span class="nn">hir</span><span class="p">::</span><span class="nn">LocalSource</span><span class="p">::</span><span class="n">AsyncFn</span><span class="p">,</span>
                <span class="p">);</span>

                <span class="n">statements</span><span class="nf">.push</span><span class="p">(</span><span class="n">move_stmt</span><span class="p">);</span>
                <span class="n">statements</span><span class="nf">.push</span><span class="p">(</span><span class="n">pattern_stmt</span><span class="p">);</span>
            <span class="p">};</span>

            <span class="n">parameters</span><span class="nf">.push</span><span class="p">(</span><span class="n">new_parameter</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">body_span</span> <span class="o">=</span> <span class="n">body</span><span class="nf">.map_or</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="p">|</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span><span class="py">.span</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">async_expr</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.make_async_expr</span><span class="p">(</span>
            <span class="nn">CaptureBy</span><span class="p">::</span><span class="n">Value</span><span class="p">,</span>
            <span class="n">closure_id</span><span class="p">,</span>
            <span class="nb">None</span><span class="p">,</span>
            <span class="n">body_span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">AsyncGeneratorKind</span><span class="p">::</span><span class="nb">Fn</span><span class="p">,</span>
            <span class="p">|</span><span class="n">this</span><span class="p">|</span> <span class="p">{</span>
                <span class="c1">// Create a block from the user's function body:</span>
                <span class="k">let</span> <span class="n">user_body</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.lower_block_expr_opt</span><span class="p">(</span><span class="n">body_span</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>

                <span class="c1">// Transform into `drop-temps { &lt;user-body&gt; }`, an expression:</span>
                <span class="k">let</span> <span class="n">desugared_span</span> <span class="o">=</span>
                    <span class="n">this</span><span class="nf">.mark_span_with_reason</span><span class="p">(</span><span class="nn">DesugaringKind</span><span class="p">::</span><span class="n">Async</span><span class="p">,</span> <span class="n">user_body</span><span class="py">.span</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">user_body</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.expr_drop_temps</span><span class="p">(</span>
                    <span class="n">desugared_span</span><span class="p">,</span>
                    <span class="n">this</span><span class="py">.arena</span><span class="nf">.alloc</span><span class="p">(</span><span class="n">user_body</span><span class="p">),</span>
                    <span class="nn">AttrVec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
                <span class="p">);</span>

                <span class="c1">// As noted above, create the final block like</span>
                <span class="c1">//</span>
                <span class="c1">// ```</span>
                <span class="c1">// {</span>
                <span class="c1">//   let $param_pattern = $raw_param;</span>
                <span class="c1">//   ...</span>
                <span class="c1">//   drop-temps { &lt;user-body&gt; }</span>
                <span class="c1">// }</span>
                <span class="c1">// ```</span>
                <span class="k">let</span> <span class="n">body</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.block_all</span><span class="p">(</span>
                    <span class="n">desugared_span</span><span class="p">,</span>
                    <span class="n">this</span><span class="py">.arena</span><span class="nf">.alloc_from_iter</span><span class="p">(</span><span class="n">statements</span><span class="p">),</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">user_body</span><span class="p">),</span>
                <span class="p">);</span>

                <span class="n">this</span><span class="nf">.expr_block</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="nn">AttrVec</span><span class="p">::</span><span class="nf">new</span><span class="p">())</span>
            <span class="p">},</span>
        <span class="p">);</span>

        <span class="p">(</span>
            <span class="n">this</span><span class="py">.arena</span><span class="nf">.alloc_from_iter</span><span class="p">(</span><span class="n">parameters</span><span class="p">),</span>
            <span class="n">this</span><span class="nf">.expr</span><span class="p">(</span><span class="n">body_span</span><span class="p">,</span> <span class="n">async_expr</span><span class="p">,</span> <span class="nn">AttrVec</span><span class="p">::</span><span class="nf">new</span><span class="p">()),</span>
        <span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">async fn</code> 被替换为 generator 后，它的参数作为 captured variable 保存在 closure 中，后续称它为 upvars，在计算 <code class="language-plaintext highlighter-rouge">Layout</code> 是会使用到。</p>

<p><code class="language-plaintext highlighter-rouge">await</code> 则会被替换为 <code class="language-plaintext highlighter-rouge">poll()</code>(compiler/rustc_ast_lowering/src/expr.rs):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Desugar `&lt;expr&gt;.await` into:</span>
<span class="cd">/// ```ignore (pseudo-rust)</span>
<span class="cd">/// match ::std::future::IntoFuture::into_future(&lt;expr&gt;) {</span>
<span class="cd">///     mut __awaitee =&gt; loop {</span>
<span class="cd">///         match unsafe { ::std::future::Future::poll(</span>
<span class="cd">///             &lt;::std::pin::Pin&gt;::new_unchecked(&amp;mut __awaitee),</span>
<span class="cd">///             ::std::future::get_context(task_context),</span>
<span class="cd">///         ) } {</span>
<span class="cd">///             ::std::task::Poll::Ready(result) =&gt; break result,</span>
<span class="cd">///             ::std::task::Poll::Pending =&gt; {}</span>
<span class="cd">///         }</span>
<span class="cd">///         task_context = yield ();</span>
<span class="cd">///     }</span>
<span class="cd">/// }</span>
<span class="cd">/// ```</span>
<span class="k">fn</span> <span class="nf">lower_expr_await</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">dot_await_span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Expr</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">hir</span><span class="p">::</span><span class="n">ExprKind</span><span class="o">&lt;</span><span class="nv">'hir</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">full_span</span> <span class="o">=</span> <span class="n">expr</span><span class="py">.span</span><span class="nf">.to</span><span class="p">(</span><span class="n">dot_await_span</span><span class="p">);</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.generator_kind</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="nn">hir</span><span class="p">::</span><span class="nn">GeneratorKind</span><span class="p">::</span><span class="nf">Async</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{}</span>
        <span class="nf">Some</span><span class="p">(</span><span class="nn">hir</span><span class="p">::</span><span class="nn">GeneratorKind</span><span class="p">::</span><span class="n">Gen</span><span class="p">)</span> <span class="p">|</span> <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tcx.sess</span><span class="nf">.emit_err</span><span class="p">(</span><span class="n">AwaitOnlyInAsyncFnAndBlocks</span> <span class="p">{</span>
                <span class="n">dot_await_span</span><span class="p">,</span>
                <span class="n">item_span</span><span class="p">:</span> <span class="k">self</span><span class="py">.current_item</span><span class="p">,</span>
            <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">span</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.mark_span_with_reason</span><span class="p">(</span><span class="nn">DesugaringKind</span><span class="p">::</span><span class="n">Await</span><span class="p">,</span> <span class="n">dot_await_span</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">gen_future_span</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.mark_span_with_reason</span><span class="p">(</span>
        <span class="nn">DesugaringKind</span><span class="p">::</span><span class="n">Await</span><span class="p">,</span>
        <span class="n">full_span</span><span class="p">,</span>
        <span class="k">self</span><span class="py">.allow_gen_future</span><span class="nf">.clone</span><span class="p">(),</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="n">expr</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.lower_expr_mut</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">expr_hir_id</span> <span class="o">=</span> <span class="n">expr</span><span class="py">.hir_id</span><span class="p">;</span>

    <span class="c1">// Note that the name of this binding must not be changed to something else because</span>
    <span class="c1">// debuggers and debugger extensions expect it to be called `__awaitee`. They use</span>
    <span class="c1">// this name to identify what is being awaited by a suspended async functions.</span>
    <span class="k">let</span> <span class="n">awaitee_ident</span> <span class="o">=</span> <span class="nn">Ident</span><span class="p">::</span><span class="nf">with_dummy_span</span><span class="p">(</span><span class="nn">sym</span><span class="p">::</span><span class="n">__awaitee</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">awaitee_pat</span><span class="p">,</span> <span class="n">awaitee_pat_hid</span><span class="p">)</span> <span class="o">=</span>
        <span class="k">self</span><span class="nf">.pat_ident_binding_mode</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">awaitee_ident</span><span class="p">,</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">BindingAnnotation</span><span class="p">::</span><span class="n">Mutable</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">task_context_ident</span> <span class="o">=</span> <span class="nn">Ident</span><span class="p">::</span><span class="nf">with_dummy_span</span><span class="p">(</span><span class="nn">sym</span><span class="p">::</span><span class="n">_task_context</span><span class="p">);</span>

    <span class="c1">// unsafe {</span>
    <span class="c1">//     ::std::future::Future::poll(</span>
    <span class="c1">//         ::std::pin::Pin::new_unchecked(&amp;mut __awaitee),</span>
    <span class="c1">//         ::std::future::get_context(task_context),</span>
    <span class="c1">//     )</span>
    <span class="c1">// }</span>
    <span class="k">let</span> <span class="n">poll_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">awaitee</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_ident</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">awaitee_ident</span><span class="p">,</span> <span class="n">awaitee_pat_hid</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">ref_mut_awaitee</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_mut_addr_of</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">awaitee</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">task_context</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task_context_hid</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.task_context</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.expr_ident_mut</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">task_context_ident</span><span class="p">,</span> <span class="n">task_context_hid</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Use of `await` outside of an async context, we cannot use `task_context` here.</span>
            <span class="k">self</span><span class="nf">.expr_err</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="n">new_unchecked</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_call_lang_item_fn_mut</span><span class="p">(</span>
            <span class="n">span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">PinNewUnchecked</span><span class="p">,</span>
            <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">ref_mut_awaitee</span><span class="p">],</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="k">let</span> <span class="n">get_context</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_call_lang_item_fn_mut</span><span class="p">(</span>
            <span class="n">gen_future_span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">GetContext</span><span class="p">,</span>
            <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">task_context</span><span class="p">],</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="k">let</span> <span class="n">call</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_call_lang_item_fn</span><span class="p">(</span>
            <span class="n">span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">FuturePoll</span><span class="p">,</span>
            <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">new_unchecked</span><span class="p">,</span> <span class="n">get_context</span><span class="p">],</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="k">self</span><span class="py">.arena</span><span class="nf">.alloc</span><span class="p">(</span><span class="k">self</span><span class="nf">.expr_unsafe</span><span class="p">(</span><span class="n">call</span><span class="p">))</span>
    <span class="p">};</span>

    <span class="c1">// `::std::task::Poll::Ready(result) =&gt; break result`</span>
    <span class="k">let</span> <span class="n">loop_node_id</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.next_node_id</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">loop_hir_id</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.lower_node_id</span><span class="p">(</span><span class="n">loop_node_id</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">ready_arm</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x_ident</span> <span class="o">=</span> <span class="nn">Ident</span><span class="p">::</span><span class="nf">with_dummy_span</span><span class="p">(</span><span class="nn">sym</span><span class="p">::</span><span class="n">result</span><span class="p">);</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">x_pat</span><span class="p">,</span> <span class="n">x_pat_hid</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.pat_ident</span><span class="p">(</span><span class="n">gen_future_span</span><span class="p">,</span> <span class="n">x_ident</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">x_expr</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_ident</span><span class="p">(</span><span class="n">gen_future_span</span><span class="p">,</span> <span class="n">x_ident</span><span class="p">,</span> <span class="n">x_pat_hid</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">ready_field</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.single_pat_field</span><span class="p">(</span><span class="n">gen_future_span</span><span class="p">,</span> <span class="n">x_pat</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">ready_pat</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.pat_lang_item_variant</span><span class="p">(</span>
            <span class="n">span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">PollReady</span><span class="p">,</span>
            <span class="n">ready_field</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="k">let</span> <span class="n">break_x</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.with_loop_scope</span><span class="p">(</span><span class="n">loop_node_id</span><span class="p">,</span> <span class="k">move</span> <span class="p">|</span><span class="n">this</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">expr_break</span> <span class="o">=</span>
                <span class="nn">hir</span><span class="p">::</span><span class="nn">ExprKind</span><span class="p">::</span><span class="nf">Break</span><span class="p">(</span><span class="n">this</span><span class="nf">.lower_loop_destination</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x_expr</span><span class="p">));</span>
            <span class="n">this</span><span class="py">.arena</span><span class="nf">.alloc</span><span class="p">(</span><span class="n">this</span><span class="nf">.expr</span><span class="p">(</span><span class="n">gen_future_span</span><span class="p">,</span> <span class="n">expr_break</span><span class="p">,</span> <span class="nn">AttrVec</span><span class="p">::</span><span class="nf">new</span><span class="p">()))</span>
        <span class="p">});</span>
        <span class="k">self</span><span class="nf">.arm</span><span class="p">(</span><span class="n">ready_pat</span><span class="p">,</span> <span class="n">break_x</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="c1">// `::std::task::Poll::Pending =&gt; {}`</span>
    <span class="k">let</span> <span class="n">pending_arm</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pending_pat</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.pat_lang_item_variant</span><span class="p">(</span>
            <span class="n">span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">PollPending</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="p">[],</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="k">let</span> <span class="n">empty_block</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_block_empty</span><span class="p">(</span><span class="n">span</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.arm</span><span class="p">(</span><span class="n">pending_pat</span><span class="p">,</span> <span class="n">empty_block</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">inner_match_stmt</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">match_expr</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_match</span><span class="p">(</span>
            <span class="n">span</span><span class="p">,</span>
            <span class="n">poll_expr</span><span class="p">,</span>
            <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">ready_arm</span><span class="p">,</span> <span class="n">pending_arm</span><span class="p">],</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">MatchSource</span><span class="p">::</span><span class="n">AwaitDesugar</span><span class="p">,</span>
        <span class="p">);</span>
        <span class="k">self</span><span class="nf">.stmt_expr</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">match_expr</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="c1">// task_context = yield ();</span>
    <span class="k">let</span> <span class="n">yield_stmt</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">unit</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_unit</span><span class="p">(</span><span class="n">span</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">yield_expr</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr</span><span class="p">(</span>
            <span class="n">span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">ExprKind</span><span class="p">::</span><span class="nf">Yield</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">YieldSource</span><span class="p">::</span><span class="n">Await</span> <span class="p">{</span> <span class="n">expr</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">)</span> <span class="p">}),</span>
            <span class="nn">AttrVec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">);</span>
        <span class="k">let</span> <span class="n">yield_expr</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arena</span><span class="nf">.alloc</span><span class="p">(</span><span class="n">yield_expr</span><span class="p">);</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task_context_hid</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.task_context</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_ident</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">task_context_ident</span><span class="p">,</span> <span class="n">task_context_hid</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">assign</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr</span><span class="p">(</span>
                <span class="n">span</span><span class="p">,</span>
                <span class="nn">hir</span><span class="p">::</span><span class="nn">ExprKind</span><span class="p">::</span><span class="nf">Assign</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">yield_expr</span><span class="p">,</span> <span class="k">self</span><span class="nf">.lower_span</span><span class="p">(</span><span class="n">span</span><span class="p">)),</span>
                <span class="nn">AttrVec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="p">);</span>
            <span class="k">self</span><span class="nf">.stmt_expr</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Use of `await` outside of an async context. Return `yield_expr` so that we can</span>
            <span class="c1">// proceed with type checking.</span>
            <span class="k">self</span><span class="nf">.stmt</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">StmtKind</span><span class="p">::</span><span class="nf">Semi</span><span class="p">(</span><span class="n">yield_expr</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">loop_block</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.block_all</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">inner_match_stmt</span><span class="p">,</span> <span class="n">yield_stmt</span><span class="p">],</span> <span class="nb">None</span><span class="p">);</span>

    <span class="c1">// loop { .. }</span>
    <span class="k">let</span> <span class="n">loop_expr</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arena</span><span class="nf">.alloc</span><span class="p">(</span><span class="nn">hir</span><span class="p">::</span><span class="n">Expr</span> <span class="p">{</span>
        <span class="n">hir_id</span><span class="p">:</span> <span class="n">loop_hir_id</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">ExprKind</span><span class="p">::</span><span class="nf">Loop</span><span class="p">(</span>
            <span class="n">loop_block</span><span class="p">,</span>
            <span class="nb">None</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">LoopSource</span><span class="p">::</span><span class="n">Loop</span><span class="p">,</span>
            <span class="k">self</span><span class="nf">.lower_span</span><span class="p">(</span><span class="n">span</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="n">span</span><span class="p">:</span> <span class="k">self</span><span class="nf">.lower_span</span><span class="p">(</span><span class="n">span</span><span class="p">),</span>
    <span class="p">});</span>

    <span class="c1">// mut __awaitee =&gt; loop { ... }</span>
    <span class="k">let</span> <span class="n">awaitee_arm</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.arm</span><span class="p">(</span><span class="n">awaitee_pat</span><span class="p">,</span> <span class="n">loop_expr</span><span class="p">);</span>

    <span class="c1">// `match ::std::future::IntoFuture::into_future(&lt;expr&gt;) { ... }`</span>
    <span class="k">let</span> <span class="n">into_future_span</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.mark_span_with_reason</span><span class="p">(</span>
        <span class="nn">DesugaringKind</span><span class="p">::</span><span class="n">Await</span><span class="p">,</span>
        <span class="n">dot_await_span</span><span class="p">,</span>
        <span class="k">self</span><span class="py">.allow_into_future</span><span class="nf">.clone</span><span class="p">(),</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="n">into_future_expr</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_call_lang_item_fn</span><span class="p">(</span>
        <span class="n">into_future_span</span><span class="p">,</span>
        <span class="nn">hir</span><span class="p">::</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">IntoFutureIntoFuture</span><span class="p">,</span>
        <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">expr</span><span class="p">],</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">),</span>
    <span class="p">);</span>

    <span class="c1">// match &lt;into_future_expr&gt; {</span>
    <span class="c1">//     mut __awaitee =&gt; loop { .. }</span>
    <span class="c1">// }</span>
    <span class="nn">hir</span><span class="p">::</span><span class="nn">ExprKind</span><span class="p">::</span><span class="nf">Match</span><span class="p">(</span>
        <span class="n">into_future_expr</span><span class="p">,</span>
        <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">awaitee_arm</span><span class="p">],</span>
        <span class="nn">hir</span><span class="p">::</span><span class="nn">MatchSource</span><span class="p">::</span><span class="n">AwaitDesugar</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="generator-会被替换为-generatorstate">generator 会被替换为 GeneratorState</h2>

<p>此后 hir 会转换为 mir，generator 在 mir_transform 中被替换为 <code class="language-plaintext highlighter-rouge">GeneratorState</code>(compiler/rustc_mir_transform/src/generator.rs):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span> <span class="n">MirPass</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">StateTransform</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">run_pass</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">tcx</span><span class="p">:</span> <span class="n">TyCtxt</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Body</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">yield_ty</span><span class="p">)</span> <span class="o">=</span> <span class="n">body</span><span class="nf">.yield_ty</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// This only applies to generators</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="nd">assert!</span><span class="p">(</span><span class="n">body</span><span class="nf">.generator_drop</span><span class="p">()</span><span class="nf">.is_none</span><span class="p">());</span>
        <span class="nf">dump_mir</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="nb">None</span><span class="p">,</span> <span class="s">"generator_before"</span><span class="p">,</span> <span class="o">&amp;</span><span class="mi">0</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="p">|</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">|</span> <span class="nf">Ok</span><span class="p">(()));</span>

        <span class="c1">// The first argument is the generator type passed by value</span>
        <span class="k">let</span> <span class="n">gen_ty</span> <span class="o">=</span> <span class="n">body</span><span class="py">.local_decls.raw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="py">.ty</span><span class="p">;</span>

        <span class="c1">// Get the interior types and substs which typeck computed</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">upvars</span><span class="p">,</span> <span class="n">interior</span><span class="p">,</span> <span class="n">discr_ty</span><span class="p">,</span> <span class="n">movable</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="o">*</span><span class="n">gen_ty</span><span class="nf">.kind</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">ty</span><span class="p">::</span><span class="nf">Generator</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">substs</span><span class="p">,</span> <span class="n">movability</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">substs</span> <span class="o">=</span> <span class="n">substs</span><span class="nf">.as_generator</span><span class="p">();</span>
                <span class="p">(</span>
                    <span class="n">substs</span><span class="nf">.upvar_tys</span><span class="p">()</span><span class="nf">.collect</span><span class="p">(),</span>
                    <span class="n">substs</span><span class="nf">.witness</span><span class="p">(),</span>
                    <span class="n">substs</span><span class="nf">.discr_ty</span><span class="p">(</span><span class="n">tcx</span><span class="p">),</span>
                    <span class="n">movability</span> <span class="o">==</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">Movability</span><span class="p">::</span><span class="n">Movable</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">tcx</span><span class="py">.sess</span>
                    <span class="nf">.delay_span_bug</span><span class="p">(</span><span class="n">body</span><span class="py">.span</span><span class="p">,</span> <span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"unexpected generator type {}"</span><span class="p">,</span> <span class="n">gen_ty</span><span class="p">));</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="c1">// Compute GeneratorState&lt;yield_ty, return_ty&gt;</span>
        <span class="k">let</span> <span class="n">state_did</span> <span class="o">=</span> <span class="n">tcx</span><span class="nf">.require_lang_item</span><span class="p">(</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">GeneratorState</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">state_adt_ref</span> <span class="o">=</span> <span class="n">tcx</span><span class="nf">.adt_def</span><span class="p">(</span><span class="n">state_did</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">state_substs</span> <span class="o">=</span> <span class="n">tcx</span><span class="nf">.intern_substs</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="n">yield_ty</span><span class="nf">.into</span><span class="p">(),</span> <span class="n">body</span><span class="nf">.return_ty</span><span class="p">()</span><span class="nf">.into</span><span class="p">()]);</span>
        <span class="k">let</span> <span class="n">ret_ty</span> <span class="o">=</span> <span class="n">tcx</span><span class="nf">.mk_adt</span><span class="p">(</span><span class="n">state_adt_ref</span><span class="p">,</span> <span class="n">state_substs</span><span class="p">);</span>

        <span class="c1">// We rename RETURN_PLACE which has type mir.return_ty to new_ret_local</span>
        <span class="c1">// RETURN_PLACE then is a fresh unused local with type ret_ty.</span>
        <span class="k">let</span> <span class="n">new_ret_local</span> <span class="o">=</span> <span class="nf">replace_local</span><span class="p">(</span><span class="n">RETURN_PLACE</span><span class="p">,</span> <span class="n">ret_ty</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">tcx</span><span class="p">);</span>

        <span class="c1">// We also replace the resume argument and insert an `Assign`.</span>
        <span class="c1">// This is needed because the resume argument `_2` might be live across a `yield`, in which</span>
        <span class="c1">// case there is no `Assign` to it that the transform can turn into a store to the generator</span>
        <span class="c1">// state. After the yield the slot in the generator state would then be uninitialized.</span>
        <span class="k">let</span> <span class="n">resume_local</span> <span class="o">=</span> <span class="nn">Local</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">new_resume_local</span> <span class="o">=</span>
            <span class="nf">replace_local</span><span class="p">(</span><span class="n">resume_local</span><span class="p">,</span> <span class="n">body</span><span class="py">.local_decls</span><span class="p">[</span><span class="n">resume_local</span><span class="p">]</span><span class="py">.ty</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">tcx</span><span class="p">);</span>

        <span class="c1">// When first entering the generator, move the resume argument into its new local.</span>
        <span class="k">let</span> <span class="n">source_info</span> <span class="o">=</span> <span class="nn">SourceInfo</span><span class="p">::</span><span class="nf">outermost</span><span class="p">(</span><span class="n">body</span><span class="py">.span</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">stmts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">body</span><span class="nf">.basic_blocks_mut</span><span class="p">()[</span><span class="nn">BasicBlock</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span><span class="py">.statements</span><span class="p">;</span>
        <span class="n">stmts</span><span class="nf">.insert</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">Statement</span> <span class="p">{</span>
                <span class="n">source_info</span><span class="p">,</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">StatementKind</span><span class="p">::</span><span class="nf">Assign</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">((</span>
                    <span class="n">new_resume_local</span><span class="nf">.into</span><span class="p">(),</span>
                    <span class="nn">Rvalue</span><span class="p">::</span><span class="nf">Use</span><span class="p">(</span><span class="nn">Operand</span><span class="p">::</span><span class="nf">Move</span><span class="p">(</span><span class="n">resume_local</span><span class="nf">.into</span><span class="p">())),</span>
                <span class="p">))),</span>
            <span class="p">},</span>
        <span class="p">);</span>

        <span class="k">let</span> <span class="n">always_live_locals</span> <span class="o">=</span> <span class="nf">always_storage_live_locals</span><span class="p">(</span><span class="o">&amp;</span><span class="n">body</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">liveness_info</span> <span class="o">=</span>
            <span class="nf">locals_live_across_suspend_points</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">always_live_locals</span><span class="p">,</span> <span class="n">movable</span><span class="p">);</span>

        <span class="nf">sanitize_witness</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">interior</span><span class="p">,</span> <span class="n">upvars</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">liveness_info</span><span class="py">.saved_locals</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">tcx</span><span class="py">.sess.opts.unstable_opts.validate_mir</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">vis</span> <span class="o">=</span> <span class="n">EnsureGeneratorFieldAssignmentsNeverAlias</span> <span class="p">{</span>
                <span class="n">assigned_local</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
                <span class="n">saved_locals</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">liveness_info</span><span class="py">.saved_locals</span><span class="p">,</span>
                <span class="n">storage_conflicts</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">liveness_info</span><span class="py">.storage_conflicts</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="n">vis</span><span class="nf">.visit_body</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Extract locals which are live across suspension point into `layout`</span>
        <span class="c1">// `remap` gives a mapping from local indices onto generator struct indices</span>
        <span class="c1">// `storage_liveness` tells us which locals have live storage at suspension points</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">remap</span><span class="p">,</span> <span class="n">layout</span><span class="p">,</span> <span class="n">storage_liveness</span><span class="p">)</span> <span class="o">=</span> <span class="nf">compute_layout</span><span class="p">(</span><span class="n">liveness_info</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">can_return</span> <span class="o">=</span> <span class="nf">can_return</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">tcx</span><span class="nf">.param_env</span><span class="p">(</span><span class="n">body</span><span class="py">.source</span><span class="nf">.def_id</span><span class="p">()));</span>

        <span class="c1">// Run the transformation which converts Places from Local to generator struct</span>
        <span class="c1">// accesses for locals in `remap`.</span>
        <span class="c1">// It also rewrites `return x` and `yield y` as writing a new generator state and returning</span>
        <span class="c1">// GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively.</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">TransformVisitor</span> <span class="p">{</span>
            <span class="n">tcx</span><span class="p">,</span>
            <span class="n">state_adt_ref</span><span class="p">,</span>
            <span class="n">state_substs</span><span class="p">,</span>
            <span class="n">remap</span><span class="p">,</span>
            <span class="n">storage_liveness</span><span class="p">,</span>
            <span class="n">always_live_locals</span><span class="p">,</span>
            <span class="n">suspension_points</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">new_ret_local</span><span class="p">,</span>
            <span class="n">discr_ty</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="n">transform</span><span class="nf">.visit_body</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>

        <span class="c1">// Update our MIR struct to reflect the changes we've made</span>
        <span class="n">body</span><span class="py">.arg_count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// self, resume arg</span>
        <span class="n">body</span><span class="py">.spread_arg</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="n">body</span><span class="py">.generator</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.yield_ty</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
        <span class="n">body</span><span class="py">.generator</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.generator_layout</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>

        <span class="c1">// Insert `drop(generator_struct)` which is used to drop upvars for generators in</span>
        <span class="c1">// the unresumed state.</span>
        <span class="c1">// This is expanded to a drop ladder in `elaborate_generator_drops`.</span>
        <span class="k">let</span> <span class="n">drop_clean</span> <span class="o">=</span> <span class="nf">insert_clean_drop</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>

        <span class="nf">dump_mir</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="nb">None</span><span class="p">,</span> <span class="s">"generator_pre-elab"</span><span class="p">,</span> <span class="o">&amp;</span><span class="mi">0</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="p">|</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">|</span> <span class="nf">Ok</span><span class="p">(()));</span>

        <span class="c1">// Expand `drop(generator_struct)` to a drop ladder which destroys upvars.</span>
        <span class="c1">// If any upvars are moved out of, drop elaboration will handle upvar destruction.</span>
        <span class="c1">// However we need to also elaborate the code generated by `insert_clean_drop`.</span>
        <span class="nf">elaborate_generator_drops</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>

        <span class="nf">dump_mir</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="nb">None</span><span class="p">,</span> <span class="s">"generator_post-transform"</span><span class="p">,</span> <span class="o">&amp;</span><span class="mi">0</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="p">|</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">|</span> <span class="nf">Ok</span><span class="p">(()));</span>

        <span class="c1">// Create a copy of our MIR and use it to create the drop shim for the generator</span>
        <span class="k">let</span> <span class="n">drop_shim</span> <span class="o">=</span> <span class="nf">create_generator_drop_shim</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transform</span><span class="p">,</span> <span class="n">gen_ty</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">drop_clean</span><span class="p">);</span>

        <span class="n">body</span><span class="py">.generator</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.generator_drop</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">drop_shim</span><span class="p">);</span>

        <span class="c1">// Create the Generator::resume function</span>
        <span class="nf">create_generator_resume_function</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">can_return</span><span class="p">);</span>

        <span class="c1">// Run derefer to fix Derefs that are not in the first place</span>
        <span class="nf">deref_finder</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>第 85 行 <code class="language-plaintext highlighter-rouge">compute_layout</code> 计算出 <code class="language-plaintext highlighter-rouge">GeneratorLayout</code>，并在 111 行保存到 <code class="language-plaintext highlighter-rouge">body.generator</code> 中。这里的 <code class="language-plaintext highlighter-rouge">GeneratorLayout</code> 就是 <code class="language-plaintext highlighter-rouge">GeneratorState</code> 的内存空间，它分成两部分：<code class="language-plaintext highlighter-rouge">prefix</code> + <code class="language-plaintext highlighter-rouge">variants</code>。<code class="language-plaintext highlighter-rouge">prefix</code> 保存了会跨越 <code class="language-plaintext highlighter-rouge">suspend point</code> 的变量，<code class="language-plaintext highlighter-rouge">variants</code> 是不同的 state，其中保存了只会在当前 state 使用到的变量。</p>

<h2 id="generatorstate-的内存布局是如何计算的">GeneratorState 的内存布局是如何计算的？</h2>

<p>编译器在代码生成阶段会根据前面计算得到的 <code class="language-plaintext highlighter-rouge">GeneratorLayout</code> 算出最终的内存布局 <code class="language-plaintext highlighter-rouge">Layout</code>(compiler/rustc_middle/src/ty/layout.rs):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Compute the full generator layout.</span>
<span class="k">fn</span> <span class="nf">generator_layout</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">ty</span><span class="p">:</span> <span class="n">Ty</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">def_id</span><span class="p">:</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">def_id</span><span class="p">::</span><span class="n">DefId</span><span class="p">,</span>
    <span class="n">substs</span><span class="p">:</span> <span class="n">SubstsRef</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Layout</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">LayoutError</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">SavedLocalEligibility</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">tcx</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tcx</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">subst_field</span> <span class="o">=</span> <span class="p">|</span><span class="n">ty</span><span class="p">:</span> <span class="n">Ty</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">|</span> <span class="nf">EarlyBinder</span><span class="p">(</span><span class="n">ty</span><span class="p">)</span><span class="nf">.subst</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">substs</span><span class="p">);</span>

    <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcx</span><span class="nf">.generator_layout</span><span class="p">(</span><span class="n">def_id</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">LayoutError</span><span class="p">::</span><span class="nf">Unknown</span><span class="p">(</span><span class="n">ty</span><span class="p">));</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">ineligible_locals</span><span class="p">,</span> <span class="n">assignments</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.generator_saved_local_eligibility</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

    <span class="c1">// Build a prefix layout, including "promoting" all ineligible</span>
    <span class="c1">// locals as part of the prefix. We compute the layout of all of</span>
    <span class="c1">// these fields at once to get optimal packing.</span>
    <span class="k">let</span> <span class="n">tag_index</span> <span class="o">=</span> <span class="n">substs</span><span class="nf">.as_generator</span><span class="p">()</span><span class="nf">.prefix_tys</span><span class="p">()</span><span class="nf">.count</span><span class="p">();</span>

    <span class="c1">// `info.variant_fields` already accounts for the reserved variants, so no need to add them.</span>
    <span class="k">let</span> <span class="n">max_discr</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="py">.variant_fields</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u128</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">discr_int</span> <span class="o">=</span> <span class="nn">Integer</span><span class="p">::</span><span class="nf">fit_unsigned</span><span class="p">(</span><span class="n">max_discr</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">discr_int_ty</span> <span class="o">=</span> <span class="n">discr_int</span><span class="nf">.to_ty</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">tag</span> <span class="o">=</span> <span class="nn">Scalar</span><span class="p">::</span><span class="n">Initialized</span> <span class="p">{</span>
        <span class="n">value</span><span class="p">:</span> <span class="nn">Primitive</span><span class="p">::</span><span class="nf">Int</span><span class="p">(</span><span class="n">discr_int</span><span class="p">,</span> <span class="k">false</span><span class="p">),</span>
        <span class="n">valid_range</span><span class="p">:</span> <span class="n">WrappingRange</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">max_discr</span> <span class="p">},</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">tag_layout</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tcx</span><span class="nf">.intern_layout</span><span class="p">(</span><span class="nn">LayoutS</span><span class="p">::</span><span class="nf">scalar</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">tag_layout</span> <span class="o">=</span> <span class="n">TyAndLayout</span> <span class="p">{</span> <span class="n">ty</span><span class="p">:</span> <span class="n">discr_int_ty</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="n">tag_layout</span> <span class="p">};</span>

    <span class="k">let</span> <span class="n">promoted_layouts</span> <span class="o">=</span> <span class="n">ineligible_locals</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">local</span><span class="p">|</span> <span class="nf">subst_field</span><span class="p">(</span><span class="n">info</span><span class="py">.field_tys</span><span class="p">[</span><span class="n">local</span><span class="p">]))</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="n">tcx</span><span class="nf">.mk_maybe_uninit</span><span class="p">(</span><span class="n">ty</span><span class="p">))</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="k">self</span><span class="nf">.layout_of</span><span class="p">(</span><span class="n">ty</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">prefix_layouts</span> <span class="o">=</span> <span class="n">substs</span>
        <span class="nf">.as_generator</span><span class="p">()</span>
        <span class="nf">.prefix_tys</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="k">self</span><span class="nf">.layout_of</span><span class="p">(</span><span class="n">ty</span><span class="p">))</span>
        <span class="nf">.chain</span><span class="p">(</span><span class="nn">iter</span><span class="p">::</span><span class="nf">once</span><span class="p">(</span><span class="nf">Ok</span><span class="p">(</span><span class="n">tag_layout</span><span class="p">)))</span>
        <span class="nf">.chain</span><span class="p">(</span><span class="n">promoted_layouts</span><span class="p">)</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">prefix</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.univariant_uninterned</span><span class="p">(</span>
        <span class="n">ty</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">prefix_layouts</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="nn">ReprOptions</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
        <span class="nn">StructKind</span><span class="p">::</span><span class="n">AlwaysSized</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">prefix_size</span><span class="p">,</span> <span class="n">prefix_align</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">prefix</span><span class="py">.size</span><span class="p">,</span> <span class="n">prefix</span><span class="py">.align</span><span class="p">);</span>

    <span class="c1">// Split the prefix layout into the "outer" fields (upvars and</span>
    <span class="c1">// discriminant) and the "promoted" fields. Promoted fields will</span>
    <span class="c1">// get included in each variant that requested them in</span>
    <span class="c1">// GeneratorLayout.</span>
    <span class="nd">debug!</span><span class="p">(</span><span class="s">"prefix = {:#?}"</span><span class="p">,</span> <span class="n">prefix</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">outer_fields</span><span class="p">,</span> <span class="n">promoted_offsets</span><span class="p">,</span> <span class="n">promoted_memory_index</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">prefix</span><span class="py">.fields</span> <span class="p">{</span>
        <span class="nn">FieldsShape</span><span class="p">::</span><span class="n">Arbitrary</span> <span class="p">{</span> <span class="k">mut</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">memory_index</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">inverse_memory_index</span> <span class="o">=</span> <span class="nf">invert_mapping</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memory_index</span><span class="p">);</span>

            <span class="c1">// "a" (`0..b_start`) and "b" (`b_start..`) correspond to</span>
            <span class="c1">// "outer" and "promoted" fields respectively.</span>
            <span class="k">let</span> <span class="n">b_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">tag_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">offsets_b</span> <span class="o">=</span> <span class="n">offsets</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">b_start</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">offsets_a</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">;</span>

            <span class="c1">// Disentangle the "a" and "b" components of `inverse_memory_index`</span>
            <span class="c1">// by preserving the order but keeping only one disjoint "half" each.</span>
            <span class="c1">// FIXME(eddyb) build a better abstraction for permutations, if possible.</span>
            <span class="k">let</span> <span class="n">inverse_memory_index_b</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span>
                <span class="n">inverse_memory_index</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.filter_map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span><span class="nf">.checked_sub</span><span class="p">(</span><span class="n">b_start</span><span class="p">))</span><span class="nf">.collect</span><span class="p">();</span>
            <span class="n">inverse_memory_index</span><span class="nf">.retain</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b_start</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">inverse_memory_index_a</span> <span class="o">=</span> <span class="n">inverse_memory_index</span><span class="p">;</span>

            <span class="c1">// Since `inverse_memory_index_{a,b}` each only refer to their</span>
            <span class="c1">// respective fields, they can be safely inverted</span>
            <span class="k">let</span> <span class="n">memory_index_a</span> <span class="o">=</span> <span class="nf">invert_mapping</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inverse_memory_index_a</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">memory_index_b</span> <span class="o">=</span> <span class="nf">invert_mapping</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inverse_memory_index_b</span><span class="p">);</span>

            <span class="k">let</span> <span class="n">outer_fields</span> <span class="o">=</span>
                <span class="nn">FieldsShape</span><span class="p">::</span><span class="n">Arbitrary</span> <span class="p">{</span> <span class="n">offsets</span><span class="p">:</span> <span class="n">offsets_a</span><span class="p">,</span> <span class="n">memory_index</span><span class="p">:</span> <span class="n">memory_index_a</span> <span class="p">};</span>
            <span class="p">(</span><span class="n">outer_fields</span><span class="p">,</span> <span class="n">offsets_b</span><span class="p">,</span> <span class="n">memory_index_b</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">bug!</span><span class="p">(),</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">size</span> <span class="o">=</span> <span class="n">prefix</span><span class="py">.size</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">align</span> <span class="o">=</span> <span class="n">prefix</span><span class="py">.align</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">variants</span> <span class="o">=</span> <span class="n">info</span>
        <span class="py">.variant_fields</span>
        <span class="nf">.iter_enumerated</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">index</span><span class="p">,</span> <span class="n">variant_fields</span><span class="p">)|</span> <span class="p">{</span>
            <span class="c1">// Only include overlap-eligible fields when we compute our variant layout.</span>
            <span class="k">let</span> <span class="n">variant_only_tys</span> <span class="o">=</span> <span class="n">variant_fields</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="n">local</span><span class="p">|</span> <span class="k">match</span> <span class="n">assignments</span><span class="p">[</span><span class="o">**</span><span class="n">local</span><span class="p">]</span> <span class="p">{</span>
                    <span class="n">Unassigned</span> <span class="k">=&gt;</span> <span class="nd">bug!</span><span class="p">(),</span>
                    <span class="nf">Assigned</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">index</span> <span class="k">=&gt;</span> <span class="k">true</span><span class="p">,</span>
                    <span class="nf">Assigned</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">bug!</span><span class="p">(</span><span class="s">"assignment does not match variant"</span><span class="p">),</span>
                    <span class="nf">Ineligible</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">false</span><span class="p">,</span>
                <span class="p">})</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">local</span><span class="p">|</span> <span class="nf">subst_field</span><span class="p">(</span><span class="n">info</span><span class="py">.field_tys</span><span class="p">[</span><span class="o">*</span><span class="n">local</span><span class="p">]));</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">variant</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.univariant_uninterned</span><span class="p">(</span>
                <span class="n">ty</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">variant_only_tys</span>
                    <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="k">self</span><span class="nf">.layout_of</span><span class="p">(</span><span class="n">ty</span><span class="p">))</span>
                    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="nn">ReprOptions</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
                <span class="nn">StructKind</span><span class="p">::</span><span class="nf">Prefixed</span><span class="p">(</span><span class="n">prefix_size</span><span class="p">,</span> <span class="n">prefix_align</span><span class="py">.abi</span><span class="p">),</span>
            <span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="n">variant</span><span class="py">.variants</span> <span class="o">=</span> <span class="nn">Variants</span><span class="p">::</span><span class="n">Single</span> <span class="p">{</span> <span class="n">index</span> <span class="p">};</span>

            <span class="k">let</span> <span class="nn">FieldsShape</span><span class="p">::</span><span class="n">Arbitrary</span> <span class="p">{</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">memory_index</span> <span class="p">}</span> <span class="o">=</span> <span class="n">variant</span><span class="py">.fields</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">bug!</span><span class="p">();</span>
            <span class="p">};</span>

            <span class="c1">// Now, stitch the promoted and variant-only fields back together in</span>
            <span class="c1">// the order they are mentioned by our GeneratorLayout.</span>
            <span class="c1">// Because we only use some subset (that can differ between variants)</span>
            <span class="c1">// of the promoted fields, we can't just pick those elements of the</span>
            <span class="c1">// `promoted_memory_index` (as we'd end up with gaps).</span>
            <span class="c1">// So instead, we build an "inverse memory_index", as if all of the</span>
            <span class="c1">// promoted fields were being used, but leave the elements not in the</span>
            <span class="c1">// subset as `INVALID_FIELD_IDX`, which we can filter out later to</span>
            <span class="c1">// obtain a valid (bijective) mapping.</span>
            <span class="k">const</span> <span class="n">INVALID_FIELD_IDX</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="o">!</span><span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">combined_inverse_memory_index</span> <span class="o">=</span>
                <span class="nd">vec!</span><span class="p">[</span><span class="n">INVALID_FIELD_IDX</span><span class="p">;</span> <span class="n">promoted_memory_index</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="n">memory_index</span><span class="nf">.len</span><span class="p">()];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">offsets_and_memory_index</span> <span class="o">=</span> <span class="nn">iter</span><span class="p">::</span><span class="nf">zip</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">memory_index</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">combined_offsets</span> <span class="o">=</span> <span class="n">variant_fields</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.enumerate</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">local</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">memory_index</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">assignments</span><span class="p">[</span><span class="o">*</span><span class="n">local</span><span class="p">]</span> <span class="p">{</span>
                        <span class="n">Unassigned</span> <span class="k">=&gt;</span> <span class="nd">bug!</span><span class="p">(),</span>
                        <span class="nf">Assigned</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">memory_index</span><span class="p">)</span> <span class="o">=</span>
                                <span class="n">offsets_and_memory_index</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                            <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">promoted_memory_index</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span> <span class="o">+</span> <span class="n">memory_index</span><span class="p">)</span>
                        <span class="p">}</span>
                        <span class="nf">Ineligible</span><span class="p">(</span><span class="n">field_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">field_idx</span> <span class="o">=</span> <span class="n">field_idx</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
                            <span class="p">(</span><span class="n">promoted_offsets</span><span class="p">[</span><span class="n">field_idx</span><span class="p">],</span> <span class="n">promoted_memory_index</span><span class="p">[</span><span class="n">field_idx</span><span class="p">])</span>
                        <span class="p">}</span>
                    <span class="p">};</span>
                    <span class="n">combined_inverse_memory_index</span><span class="p">[</span><span class="n">memory_index</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
                    <span class="n">offset</span>
                <span class="p">})</span>
                <span class="nf">.collect</span><span class="p">();</span>

            <span class="c1">// Remove the unused slots and invert the mapping to obtain the</span>
            <span class="c1">// combined `memory_index` (also see previous comment).</span>
            <span class="n">combined_inverse_memory_index</span><span class="nf">.retain</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">INVALID_FIELD_IDX</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">combined_memory_index</span> <span class="o">=</span> <span class="nf">invert_mapping</span><span class="p">(</span><span class="o">&amp;</span><span class="n">combined_inverse_memory_index</span><span class="p">);</span>

            <span class="n">variant</span><span class="py">.fields</span> <span class="o">=</span> <span class="nn">FieldsShape</span><span class="p">::</span><span class="n">Arbitrary</span> <span class="p">{</span>
                <span class="n">offsets</span><span class="p">:</span> <span class="n">combined_offsets</span><span class="p">,</span>
                <span class="n">memory_index</span><span class="p">:</span> <span class="n">combined_memory_index</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="nf">.max</span><span class="p">(</span><span class="n">variant</span><span class="py">.size</span><span class="p">);</span>
            <span class="n">align</span> <span class="o">=</span> <span class="n">align</span><span class="nf">.max</span><span class="p">(</span><span class="n">variant</span><span class="py">.align</span><span class="p">);</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">tcx</span><span class="nf">.intern_layout</span><span class="p">(</span><span class="n">variant</span><span class="p">))</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">IndexVec</span><span class="o">&lt;</span><span class="n">VariantIdx</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="nf">.align_to</span><span class="p">(</span><span class="n">align</span><span class="py">.abi</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">abi</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">prefix</span><span class="py">.abi</span><span class="nf">.is_uninhabited</span><span class="p">()</span> <span class="p">||</span> <span class="n">variants</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">v</span><span class="nf">.abi</span><span class="p">()</span><span class="nf">.is_uninhabited</span><span class="p">())</span> <span class="p">{</span>
            <span class="nn">Abi</span><span class="p">::</span><span class="n">Uninhabited</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">Abi</span><span class="p">::</span><span class="n">Aggregate</span> <span class="p">{</span> <span class="n">sized</span><span class="p">:</span> <span class="k">true</span> <span class="p">}</span>
        <span class="p">};</span>

    <span class="k">let</span> <span class="n">layout</span> <span class="o">=</span> <span class="n">tcx</span><span class="nf">.intern_layout</span><span class="p">(</span><span class="n">LayoutS</span> <span class="p">{</span>
        <span class="n">variants</span><span class="p">:</span> <span class="nn">Variants</span><span class="p">::</span><span class="n">Multiple</span> <span class="p">{</span>
            <span class="n">tag</span><span class="p">,</span>
            <span class="n">tag_encoding</span><span class="p">:</span> <span class="nn">TagEncoding</span><span class="p">::</span><span class="n">Direct</span><span class="p">,</span>
            <span class="n">tag_field</span><span class="p">:</span> <span class="n">tag_index</span><span class="p">,</span>
            <span class="n">variants</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">outer_fields</span><span class="p">,</span>
        <span class="n">abi</span><span class="p">,</span>
        <span class="n">largest_niche</span><span class="p">:</span> <span class="n">prefix</span><span class="py">.largest_niche</span><span class="p">,</span>
        <span class="n">size</span><span class="p">,</span>
        <span class="n">align</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="nd">debug!</span><span class="p">(</span><span class="s">"generator layout ({:?}): {:#?}"</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">layout</span><span class="p">);</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">LayoutS</code> 的定义为：</p>

<pre><code class="language-Rust">#[derive(PartialEq, Eq, Hash, HashStable_Generic)]
pub struct LayoutS&lt;'a&gt; {
    /// Says where the fields are located within the layout.
    pub fields: FieldsShape,

    /// Encodes information about multi-variant layouts.
    /// Even with `Multiple` variants, a layout still has its own fields! Those are then
    /// shared between all variants. One of them will be the discriminant,
    /// but e.g. generators can have more.
    ///
    /// To access all fields of this layout, both `fields` and the fields of the active variant
    /// must be taken into account.
    pub variants: Variants&lt;'a&gt;,

    /// The `abi` defines how this data is passed between functions, and it defines
    /// value restrictions via `valid_range`.
    ///
    /// Note that this is entirely orthogonal to the recursive structure defined by
    /// `variants` and `fields`; for example, `ManuallyDrop&lt;Result&lt;isize, isize&gt;&gt;` has
    /// `Abi::ScalarPair`! So, even with non-`Aggregate` `abi`, `fields` and `variants`
    /// have to be taken into account to find all fields of this layout.
    pub abi: Abi,

    /// The leaf scalar with the largest number of invalid values
    /// (i.e. outside of its `valid_range`), if it exists.
    pub largest_niche: Option&lt;Niche&gt;,

    pub align: AbiAndPrefAlign,
    pub size: Size,
}
</code></pre>

<p>根据定义，<code class="language-plaintext highlighter-rouge">fields</code> + <code class="language-plaintext highlighter-rouge">variants</code> 组成了 <code class="language-plaintext highlighter-rouge">GeneratorState</code> 的内存布局：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>To access all fields of this layout, both `fields` and the fields of the active variant must be taken into account.
</code></pre></div></div>

<p>在 <code class="language-plaintext highlighter-rouge">generator_layout</code> 函数中，<code class="language-plaintext highlighter-rouge">fields</code> 是 <code class="language-plaintext highlighter-rouge">outer_fields</code>，variants 是 <code class="language-plaintext highlighter-rouge">Variant::Multiple</code> 的实例，其中保存了 <code class="language-plaintext highlighter-rouge">variants</code> 和一个 <code class="language-plaintext highlighter-rouge">tag_field</code>。<code class="language-plaintext highlighter-rouge">outer_fields</code> 和 <code class="language-plaintext highlighter-rouge">variants</code> 均由 <code class="language-plaintext highlighter-rouge">prefix</code> 计算得到：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Split the prefix layout into the "outer" fields (upvars and</span>
<span class="c1">// discriminant) and the "promoted" fields. Promoted fields will</span>
<span class="c1">// get included in each variant that requested them in</span>
<span class="c1">// GeneratorLayout</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">prefix</code> 的计算方式为：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">tag_layout</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tcx</span><span class="nf">.intern_layout</span><span class="p">(</span><span class="nn">LayoutS</span><span class="p">::</span><span class="nf">scalar</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">));</span>
<span class="k">let</span> <span class="n">tag_layout</span> <span class="o">=</span> <span class="n">TyAndLayout</span> <span class="p">{</span> <span class="n">ty</span><span class="p">:</span> <span class="n">discr_int_ty</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="n">tag_layout</span> <span class="p">};</span>

<span class="k">let</span> <span class="n">promoted_layouts</span> <span class="o">=</span> <span class="n">ineligible_locals</span>
    <span class="nf">.iter</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|</span><span class="n">local</span><span class="p">|</span> <span class="nf">subst_field</span><span class="p">(</span><span class="n">info</span><span class="py">.field_tys</span><span class="p">[</span><span class="n">local</span><span class="p">]))</span>
    <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="n">tcx</span><span class="nf">.mk_maybe_uninit</span><span class="p">(</span><span class="n">ty</span><span class="p">))</span>
    <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="k">self</span><span class="nf">.layout_of</span><span class="p">(</span><span class="n">ty</span><span class="p">));</span>
<span class="k">let</span> <span class="n">prefix_layouts</span> <span class="o">=</span> <span class="n">substs</span>
    <span class="nf">.as_generator</span><span class="p">()</span>
    <span class="nf">.prefix_tys</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="k">self</span><span class="nf">.layout_of</span><span class="p">(</span><span class="n">ty</span><span class="p">))</span>
    <span class="nf">.chain</span><span class="p">(</span><span class="nn">iter</span><span class="p">::</span><span class="nf">once</span><span class="p">(</span><span class="nf">Ok</span><span class="p">(</span><span class="n">tag_layout</span><span class="p">)))</span>
    <span class="nf">.chain</span><span class="p">(</span><span class="n">promoted_layouts</span><span class="p">)</span>
    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="k">let</span> <span class="n">prefix</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.univariant_uninterned</span><span class="p">(</span>
    <span class="n">ty</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">prefix_layouts</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="nn">ReprOptions</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
    <span class="nn">StructKind</span><span class="p">::</span><span class="n">AlwaysSized</span><span class="p">,</span>
<span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<p>其中 <code class="language-plaintext highlighter-rouge">prefix_tys()</code> 返回的就是前面提到的 <code class="language-plaintext highlighter-rouge">upvars</code>：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// This is the types of the fields of a generator which are not stored in a</span>
<span class="cd">/// variant.</span>
<span class="nd">#[inline]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">prefix_tys</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">Ty</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.upvar_tys</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因此，一个 <code class="language-plaintext highlighter-rouge">GeneratorState</code> 的 <code class="language-plaintext highlighter-rouge">Layout</code> 中会包含一个 <code class="language-plaintext highlighter-rouge">tag</code>，<code class="language-plaintext highlighter-rouge">upvars</code>，以及由不同 state 组成的 <code class="language-plaintext highlighter-rouge">variants</code>。回到 <code class="language-plaintext highlighter-rouge">root_heartbeat</code> 的例子，<code class="language-plaintext highlighter-rouge">streaming()</code> 中，除了 <code class="language-plaintext highlighter-rouge">request</code> 和 <code class="language-plaintext highlighter-rouge">response</code> 外，还会保存下参数中的 <code class="language-plaintext highlighter-rouge">request: Request&lt;S&gt;</code>，<code class="language-plaintext highlighter-rouge">path</code> 和 <code class="language-plaintext highlighter-rouge">codec</code>。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">codec</code>: <code class="language-plaintext highlighter-rouge">tonic::codec::ProstCodec&lt;engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt;</code> size 0 bytes</li>
  <li><code class="language-plaintext highlighter-rouge">request</code>: <code class="language-plaintext highlighter-rouge">tonic::Request&lt;futures::stream::Once&lt;futures::future::Ready&lt;engula_api::server::v1::HeartbeatRequest&gt;&gt;&gt;</code> size 144 bytes</li>
  <li><code class="language-plaintext highlighter-rouge">path</code>: <code class="language-plaintext highlighter-rouge">http::uri::path::PathAndQuery</code> size 40 bytes</li>
  <li>tag: u8</li>
</ul>

<p>最终的大小为：self(8 bytes) + request(144 bytes) + path(40 bytes) + uri(88 bytes) + request(240 bytes, http request) + response(32 bytes) + tag(1 byte, aligned to 8) = 560</p>

<blockquote>
  <p>此处 <code class="language-plaintext highlighter-rouge">uri</code> 是前面计算漏掉的变量。</p>
</blockquote>

<p>由于 <code class="language-plaintext highlighter-rouge">async fn</code> 的参数作为 captured variable，会放置在 <code class="language-plaintext highlighter-rouge">outer_fields</code> 中。如果一个非常大的参数层层传递到内部的某个 <code class="language-plaintext highlighter-rouge">async fn</code>，会被一层层放大，最终导致 <code class="language-plaintext highlighter-rouge">Future</code> 大小呈现指数增长。 19 年有一个 issue 已经指出了这个问题<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>。</p>

<h1 id="解决方案">解决方案？</h1>

<p>对于普通开发者，临时的解决办法有两点：</p>

<ol>
  <li>避免 pass by value，可以使用 <code class="language-plaintext highlighter-rouge">Arc</code> 或者 reference</li>
  <li>减少使用 <code class="language-plaintext highlighter-rouge">async fn</code>。对于 tail calling，可以直接使用 <code class="language-plaintext highlighter-rouge">impl Future</code>，避免无意义的 <code class="language-plaintext highlighter-rouge">await</code>。</li>
</ol>

<blockquote>
  <p>cpp 提供了左值引用，这类层层传递的变量可以被自然地优化；而 rust 依靠编译器优化，就得依靠生成的代码能满足优化的前置条件。</p>
</blockquote>

<p>当然，community 也有人提供了改进方案<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>。该方案可以简述如下：即将 upvars 保存到 <code class="language-plaintext highlighter-rouge">GeneratorState</code> 的 <code class="language-plaintext highlighter-rouge">unresumed</code> state 中 （每个 <code class="language-plaintext highlighter-rouge">GenerateState</code> 至少有三种 state: <code class="language-plaintext highlighter-rouge">unresumed</code>, <code class="language-plaintext highlighter-rouge">finished</code>, <code class="language-plaintext highlighter-rouge">paniced</code>, 以及用户定义的 <code class="language-plaintext highlighter-rouge">suspent_x</code>)。</p>

<p>不过因为 rust 编译器架构改成了 demand-deriven compilation，该方案碰到了 query 循环依赖的问题，
需要等待其他人先将修复 dest prop <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>。</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>https://github.com/rust-lang/rust/issues/62958 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>https://github.com/rust-lang/rust/pull/89213 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>https://github.com/rust-lang/rust/pull/96451 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/2022/09/05/rust-async-fn-genrated-futures-is-too-large.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">W41ter&#39;s Bistro</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">W41ter&#39;s Bistro</li><li><a class="u-email" href="mailto:w41ter.l@gmail.com">w41ter.l@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/w41ter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">w41ter</span></a></li><li><a href="https://www.twitter.com/WalterM56697798"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WalterM56697798</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Focus on distributed storage system, compiler.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
