<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Simple and Direction SSA Constriruction Algorithm | W41ter’s Bistro</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Simple and Direction SSA Constriruction Algorithm" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="前面讲到了传统的 SSA 构造方式，直接从线性 IR 构造 SSA。而本文将介绍另外的方法允许从 AST、Bytecode 甚至源代码直接构造 SSA 形式。" />
<meta property="og:description" content="前面讲到了传统的 SSA 构造方式，直接从线性 IR 构造 SSA。而本文将介绍另外的方法允许从 AST、Bytecode 甚至源代码直接构造 SSA 形式。" />
<link rel="canonical" href="/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/2016/08/18/Simple-and-Direction-SSA-Constriruction-Algorithm.html" />
<meta property="og:url" content="/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/2016/08/18/Simple-and-Direction-SSA-Constriruction-Algorithm.html" />
<meta property="og:site_name" content="W41ter’s Bistro" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-08-18T16:04:58+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Simple and Direction SSA Constriruction Algorithm" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-08-18T16:04:58+08:00","datePublished":"2016-08-18T16:04:58+08:00","description":"前面讲到了传统的 SSA 构造方式，直接从线性 IR 构造 SSA。而本文将介绍另外的方法允许从 AST、Bytecode 甚至源代码直接构造 SSA 形式。","headline":"Simple and Direction SSA Constriruction Algorithm","mainEntityOfPage":{"@type":"WebPage","@id":"/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/2016/08/18/Simple-and-Direction-SSA-Constriruction-Algorithm.html"},"url":"/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/2016/08/18/Simple-and-Direction-SSA-Constriruction-Algorithm.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="W41ter's Bistro" /><!-- for mathjax support -->
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">W41ter&#39;s Bistro</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Simple and Direction SSA Constriruction Algorithm</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-08-18T16:04:58+08:00" itemprop="datePublished">Aug 18, 2016
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>前面讲到了传统的 SSA 构造方式，直接从线性 IR 构造 SSA。而本文将介绍另外的方法允许从 AST、Bytecode 甚至源代码直接构造 SSA 形式。</p>

<!-- more -->

<h2 id="llvm-中的方法">LLVM 中的方法</h2>

<p>LLVM ir 为 SSA 形式，如果用户手工翻译 AST，那么只有在翻译的时候直接生成 SSA 形式中间代码。不过 LLVM 给用户留下了一个后门，可以将变量全部表达成为 Memory 形式，通过指针操作。然后通过 Mem2Reg pass 转换成 SSA 形式。</p>

<p>这里不介绍翻译时候的方式，仅仅介绍一下 Mem2Reg pass。下面的代码抄自 LLVM 中：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 遍历指令序列找到 alloca
for (Instruction instr : instructions)
{
    if (isa&lt;Alloca&gt;(instr))
        allocas.push_back(instr);
}

// 一个一个的提升 alloca 指令
for (Alloca alloca : allocas)
{
    // 判断是否可以提升
    if (!alloca.isAllocaPromoteable())
        continue;
    
    // 跳过无使用者的alloca指令
    if (alloca.user_begin() == alloca.user_end())
        continue;
        
    // 收集alloca指令的使用，定义信息
    info.analyzeAlloca(alloca);
         
    // 下面的函数，对只有一次定义（即只有一条 store 指令）的 alloca 进行优化
    // 把所有的 load 指令全部用定义时保存的 value 替换
    if (info.definingBlocks.size() == 1)
        rewriteSingleStoreAlloca(alloca, info);
    
    // 下面的代码仅仅对只在一个基本块中使用和定义的alloca指令进行优化
    if (info.onlyUsedOneBlock)
        promoteSingleBlockAlloca(alloca, info);

    // 插入无参数的Phi函数，使用标准的基于支配边界的算法，其中使用DJ图的方式进行了优化
    determineInsertionPoint(alloca, allocaNum, info);

    // 使用 IDF 和标准 ssa 构造算法提升 alloca ，决定那些需要插入 Phi 函数
    DefBlocks.insert(Info.DefiningBlocks.begin(), Info.DefiningBlocks.end());
    ComputeLiveInBlocks(AI, Info, DefBlocks, LiveInBlocks);
    IDF.setLiveInBlocks(LiveInBlocks);
    IDF.setDefiningBlocks(DefBlocks);
    IDF.calculate(PHIBlocks);

    // 执行 SSA 重命名算法，并插入 Phi 节点
    RenamePassWorkList.emplace_back(&amp;F.front(), nullptr, std::move(Values));
    do {
        // RenamePass may add new worklist entries.
        RenamePass(RPD.BB, RPD.Pred, RPD.Values, RenamePassWorkList);
    } while (!RenamePassWorkList.empty());

    // 移除 allocas
    for (unsigned i = 0, e = Allocas.size(); i != e; ++i) 
    {
        Instruction *A = Allocas[i];
        A-&gt;replaceAllUsesWith(UndefValue::get(A-&gt;getType()));
        A-&gt;eraseFromParent();
    }

  // 最后执行一趟消除平凡Phi函数的操作，
    while (eliminatedAPHI)
    {
        // if the phi merges one value and/or undefs, get the value
        if ((V = simplifyInstruction(phi, DT)) != null)
        {
            phi.replaceAllUsesWith(V);
            phi.eraseFromBasicBlock();
            newPhiNodes.remove(entity);
            eliminatedAPHI = true;
            continue;
        }
    }
}
</code></pre></div></div>

<h2 id="直接构造">直接构造</h2>

<p>这种方法来源于论文：</p>

<blockquote>
  <p>Simple and Eﬃcient Construction of Static Single Assignment Form
Matthias Braun1, Sebastian Buchwald1, Sebastian Hack2, Roland Leißa2, Christoph Mallon2, and Andreas Zwinkau1</p>
</blockquote>

<p>下面介绍该构造方法。</p>

<h3 id="local-value-numbering">Local Value Numbering</h3>

<p>这部分操作以基本块为单位，所以生成的 IR 必须为 CFG 形式。CFG 形式能够非常容易的从源代码构造，这里略过。</p>

<p>该方法按照程序执行的顺序处理所有的表达式，并且在变量和其定义表达式之间建立映射。也就是说当遇到对变量赋值时，把赋值符号右边的表达式最为当前变量的定义。当一个变量被访问的时候，我们就查找其定义。上述的过程就叫做 <strong>local value numbering</strong>。</p>

<p>如果一个基本块中完成了 <strong>local value numbering</strong>，这个基本块就被称为 <strong>filled</strong>。 只有一个基本块完成了 <strong>local value numbering</strong> 后，才能够添加后继基本块。这个属性会在处理 <strong>incomplete CFGs</strong> 的时候使用。</p>

<p>Algorithm 1: Implementation of local value numbering</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>writeVariable(variable, block, value): 
    currentDef[variable][block] ← value 
    
readVariable(variable, block): 
    if currentDef[variable] contains block: 
        # local value numbering
        return currentDef[variable][block] 
    # global value numbering 
    return readVariableRecursive(variable, block) 
</code></pre></div></div>

<h3 id="global-value-numbering">Global Value Numbering</h3>

<p>正如上面算法展示，当读取变量定义的时候，如果当前基本块没有变量的定义，那么只能递归地查找其前驱基本块。递归地查找算法如下：</p>

<p>如果基本块只有一个前驱，仅仅在其前驱中查找定义，否则，构造一个 φ 函数，将其所有前驱中定义加入该 φ 函数，并将该 φ 函数作为该基本块的定义。</p>

<p>需要注意的是该查找方式可能导致循环查找，比如在循环体中查找定义。为了避免程序死循环，在查找前先为该基本块建立一个没有任何操作数的 φ 函数作为其定义。</p>

<p>Algorithm 2: Implementation of global value numbering</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>readVariableRecursive(variable, block): 
    if block not in sealedBlocks: 
        # Incomplete CFG 
        val ← new Phi(block) 
        incompletePhis[block][variable] ← val
    else if |block.preds| = 1:
        # Optimize the common case of one predecessor: No phi needed 
        val ← readVariable(variable, block.preds[0])
    else : 
        # Break potential cycles with operandless phi 
        val ← new Phi(block) 
        writeVariable(variable, block, val) 
        val ← addPhiOperands(variable, val) 
    writeVariable(variable, block, val) 
    return val

addPhiOperands(variable, phi): 
    # Determine operands from predecessors 
    for pred in phi.block.preds: 
        phi.appendOperand(readVariable(variable, pred)) 
    return tryRemoveTrivialPhi(phi) 
</code></pre></div></div>

<p>这种查找方式可能导致多余的 φ 函数，称为 <strong>trivial</strong> 。如果一个 φ 函数引用了自身和另一个定义，那么就叫做 <strong>trivial</strong> φ 函数。比如有 <code class="language-plaintext highlighter-rouge">a.1 = φ&lt;a.1, a.0&gt;</code>。这个 φ 函数完全可以被另一个定义给替换。还有一种特殊的情况，φ 函数仅仅引用了自身，这种情况仅仅发生在不可达或者开始基本块，这时用一个 <code class="language-plaintext highlighter-rouge">Undef</code> 值代替。</p>

<p>需要注意的是如果我们替换了 <code class="language-plaintext highlighter-rouge">trivial</code> φ 函数，可能导致引用该 φ 函数的值也变成 <code class="language-plaintext highlighter-rouge">trivial</code> φ 函数，所以还需要递归地进行替换操作。</p>

<p>Algorithm 3: Detect and recursively remove a trivial φ function</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tryRemoveTrivialPhi(phi): 
    same ← None for op in phi.operands: 
        if op = same || op = phi: 
            # Unique value or self−reference
            continue 
        if same = None: 
            # The phi merges at least two values: not trivial 
            return phi 
        same ← op
        if same = None: 
            # The phi is unreachable or in the start block
            same ← new Undef() 

        # Remember all users except the phi itself
        users ← phi.users.remove(phi) 
        # Reroute all uses of phi to same and remove phi
        phi .replaceBy(same)

        # Try to recursively remove all phi users, 
        # which might have become trivial 
        for use in users: 
            if use is a Phi: 
                tryRemoveTrivialPhi(use) 
        return same 
</code></pre></div></div>

<p>上述操作目前还无法处理未完成的循环，比方说如果循环体未处理完，那么循环头部分仍然有可能加入新的前驱，这就是前面引用到的 <code class="language-plaintext highlighter-rouge">Incomplete CFGs</code>。</p>

<h3 id="handling-incomplete-cfgs">Handling Incomplete CFGs</h3>

<p>如果一个基本块不会再加入任何前驱结点，那么就可以称为 <code class="language-plaintext highlighter-rouge">sealed</code> 基本块。因为只有 <code class="language-plaintext highlighter-rouge">filled</code> 基本块拥有后继，所以前驱基本块必须是 <code class="language-plaintext highlighter-rouge">filled</code>。</p>

<p><code class="language-plaintext highlighter-rouge">filled</code> 基本块可以为其后继提供变量定义，而 <code class="language-plaintext highlighter-rouge">sealed</code> 基本块可能会从其前驱中查找变量定义。</p>

<p>Algorithm 4: Handling incomplete CFGs</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sealBlock(block): 
    for variable in incompletePhis[block]: 
        addPhiOperands(variable, incompletePhis[block][variable]) 
        sealedBlocks.add(block) 
</code></pre></div></div>

<p>如果在一个属于 <code class="language-plaintext highlighter-rouge">filled</code> 且非 <code class="language-plaintext highlighter-rouge">sealed</code> 基本块中查找变量定义呢？如前面算法2提到的，对于非 <code class="language-plaintext highlighter-rouge">sealed</code> 基本块，建立一个 函数并保存在 <code class="language-plaintext highlighter-rouge">incompletePhis</code> 中为其后继提供定义。当该非 <code class="language-plaintext highlighter-rouge">sealed</code> 基本块不会有新的前驱加入时，对其进行 <code class="language-plaintext highlighter-rouge">seal</code> 操作。</p>

<p><code class="language-plaintext highlighter-rouge">seal</code> 操作会对该基本块的所有 <code class="language-plaintext highlighter-rouge">incompletePhis</code> 进行处理，完成处理后将该基本块加入 <code class="language-plaintext highlighter-rouge">sealed</code> 集合。</p>

<h3 id="结束">结束</h3>

<p>通过上述四个算法，能够完成 SSA 形式构造，当然，还有进一步的优化这里就不讲了，有兴趣可以直接看论文。</p>


  </div><a class="u-url" href="/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/2016/08/18/Simple-and-Direction-SSA-Constriruction-Algorithm.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">W41ter&#39;s Bistro</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">W41ter&#39;s Bistro</li><li><a class="u-email" href="mailto:w41ter.l@gmail.com">w41ter.l@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/w41ter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">w41ter</span></a></li><li><a href="https://www.twitter.com/WalterM56697798"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WalterM56697798</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Focus on distributed storage system, compiler.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
