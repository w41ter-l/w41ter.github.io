<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>七、function as first class | W41ter’s Bistro</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="七、function as first class" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="当设计一门语言时，函数部分设计五花八门，各种设计所对应的实现方式也各有千秋。" />
<meta property="og:description" content="当设计一门语言时，函数部分设计五花八门，各种设计所对应的实现方式也各有千秋。" />
<link rel="canonical" href="/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/2015/12/25/%E4%B8%83-function-as-first-class.html" />
<meta property="og:url" content="/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/2015/12/25/%E4%B8%83-function-as-first-class.html" />
<meta property="og:site_name" content="W41ter’s Bistro" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-12-25T05:20:49+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="七、function as first class" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2015-12-25T05:20:49+08:00","datePublished":"2015-12-25T05:20:49+08:00","description":"当设计一门语言时，函数部分设计五花八门，各种设计所对应的实现方式也各有千秋。","headline":"七、function as first class","mainEntityOfPage":{"@type":"WebPage","@id":"/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/2015/12/25/%E4%B8%83-function-as-first-class.html"},"url":"/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/2015/12/25/%E4%B8%83-function-as-first-class.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="W41ter's Bistro" /><!-- for mathjax support -->
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">W41ter&#39;s Bistro</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">七、function as first class</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2015-12-25T05:20:49+08:00" itemprop="datePublished">Dec 25, 2015
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>当设计一门语言时，函数部分设计五花八门，各种设计所对应的实现方式也各有千秋。</p>

<!-- more -->

<h2 id="函数式编程">函数式编程</h2>

<p><em>函数式编程</em> 是一种编程范式(programming paradigm)，也就是如何写程序的方法论。它将计算机运算看作是数学中函数的计算，并且避免了状态以及变量的概念。在函数式编程语言中，函数跟其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。且函数中没有副作用(函数内部与外部互动，如内部修改全局变量值)，因此函数只返回新的值，不修改系统变量。在输入参数相同的情况下，得到的结果总是相同的。</p>

<h2 id="c语言中的函数">C语言中的函数</h2>

<p>C语言中的函数并不是严格意义上的函数，它具有副作用。这种函数的实现方式十分简单，对于函数体部分，生成相关代码，保存在静态区域即可。对于函数调用部分，可以将参数压入栈，然后调用。</p>

<p>比如 <code class="language-plaintext highlighter-rouge">printf(1, 2, 2);</code> 可以翻译成如下代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>push 2
push 2
push 1
call printf
</code></pre></div></div>

<h2 id="高阶函数">高阶函数</h2>

<p>我们把接受一个或多个函数作为参数，或者能返回函数的函数叫做高阶函数。在C语言中可以通过函数指针进行传递函数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef void(*func)();
void test() {}
void call(func f) {
    f();
}
</code></pre></div></div>

<p>这样是将函数地址传递给调用函数，可以用汇编简要解释：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>push offset _test
call _call

; in call
call [ebp-4]
</code></pre></div></div>

<h2 id="嵌套函数">嵌套函数</h2>

<p>pascal 之类的语言就支持嵌套函数，所谓嵌套，就是可以在函数内部定义函数。C语言并不支持嵌套函数，我们假设其支持嵌套函数：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void global_func() {
    int a = 20;
    void nest_func() {
        a = 10;
    }
    void nest_func1() {
        int a = 40;
        void test() {
            nest_func();
            a = 30;
        }
        a == 40;
        test();
        a == 30;
    }
    nest_func();
    a == 10;
    a = 20;
    nest_func1();
    a == 10;
}
nest_func(); /* error */
</code></pre></div></div>

<p>可以看到的是，嵌套定义函数可以访问外部作用域，并产生副作用。不同作用域相互之间屏蔽。嵌套作用域给函数实现带来了不少麻烦，比如在查找变量所在作用域时，需要沿着栈帧回溯。如上诉例子，<code class="language-plaintext highlighter-rouge">test</code> 在查找变量 <code class="language-plaintext highlighter-rouge">a</code> 时，应该找到 <code class="language-plaintext highlighter-rouge">nest_func1</code> 中的变量 <code class="language-plaintext highlighter-rouge">a</code> ，而 <code class="language-plaintext highlighter-rouge">test</code> 中调用的 <code class="language-plaintext highlighter-rouge">nest_func</code> 所查找的 <code class="language-plaintext highlighter-rouge">a</code> 却应该是 <code class="language-plaintext highlighter-rouge">global_func</code> 中的 <code class="language-plaintext highlighter-rouge">a</code>。(这里假定使用的是 <em>词法作用域</em>， 而不是 <em>动态作用域</em>)这样就不能直接使用原有的向上回溯查找变量的方法，不过这有相应的解决办法。对于每个函数的帧，我们加入一个访问链指针，其指向当前调用栈中，该函数定义所在的外层函数最近一次调用的帧。比如对于上面的例子，在调用 <code class="language-plaintext highlighter-rouge">nest_func1()</code> 中的 <code class="language-plaintext highlighter-rouge">test()</code> 时，<code class="language-plaintext highlighter-rouge">test</code> 中的指针应当指向其直接上层 <code class="language-plaintext highlighter-rouge">nest_func1</code> , 但是对于 <code class="language-plaintext highlighter-rouge">test()</code> 调用中的函数 <code class="language-plaintext highlighter-rouge">nest_func</code> ，其上层不应当是 <code class="language-plaintext highlighter-rouge">test()</code>。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>top -&gt;  nest_func()
        test()
        nest_func1()
        global_func()
bottom -&gt;
简单的函数调用栈
</code></pre></div></div>

<p>这里 <code class="language-plaintext highlighter-rouge">nest_func</code> 访问链应当指向最上面的 <code class="language-plaintext highlighter-rouge">global_func()</code>。这样，函数在查找变量时，就可以通过访问链回溯而不是调用栈回溯。关于访问链的具体实现，可以参考龙紫书。还需要注意的是如果嵌套函数中有引用外层变量，那么是无法将内层函数当作返回值返回，所以这里需要引入闭包的概念。</p>

<h2 id="柯里化函数">柯里化函数</h2>

<p>在闭包之前需要了解柯里化函数(Currying)，简单来说柯里化函数就是函数生成的函数，比如以下C++代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int func(int a, int b) {
    return a + b;
}
auto call = std::bind(func, 1, _1);
call(1);
</code></pre></div></div>
<p>在这里我们传递给函数 <code class="language-plaintext highlighter-rouge">func</code> 一个参数，然后生成一个保存了当前状态的函数，然后再后续补完全部参数时调用，这就是一个简单的柯里化函数应用。现在来考虑如何实现柯里化函数，柯里化函数需要保存当前已有的状态，那么我们对每一个函数包括普通函数定义一个 frame ，在每一次调用时，检测参数数目，如果满足所有参数都有对应的实参，那么就调用，否则生成一个新函数，将原有的 frame 拷贝一份，并加入新的参数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (args.size() == params.size())
    call function;
else 
    insert new function
    copy frame to new frame and insert params
</code></pre></div></div>

<h2 id="闭包">闭包</h2>

<p>闭包是指可以包含自由(未绑定到特定对象)变量的代码块，这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义。可以把闭包当作嵌套的高阶柯里化函数，嵌套对应着代码块或全局上下文，柯里化函数则是保存当前上下文状态，高阶使得函数可以通过参数或返回值进行传递。对于闭包有多种实现方式，这里紧紧讨论一种非常 native 的实现方式。首先需要对闭包中访问的自由变量进行捕获，然后隐式地作用参数传递给闭包体，生成新函数返回。这样变换以后，新生成的函数并不依赖于其父作用域，使得函数可以在任意地方调用。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(define (func x) 
    (lambda (a) （+ a x))
    
可以改为

(define (func x)
    ((define (nest_func x a)
        (+ a x)) x))
</code></pre></div></div>

  </div><a class="u-url" href="/%E7%BC%96%E8%AF%91%E5%99%A8%E5%AE%9E%E7%8E%B0/2015/12/25/%E4%B8%83-function-as-first-class.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">W41ter&#39;s Bistro</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">W41ter&#39;s Bistro</li><li><a class="u-email" href="mailto:w41ter.l@gmail.com">w41ter.l@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/w41ter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">w41ter</span></a></li><li><a href="https://www.twitter.com/WalterM56697798"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WalterM56697798</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Focus on distributed storage system, compiler.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
