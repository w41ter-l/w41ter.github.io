<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>FoundationDB 架构 - 写事务处理流程 | W41ter’s Bistro</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="FoundationDB 架构 - 写事务处理流程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="背景 从FoundationDB 源码阅读：maintenace 模式的作用中可知 FDB 的 maintenance 模式并不会主动触发 recruit 流程，如果待操作的机器上有 transaction system 的进程，那么重启操作将会引起 3~5s 的服务中断，原因是等待直到 failure detectors 判断机器故障后，cluster controller 才会触发 recruit 流程。 我们需要找到一个机制触发 recruit 流程，同时不触发任何数据迁移，使用 exclude 和 maintenance 配合是否能够取得这个目标呢？这就是本文研究的目的。 FDB 的 exclude 命令用于在不影响可用性和容错的情况下，从集群中临时或永久地移除机器、进程。详情参考：removing-machines-from-a-cluster。 代码分析 设置 exclude 选项 在 fdbcli 中输入 exclude ip:port no_wait 后，会进入 excludeCommandActor(fdbcli/ExcludeCommand.actor.cpp)；完成一系列检查后和准备后，进入 excludeSeversAndLocalities： ACTOR Future&lt;bool&gt; excludeServersAndLocalities(Reference&lt;IDatabase&gt; db, std::vector&lt;AddressExclusion&gt; servers, std::unordered_set&lt;std::string&gt; localities, bool failed, bool force) { state Reference&lt;ITransaction&gt; tr = db-&gt;createTransaction(); loop { tr-&gt;setOption(FDBTransactionOptions::SPECIAL_KEY_SPACE_ENABLE_WRITES); try { if (force &amp;&amp; servers.size()) tr-&gt;set(failed ? fdb_cli::failedForceOptionSpecialKey : fdb_cli::excludedForceOptionSpecialKey, ValueRef()); for (const auto&amp; s : servers) { Key addr = failed ? fdb_cli::failedServersSpecialKeyRange.begin.withSuffix(s.toString()) : fdb_cli::excludedServersSpecialKeyRange.begin.withSuffix(s.toString()); tr-&gt;set(addr, ValueRef()); } if (force &amp;&amp; localities.size()) tr-&gt;set(failed ? fdb_cli::failedLocalityForceOptionSpecialKey : fdb_cli::excludedLocalityForceOptionSpecialKey, ValueRef()); for (const auto&amp; l : localities) { Key addr = failed ? fdb_cli::failedLocalitySpecialKeyRange.begin.withSuffix(l) : fdb_cli::excludedLocalitySpecialKeyRange.begin.withSuffix(l); tr-&gt;set(addr, ValueRef()); } wait(safeThreadFutureToFuture(tr-&gt;commit())) severs 最终保存到 excludedServersSpecialKeyRange 中。注意到 transaction 设置了 SPECIAL_KEY_SPACE_ENABLE_WRITES，在提交给 fdbserver 前，fdbclient 会对 key value 做一些修饰。exclude 对应的 impl 为 ExcludeServersRangeImpl(fdbclient/SpecialKeySpace.actor.cpp)，完成检查后，进入 excludeServers(fdbclient/ManagementAPI.actor.cpp): ACTOR Future&lt;Void&gt; excludeServers(Transaction* tr, std::vector&lt;AddressExclusion&gt; servers, bool failed) { tr-&gt;setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS); tr-&gt;setOption(FDBTransactionOptions::PRIORITY_SYSTEM_IMMEDIATE); tr-&gt;setOption(FDBTransactionOptions::LOCK_AWARE); tr-&gt;setOption(FDBTransactionOptions::USE_PROVISIONAL_PROXIES); std::vector&lt;AddressExclusion&gt; excl = wait(failed ? getExcludedFailedServerList(tr) : getExcludedServerList(tr)); std::set&lt;AddressExclusion&gt; exclusions(excl.begin(), excl.end()); bool containNewExclusion = false; for (auto&amp; s : servers) { if (exclusions.find(s) != exclusions.end()) { continue; } containNewExclusion = true; if (failed) { tr-&gt;set(encodeFailedServersKey(s), StringRef()); } else { tr-&gt;set(encodeExcludedServersKey(s), StringRef()); } } if (containNewExclusion) { std::string excludeVersionKey = deterministicRandom()-&gt;randomUniqueID().toString(); auto serversVersionKey = failed ? failedServersVersionKey : excludedServersVersionKey; tr-&gt;addReadConflictRange(singleKeyRange(serversVersionKey)); // To conflict with parallel includeServers tr-&gt;set(serversVersionKey, excludeVersionKey); } 最终写入到 key \xff\xff/conf/excluded/$server 中。 标记 worker 为 excluded fdbserver 的 cluster controller 在执行完 cluster recovery 后，会启动一个 actor configurationMonitor （fdbserver/ClusterRecovery.actor.cpp）监听 excludedServersVersionKey 的变化。一旦发生变化，则重新读取 DatabaseConfiguration，当其与内存中记录的 configuration 不同时触发 registration： RangeResult results = wait(tr.getRange(configKeys, CLIENT_KNOBS-&gt;TOO_MANY)); ASSERT(!results.more &amp;&amp; results.size() &lt; CLIENT_KNOBS-&gt;TOO_MANY); DatabaseConfiguration conf; conf.fromKeyValues((VectorRef&lt;KeyValueRef&gt;)results); TraceEvent(&quot;ConfigurationMonitor&quot;, self-&gt;dbgid) .detail(getRecoveryEventName(ClusterRecoveryEventType::CLUSTER_RECOVERY_STATE_EVENT_NAME).c_str(), self-&gt;recoveryState); if (conf != self-&gt;configuration) { if (self-&gt;recoveryState != RecoveryState::ALL_LOGS_RECRUITED &amp;&amp; self-&gt;recoveryState != RecoveryState::FULLY_RECOVERED) { self-&gt;controllerData-&gt;shouldCommitSuicide = true; throw restart_cluster_controller(); } self-&gt;configuration = conf; self-&gt;registrationTrigger.trigger(); } 另一个 actor updateRegistration 会等待 registrationTrigger，最后调用 sendMasterRegistration ；后者将新的 configuration 通过 RegisterMasterRequest 发送给 cluster controller。 Cluster controller 的 clusterRegisterMaster(fdbserver/ClusterController.actor.cpp) 负责处理 RegisterMasterRequest 。对于每一个 worker，cluster controller 会将其信息记录在 WorkerInfo 中；WorkerInfo 的成员 priorityInfo 中记录了 isExcluded 字段，表示是否通过 exclude 命令标记。clusterRegisterMaster 会遍历 RegisterMasterRequest 中携带的 configuration，并将 excluded 的 server 标记为 isExcluded = true: db-&gt;fullyRecoveredConfig = req.configuration.get(); for (auto&amp; it : self-&gt;id_worker) { bool isExcludedFromConfig = db-&gt;fullyRecoveredConfig.isExcludedServer(it.second.details.interf.addresses()); if (it.second.priorityInfo.isExcluded != isExcludedFromConfig) { it.second.priorityInfo.isExcluded = isExcludedFromConfig; if (!it.second.reply.isSet()) { it.second.reply.send( RegisterWorkerReply(it.second.details.processClass, it.second.priorityInfo)); } } } 执行 recruit 除了标记 isExcluded 外，clusterRegisterMaster 还会启动一个 actor doCheckOutstandingRequests（fdbserver/ClusterController.actor.cpp）；后者会调用 ClusterControllerData::betterMasterExists： if (self-&gt;betterMasterExists()) { self-&gt;db.forceMasterFailure.trigger(); TraceEvent(&quot;MasterRegistrationKill&quot;, self-&gt;id).detail(&quot;MasterId&quot;, self-&gt;db.serverInfo-&gt;get().master.id()); } betterMasterExists 会依次遍历 TLog, commit proxy, GRV proxy, resolver，任何一个 process 所在的 worker 的 isExcluded 为 true，都会返回 true： if (commitProxyWorker-&gt;second.priorityInfo.isExcluded) { TraceEvent(&quot;BetterMasterExists&quot;, id) .detail(&quot;Reason&quot;, &quot;CommitProxyExcluded&quot;) .detail(&quot;ProcessID&quot;, it.processId); return true; } 最后 forceMasterFailure 会唤醒 clusterWatchDatabase ，后者做一些当前 epoch 的清理工作后，重新调用：clusterRecoveryCore 启动新阶段的 transaction system。 Storage 会迁移吗？ fdbserver 还有一个 ExclusionTracker，它负责监听 excludedServersVersionKey（fdbserver/include/fdbserver/ExclusionTracker.actor.h)。一旦 excluded servers 发生变化，它会唤醒 ACTOR trackExcludedServers (fdbserver/DDTeamCollection.actor.cpp)；后者最终会唤醒 DDTeamCollectionImpl::storageRecruiter: ACTOR static Future&lt;Void&gt; trackExcludedServers(DDTeamCollection* self) { state ExclusionTracker exclusionTracker(self-&gt;dbContext()); loop { // wait for new set of excluded servers wait(exclusionTracker.changed.onTrigger()); auto old = self-&gt;excludedServers.getKeys(); for (const auto&amp; o : old) { if (!exclusionTracker.excluded.count(o) &amp;&amp; !exclusionTracker.failed.count(o) &amp;&amp; !(self-&gt;excludedServers.count(o) &amp;&amp; self-&gt;excludedServers.get(o) == DDTeamCollection::Status::WIGGLING)) { self-&gt;excludedServers.set(o, DDTeamCollection::Status::NONE); } } for (const auto&amp; n : exclusionTracker.excluded) { if (!exclusionTracker.failed.count(n)) { self-&gt;excludedServers.set(n, DDTeamCollection::Status::EXCLUDED); } } ... self-&gt;restartRecruiting.trigger(); } } storageRecruiter 会收集信息并发送 RecruitStorageRequest 给 cluster controller: std::set&lt;AddressExclusion&gt; exclusions; auto excl = self-&gt;excludedServers.getKeys(); for (const auto&amp; s : excl) { if (self-&gt;excludedServers.get(s) != DDTeamCollection::Status::NONE) { TraceEvent(SevDebug, &quot;DDRecruitExcl2&quot;) .detail(&quot;Primary&quot;, self-&gt;primary) .detail(&quot;Excluding&quot;, s.toString()); exclusions.insert(s); } } for (auto it : exclusions) { rsr.excludeAddresses.push_back(it); } if (!fCandidateWorker.isValid() || fCandidateWorker.isReady() || rsr.excludeAddresses != lastRequest.excludeAddresses || rsr.criticalRecruitment != lastRequest.criticalRecruitment) { lastRequest = rsr; fCandidateWorker = brokenPromiseToNever(recruitStorage-&gt;get().getReply(rsr, TaskPriority::DataDistribution)); } 前边设置好的 exclude 会被放到请求的 excludeAddresses 字段中。cluster controller 会根据请求条件过滤掉不合适的 worker（fdbserver/include/fdbserver/ClusterController.actor.h:ClusterControllerData::getStorageWorker）。收到 response 后，storageRecruiter 会发送 InitialStorageRequest 给目标进程，完成 recruit 流程。 可以发现，这个过程中并没有判断 storage process 的 failure status，而是直接发送 RecruitStorageRequest。那么这就意味着不能手动临时 exclude 任何一个 storage，否则都会触发数据迁移。 结论 通过分析，exclude 命令的确可以主动触发 recruit 流程，同时如果 process 上有 storage role，它还出触发 recruit storage 流程。 如果我们现在需要取得平滑升级的能力，那么需要以下几个步骤： 列出所有的 process 的 role，如果目标机器上某个 process 有 transaction system 的 role （非 coordinator，非 storage），那么执行 exclude $IP:$PORT 等到 recovery 完成后，执行 maintenance on $zone-id，表示禁用 storage process 的 failure detector 修改配置、重启 执行 maintenance off 执行 include $IP:$PORT，允许 transaction system 的 role 调度回该机器" />
<meta property="og:description" content="背景 从FoundationDB 源码阅读：maintenace 模式的作用中可知 FDB 的 maintenance 模式并不会主动触发 recruit 流程，如果待操作的机器上有 transaction system 的进程，那么重启操作将会引起 3~5s 的服务中断，原因是等待直到 failure detectors 判断机器故障后，cluster controller 才会触发 recruit 流程。 我们需要找到一个机制触发 recruit 流程，同时不触发任何数据迁移，使用 exclude 和 maintenance 配合是否能够取得这个目标呢？这就是本文研究的目的。 FDB 的 exclude 命令用于在不影响可用性和容错的情况下，从集群中临时或永久地移除机器、进程。详情参考：removing-machines-from-a-cluster。 代码分析 设置 exclude 选项 在 fdbcli 中输入 exclude ip:port no_wait 后，会进入 excludeCommandActor(fdbcli/ExcludeCommand.actor.cpp)；完成一系列检查后和准备后，进入 excludeSeversAndLocalities： ACTOR Future&lt;bool&gt; excludeServersAndLocalities(Reference&lt;IDatabase&gt; db, std::vector&lt;AddressExclusion&gt; servers, std::unordered_set&lt;std::string&gt; localities, bool failed, bool force) { state Reference&lt;ITransaction&gt; tr = db-&gt;createTransaction(); loop { tr-&gt;setOption(FDBTransactionOptions::SPECIAL_KEY_SPACE_ENABLE_WRITES); try { if (force &amp;&amp; servers.size()) tr-&gt;set(failed ? fdb_cli::failedForceOptionSpecialKey : fdb_cli::excludedForceOptionSpecialKey, ValueRef()); for (const auto&amp; s : servers) { Key addr = failed ? fdb_cli::failedServersSpecialKeyRange.begin.withSuffix(s.toString()) : fdb_cli::excludedServersSpecialKeyRange.begin.withSuffix(s.toString()); tr-&gt;set(addr, ValueRef()); } if (force &amp;&amp; localities.size()) tr-&gt;set(failed ? fdb_cli::failedLocalityForceOptionSpecialKey : fdb_cli::excludedLocalityForceOptionSpecialKey, ValueRef()); for (const auto&amp; l : localities) { Key addr = failed ? fdb_cli::failedLocalitySpecialKeyRange.begin.withSuffix(l) : fdb_cli::excludedLocalitySpecialKeyRange.begin.withSuffix(l); tr-&gt;set(addr, ValueRef()); } wait(safeThreadFutureToFuture(tr-&gt;commit())) severs 最终保存到 excludedServersSpecialKeyRange 中。注意到 transaction 设置了 SPECIAL_KEY_SPACE_ENABLE_WRITES，在提交给 fdbserver 前，fdbclient 会对 key value 做一些修饰。exclude 对应的 impl 为 ExcludeServersRangeImpl(fdbclient/SpecialKeySpace.actor.cpp)，完成检查后，进入 excludeServers(fdbclient/ManagementAPI.actor.cpp): ACTOR Future&lt;Void&gt; excludeServers(Transaction* tr, std::vector&lt;AddressExclusion&gt; servers, bool failed) { tr-&gt;setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS); tr-&gt;setOption(FDBTransactionOptions::PRIORITY_SYSTEM_IMMEDIATE); tr-&gt;setOption(FDBTransactionOptions::LOCK_AWARE); tr-&gt;setOption(FDBTransactionOptions::USE_PROVISIONAL_PROXIES); std::vector&lt;AddressExclusion&gt; excl = wait(failed ? getExcludedFailedServerList(tr) : getExcludedServerList(tr)); std::set&lt;AddressExclusion&gt; exclusions(excl.begin(), excl.end()); bool containNewExclusion = false; for (auto&amp; s : servers) { if (exclusions.find(s) != exclusions.end()) { continue; } containNewExclusion = true; if (failed) { tr-&gt;set(encodeFailedServersKey(s), StringRef()); } else { tr-&gt;set(encodeExcludedServersKey(s), StringRef()); } } if (containNewExclusion) { std::string excludeVersionKey = deterministicRandom()-&gt;randomUniqueID().toString(); auto serversVersionKey = failed ? failedServersVersionKey : excludedServersVersionKey; tr-&gt;addReadConflictRange(singleKeyRange(serversVersionKey)); // To conflict with parallel includeServers tr-&gt;set(serversVersionKey, excludeVersionKey); } 最终写入到 key \xff\xff/conf/excluded/$server 中。 标记 worker 为 excluded fdbserver 的 cluster controller 在执行完 cluster recovery 后，会启动一个 actor configurationMonitor （fdbserver/ClusterRecovery.actor.cpp）监听 excludedServersVersionKey 的变化。一旦发生变化，则重新读取 DatabaseConfiguration，当其与内存中记录的 configuration 不同时触发 registration： RangeResult results = wait(tr.getRange(configKeys, CLIENT_KNOBS-&gt;TOO_MANY)); ASSERT(!results.more &amp;&amp; results.size() &lt; CLIENT_KNOBS-&gt;TOO_MANY); DatabaseConfiguration conf; conf.fromKeyValues((VectorRef&lt;KeyValueRef&gt;)results); TraceEvent(&quot;ConfigurationMonitor&quot;, self-&gt;dbgid) .detail(getRecoveryEventName(ClusterRecoveryEventType::CLUSTER_RECOVERY_STATE_EVENT_NAME).c_str(), self-&gt;recoveryState); if (conf != self-&gt;configuration) { if (self-&gt;recoveryState != RecoveryState::ALL_LOGS_RECRUITED &amp;&amp; self-&gt;recoveryState != RecoveryState::FULLY_RECOVERED) { self-&gt;controllerData-&gt;shouldCommitSuicide = true; throw restart_cluster_controller(); } self-&gt;configuration = conf; self-&gt;registrationTrigger.trigger(); } 另一个 actor updateRegistration 会等待 registrationTrigger，最后调用 sendMasterRegistration ；后者将新的 configuration 通过 RegisterMasterRequest 发送给 cluster controller。 Cluster controller 的 clusterRegisterMaster(fdbserver/ClusterController.actor.cpp) 负责处理 RegisterMasterRequest 。对于每一个 worker，cluster controller 会将其信息记录在 WorkerInfo 中；WorkerInfo 的成员 priorityInfo 中记录了 isExcluded 字段，表示是否通过 exclude 命令标记。clusterRegisterMaster 会遍历 RegisterMasterRequest 中携带的 configuration，并将 excluded 的 server 标记为 isExcluded = true: db-&gt;fullyRecoveredConfig = req.configuration.get(); for (auto&amp; it : self-&gt;id_worker) { bool isExcludedFromConfig = db-&gt;fullyRecoveredConfig.isExcludedServer(it.second.details.interf.addresses()); if (it.second.priorityInfo.isExcluded != isExcludedFromConfig) { it.second.priorityInfo.isExcluded = isExcludedFromConfig; if (!it.second.reply.isSet()) { it.second.reply.send( RegisterWorkerReply(it.second.details.processClass, it.second.priorityInfo)); } } } 执行 recruit 除了标记 isExcluded 外，clusterRegisterMaster 还会启动一个 actor doCheckOutstandingRequests（fdbserver/ClusterController.actor.cpp）；后者会调用 ClusterControllerData::betterMasterExists： if (self-&gt;betterMasterExists()) { self-&gt;db.forceMasterFailure.trigger(); TraceEvent(&quot;MasterRegistrationKill&quot;, self-&gt;id).detail(&quot;MasterId&quot;, self-&gt;db.serverInfo-&gt;get().master.id()); } betterMasterExists 会依次遍历 TLog, commit proxy, GRV proxy, resolver，任何一个 process 所在的 worker 的 isExcluded 为 true，都会返回 true： if (commitProxyWorker-&gt;second.priorityInfo.isExcluded) { TraceEvent(&quot;BetterMasterExists&quot;, id) .detail(&quot;Reason&quot;, &quot;CommitProxyExcluded&quot;) .detail(&quot;ProcessID&quot;, it.processId); return true; } 最后 forceMasterFailure 会唤醒 clusterWatchDatabase ，后者做一些当前 epoch 的清理工作后，重新调用：clusterRecoveryCore 启动新阶段的 transaction system。 Storage 会迁移吗？ fdbserver 还有一个 ExclusionTracker，它负责监听 excludedServersVersionKey（fdbserver/include/fdbserver/ExclusionTracker.actor.h)。一旦 excluded servers 发生变化，它会唤醒 ACTOR trackExcludedServers (fdbserver/DDTeamCollection.actor.cpp)；后者最终会唤醒 DDTeamCollectionImpl::storageRecruiter: ACTOR static Future&lt;Void&gt; trackExcludedServers(DDTeamCollection* self) { state ExclusionTracker exclusionTracker(self-&gt;dbContext()); loop { // wait for new set of excluded servers wait(exclusionTracker.changed.onTrigger()); auto old = self-&gt;excludedServers.getKeys(); for (const auto&amp; o : old) { if (!exclusionTracker.excluded.count(o) &amp;&amp; !exclusionTracker.failed.count(o) &amp;&amp; !(self-&gt;excludedServers.count(o) &amp;&amp; self-&gt;excludedServers.get(o) == DDTeamCollection::Status::WIGGLING)) { self-&gt;excludedServers.set(o, DDTeamCollection::Status::NONE); } } for (const auto&amp; n : exclusionTracker.excluded) { if (!exclusionTracker.failed.count(n)) { self-&gt;excludedServers.set(n, DDTeamCollection::Status::EXCLUDED); } } ... self-&gt;restartRecruiting.trigger(); } } storageRecruiter 会收集信息并发送 RecruitStorageRequest 给 cluster controller: std::set&lt;AddressExclusion&gt; exclusions; auto excl = self-&gt;excludedServers.getKeys(); for (const auto&amp; s : excl) { if (self-&gt;excludedServers.get(s) != DDTeamCollection::Status::NONE) { TraceEvent(SevDebug, &quot;DDRecruitExcl2&quot;) .detail(&quot;Primary&quot;, self-&gt;primary) .detail(&quot;Excluding&quot;, s.toString()); exclusions.insert(s); } } for (auto it : exclusions) { rsr.excludeAddresses.push_back(it); } if (!fCandidateWorker.isValid() || fCandidateWorker.isReady() || rsr.excludeAddresses != lastRequest.excludeAddresses || rsr.criticalRecruitment != lastRequest.criticalRecruitment) { lastRequest = rsr; fCandidateWorker = brokenPromiseToNever(recruitStorage-&gt;get().getReply(rsr, TaskPriority::DataDistribution)); } 前边设置好的 exclude 会被放到请求的 excludeAddresses 字段中。cluster controller 会根据请求条件过滤掉不合适的 worker（fdbserver/include/fdbserver/ClusterController.actor.h:ClusterControllerData::getStorageWorker）。收到 response 后，storageRecruiter 会发送 InitialStorageRequest 给目标进程，完成 recruit 流程。 可以发现，这个过程中并没有判断 storage process 的 failure status，而是直接发送 RecruitStorageRequest。那么这就意味着不能手动临时 exclude 任何一个 storage，否则都会触发数据迁移。 结论 通过分析，exclude 命令的确可以主动触发 recruit 流程，同时如果 process 上有 storage role，它还出触发 recruit storage 流程。 如果我们现在需要取得平滑升级的能力，那么需要以下几个步骤： 列出所有的 process 的 role，如果目标机器上某个 process 有 transaction system 的 role （非 coordinator，非 storage），那么执行 exclude $IP:$PORT 等到 recovery 完成后，执行 maintenance on $zone-id，表示禁用 storage process 的 failure detector 修改配置、重启 执行 maintenance off 执行 include $IP:$PORT，允许 transaction system 的 role 调度回该机器" />
<link rel="canonical" href="/2023/07/20/FDB-exclude-cmd.html" />
<meta property="og:url" content="/2023/07/20/FDB-exclude-cmd.html" />
<meta property="og:site_name" content="W41ter’s Bistro" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-07-20T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="FoundationDB 架构 - 写事务处理流程" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-07-20T00:00:00+08:00","datePublished":"2023-07-20T00:00:00+08:00","description":"背景 从FoundationDB 源码阅读：maintenace 模式的作用中可知 FDB 的 maintenance 模式并不会主动触发 recruit 流程，如果待操作的机器上有 transaction system 的进程，那么重启操作将会引起 3~5s 的服务中断，原因是等待直到 failure detectors 判断机器故障后，cluster controller 才会触发 recruit 流程。 我们需要找到一个机制触发 recruit 流程，同时不触发任何数据迁移，使用 exclude 和 maintenance 配合是否能够取得这个目标呢？这就是本文研究的目的。 FDB 的 exclude 命令用于在不影响可用性和容错的情况下，从集群中临时或永久地移除机器、进程。详情参考：removing-machines-from-a-cluster。 代码分析 设置 exclude 选项 在 fdbcli 中输入 exclude ip:port no_wait 后，会进入 excludeCommandActor(fdbcli/ExcludeCommand.actor.cpp)；完成一系列检查后和准备后，进入 excludeSeversAndLocalities： ACTOR Future&lt;bool&gt; excludeServersAndLocalities(Reference&lt;IDatabase&gt; db, std::vector&lt;AddressExclusion&gt; servers, std::unordered_set&lt;std::string&gt; localities, bool failed, bool force) { state Reference&lt;ITransaction&gt; tr = db-&gt;createTransaction(); loop { tr-&gt;setOption(FDBTransactionOptions::SPECIAL_KEY_SPACE_ENABLE_WRITES); try { if (force &amp;&amp; servers.size()) tr-&gt;set(failed ? fdb_cli::failedForceOptionSpecialKey : fdb_cli::excludedForceOptionSpecialKey, ValueRef()); for (const auto&amp; s : servers) { Key addr = failed ? fdb_cli::failedServersSpecialKeyRange.begin.withSuffix(s.toString()) : fdb_cli::excludedServersSpecialKeyRange.begin.withSuffix(s.toString()); tr-&gt;set(addr, ValueRef()); } if (force &amp;&amp; localities.size()) tr-&gt;set(failed ? fdb_cli::failedLocalityForceOptionSpecialKey : fdb_cli::excludedLocalityForceOptionSpecialKey, ValueRef()); for (const auto&amp; l : localities) { Key addr = failed ? fdb_cli::failedLocalitySpecialKeyRange.begin.withSuffix(l) : fdb_cli::excludedLocalitySpecialKeyRange.begin.withSuffix(l); tr-&gt;set(addr, ValueRef()); } wait(safeThreadFutureToFuture(tr-&gt;commit())) severs 最终保存到 excludedServersSpecialKeyRange 中。注意到 transaction 设置了 SPECIAL_KEY_SPACE_ENABLE_WRITES，在提交给 fdbserver 前，fdbclient 会对 key value 做一些修饰。exclude 对应的 impl 为 ExcludeServersRangeImpl(fdbclient/SpecialKeySpace.actor.cpp)，完成检查后，进入 excludeServers(fdbclient/ManagementAPI.actor.cpp): ACTOR Future&lt;Void&gt; excludeServers(Transaction* tr, std::vector&lt;AddressExclusion&gt; servers, bool failed) { tr-&gt;setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS); tr-&gt;setOption(FDBTransactionOptions::PRIORITY_SYSTEM_IMMEDIATE); tr-&gt;setOption(FDBTransactionOptions::LOCK_AWARE); tr-&gt;setOption(FDBTransactionOptions::USE_PROVISIONAL_PROXIES); std::vector&lt;AddressExclusion&gt; excl = wait(failed ? getExcludedFailedServerList(tr) : getExcludedServerList(tr)); std::set&lt;AddressExclusion&gt; exclusions(excl.begin(), excl.end()); bool containNewExclusion = false; for (auto&amp; s : servers) { if (exclusions.find(s) != exclusions.end()) { continue; } containNewExclusion = true; if (failed) { tr-&gt;set(encodeFailedServersKey(s), StringRef()); } else { tr-&gt;set(encodeExcludedServersKey(s), StringRef()); } } if (containNewExclusion) { std::string excludeVersionKey = deterministicRandom()-&gt;randomUniqueID().toString(); auto serversVersionKey = failed ? failedServersVersionKey : excludedServersVersionKey; tr-&gt;addReadConflictRange(singleKeyRange(serversVersionKey)); // To conflict with parallel includeServers tr-&gt;set(serversVersionKey, excludeVersionKey); } 最终写入到 key \\xff\\xff/conf/excluded/$server 中。 标记 worker 为 excluded fdbserver 的 cluster controller 在执行完 cluster recovery 后，会启动一个 actor configurationMonitor （fdbserver/ClusterRecovery.actor.cpp）监听 excludedServersVersionKey 的变化。一旦发生变化，则重新读取 DatabaseConfiguration，当其与内存中记录的 configuration 不同时触发 registration： RangeResult results = wait(tr.getRange(configKeys, CLIENT_KNOBS-&gt;TOO_MANY)); ASSERT(!results.more &amp;&amp; results.size() &lt; CLIENT_KNOBS-&gt;TOO_MANY); DatabaseConfiguration conf; conf.fromKeyValues((VectorRef&lt;KeyValueRef&gt;)results); TraceEvent(&quot;ConfigurationMonitor&quot;, self-&gt;dbgid) .detail(getRecoveryEventName(ClusterRecoveryEventType::CLUSTER_RECOVERY_STATE_EVENT_NAME).c_str(), self-&gt;recoveryState); if (conf != self-&gt;configuration) { if (self-&gt;recoveryState != RecoveryState::ALL_LOGS_RECRUITED &amp;&amp; self-&gt;recoveryState != RecoveryState::FULLY_RECOVERED) { self-&gt;controllerData-&gt;shouldCommitSuicide = true; throw restart_cluster_controller(); } self-&gt;configuration = conf; self-&gt;registrationTrigger.trigger(); } 另一个 actor updateRegistration 会等待 registrationTrigger，最后调用 sendMasterRegistration ；后者将新的 configuration 通过 RegisterMasterRequest 发送给 cluster controller。 Cluster controller 的 clusterRegisterMaster(fdbserver/ClusterController.actor.cpp) 负责处理 RegisterMasterRequest 。对于每一个 worker，cluster controller 会将其信息记录在 WorkerInfo 中；WorkerInfo 的成员 priorityInfo 中记录了 isExcluded 字段，表示是否通过 exclude 命令标记。clusterRegisterMaster 会遍历 RegisterMasterRequest 中携带的 configuration，并将 excluded 的 server 标记为 isExcluded = true: db-&gt;fullyRecoveredConfig = req.configuration.get(); for (auto&amp; it : self-&gt;id_worker) { bool isExcludedFromConfig = db-&gt;fullyRecoveredConfig.isExcludedServer(it.second.details.interf.addresses()); if (it.second.priorityInfo.isExcluded != isExcludedFromConfig) { it.second.priorityInfo.isExcluded = isExcludedFromConfig; if (!it.second.reply.isSet()) { it.second.reply.send( RegisterWorkerReply(it.second.details.processClass, it.second.priorityInfo)); } } } 执行 recruit 除了标记 isExcluded 外，clusterRegisterMaster 还会启动一个 actor doCheckOutstandingRequests（fdbserver/ClusterController.actor.cpp）；后者会调用 ClusterControllerData::betterMasterExists： if (self-&gt;betterMasterExists()) { self-&gt;db.forceMasterFailure.trigger(); TraceEvent(&quot;MasterRegistrationKill&quot;, self-&gt;id).detail(&quot;MasterId&quot;, self-&gt;db.serverInfo-&gt;get().master.id()); } betterMasterExists 会依次遍历 TLog, commit proxy, GRV proxy, resolver，任何一个 process 所在的 worker 的 isExcluded 为 true，都会返回 true： if (commitProxyWorker-&gt;second.priorityInfo.isExcluded) { TraceEvent(&quot;BetterMasterExists&quot;, id) .detail(&quot;Reason&quot;, &quot;CommitProxyExcluded&quot;) .detail(&quot;ProcessID&quot;, it.processId); return true; } 最后 forceMasterFailure 会唤醒 clusterWatchDatabase ，后者做一些当前 epoch 的清理工作后，重新调用：clusterRecoveryCore 启动新阶段的 transaction system。 Storage 会迁移吗？ fdbserver 还有一个 ExclusionTracker，它负责监听 excludedServersVersionKey（fdbserver/include/fdbserver/ExclusionTracker.actor.h)。一旦 excluded servers 发生变化，它会唤醒 ACTOR trackExcludedServers (fdbserver/DDTeamCollection.actor.cpp)；后者最终会唤醒 DDTeamCollectionImpl::storageRecruiter: ACTOR static Future&lt;Void&gt; trackExcludedServers(DDTeamCollection* self) { state ExclusionTracker exclusionTracker(self-&gt;dbContext()); loop { // wait for new set of excluded servers wait(exclusionTracker.changed.onTrigger()); auto old = self-&gt;excludedServers.getKeys(); for (const auto&amp; o : old) { if (!exclusionTracker.excluded.count(o) &amp;&amp; !exclusionTracker.failed.count(o) &amp;&amp; !(self-&gt;excludedServers.count(o) &amp;&amp; self-&gt;excludedServers.get(o) == DDTeamCollection::Status::WIGGLING)) { self-&gt;excludedServers.set(o, DDTeamCollection::Status::NONE); } } for (const auto&amp; n : exclusionTracker.excluded) { if (!exclusionTracker.failed.count(n)) { self-&gt;excludedServers.set(n, DDTeamCollection::Status::EXCLUDED); } } ... self-&gt;restartRecruiting.trigger(); } } storageRecruiter 会收集信息并发送 RecruitStorageRequest 给 cluster controller: std::set&lt;AddressExclusion&gt; exclusions; auto excl = self-&gt;excludedServers.getKeys(); for (const auto&amp; s : excl) { if (self-&gt;excludedServers.get(s) != DDTeamCollection::Status::NONE) { TraceEvent(SevDebug, &quot;DDRecruitExcl2&quot;) .detail(&quot;Primary&quot;, self-&gt;primary) .detail(&quot;Excluding&quot;, s.toString()); exclusions.insert(s); } } for (auto it : exclusions) { rsr.excludeAddresses.push_back(it); } if (!fCandidateWorker.isValid() || fCandidateWorker.isReady() || rsr.excludeAddresses != lastRequest.excludeAddresses || rsr.criticalRecruitment != lastRequest.criticalRecruitment) { lastRequest = rsr; fCandidateWorker = brokenPromiseToNever(recruitStorage-&gt;get().getReply(rsr, TaskPriority::DataDistribution)); } 前边设置好的 exclude 会被放到请求的 excludeAddresses 字段中。cluster controller 会根据请求条件过滤掉不合适的 worker（fdbserver/include/fdbserver/ClusterController.actor.h:ClusterControllerData::getStorageWorker）。收到 response 后，storageRecruiter 会发送 InitialStorageRequest 给目标进程，完成 recruit 流程。 可以发现，这个过程中并没有判断 storage process 的 failure status，而是直接发送 RecruitStorageRequest。那么这就意味着不能手动临时 exclude 任何一个 storage，否则都会触发数据迁移。 结论 通过分析，exclude 命令的确可以主动触发 recruit 流程，同时如果 process 上有 storage role，它还出触发 recruit storage 流程。 如果我们现在需要取得平滑升级的能力，那么需要以下几个步骤： 列出所有的 process 的 role，如果目标机器上某个 process 有 transaction system 的 role （非 coordinator，非 storage），那么执行 exclude $IP:$PORT 等到 recovery 完成后，执行 maintenance on $zone-id，表示禁用 storage process 的 failure detector 修改配置、重启 执行 maintenance off 执行 include $IP:$PORT，允许 transaction system 的 role 调度回该机器","headline":"FoundationDB 架构 - 写事务处理流程","mainEntityOfPage":{"@type":"WebPage","@id":"/2023/07/20/FDB-exclude-cmd.html"},"url":"/2023/07/20/FDB-exclude-cmd.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="W41ter's Bistro" /><!-- for mathjax support -->
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          extensions: [
          "tex2jax.js",
          "MathMenu.js",
          "MathZoom.js",
          "AssistiveMML.js",
          "a11y/accessibility-menu.js"
        ],
        tex2jax: {      // AND HERE
          inlineMath: [['$', '$']],
          displayMath: [['$$', '$$']]
        },
        jax: ["input/TeX", "output/CommonHTML"],
        TeX: {
          extensions: [
            "AMSmath.js",
            "AMSsymbols.js",
            "noErrors.js",
            "noUndefined.js",
          ],
          equationNumbers: { autoNumber: "AMS" }
        }
      });
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">W41ter&#39;s Bistro</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">FoundationDB 架构 - 写事务处理流程</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-07-20T00:00:00+08:00" itemprop="datePublished">Jul 20, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="背景">背景</h1>

<p>从<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODgyOTg5NA==&amp;mid=2247483676&amp;idx=1&amp;sn=3f8175c1b2996a9690ac620e053b9034&amp;chksm=fdd784b5caa00da338f85dc606152eda51c25bdd7c052370fdc6de3dc789fede709a6437f7fe&amp;=873428723&amp;=zh_CN#rd">FoundationDB 源码阅读：maintenace 模式的作用</a>中可知 FDB 的 <code class="language-plaintext highlighter-rouge">maintenance</code> 模式并不会主动触发 recruit 流程，如果待操作的机器上有 transaction system 的进程，那么重启操作将会引起 3~5s 的服务中断，原因是等待直到 failure detectors 判断机器故障后，cluster controller 才会触发 recruit 流程。</p>

<p>我们需要找到一个机制触发 recruit 流程，同时不触发任何数据迁移，使用 <code class="language-plaintext highlighter-rouge">exclude</code> 和 <code class="language-plaintext highlighter-rouge">maintenance</code> 配合是否能够取得这个目标呢？这就是本文研究的目的。</p>

<p>FDB 的 <code class="language-plaintext highlighter-rouge">exclude</code> 命令用于在不影响可用性和容错的情况下，从集群中临时或永久地移除机器、进程。详情参考：<a href="https://apple.github.io/foundationdb/administration.html#removing-machines-from-a-cluster" title="removing-machines-from-a-cluster">removing-machines-from-a-cluster</a>。</p>

<h1 id="代码分析">代码分析</h1>

<h2 id="设置-exclude-选项">设置 exclude 选项</h2>

<p>在 fdbcli 中输入 exclude ip:port no_wait 后，会进入 excludeCommandActor(fdbcli/ExcludeCommand.actor.cpp)；完成一系列检查后和准备后，进入 excludeSeversAndLocalities：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ACTOR</span> <span class="n">Future</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">excludeServersAndLocalities</span><span class="p">(</span><span class="n">Reference</span><span class="o">&lt;</span><span class="n">IDatabase</span><span class="o">&gt;</span> <span class="n">db</span><span class="p">,</span>
                                               <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AddressExclusion</span><span class="o">&gt;</span> <span class="n">servers</span><span class="p">,</span>
                                               <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">localities</span><span class="p">,</span>
                                               <span class="kt">bool</span> <span class="n">failed</span><span class="p">,</span>
                                               <span class="kt">bool</span> <span class="n">force</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">state</span> <span class="n">Reference</span><span class="o">&lt;</span><span class="n">ITransaction</span><span class="o">&gt;</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">createTransaction</span><span class="p">();</span>
    <span class="n">loop</span> <span class="p">{</span>
        <span class="n">tr</span><span class="o">-&gt;</span><span class="n">setOption</span><span class="p">(</span><span class="n">FDBTransactionOptions</span><span class="o">::</span><span class="n">SPECIAL_KEY_SPACE_ENABLE_WRITES</span><span class="p">);</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">&amp;&amp;</span> <span class="n">servers</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
                <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">failed</span> <span class="o">?</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">failedForceOptionSpecialKey</span> <span class="o">:</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">excludedForceOptionSpecialKey</span><span class="p">,</span>
                        <span class="n">ValueRef</span><span class="p">());</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">s</span> <span class="o">:</span> <span class="n">servers</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Key</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">failed</span> <span class="o">?</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">failedServersSpecialKeyRange</span><span class="p">.</span><span class="n">begin</span><span class="p">.</span><span class="n">withSuffix</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">toString</span><span class="p">())</span>
                                  <span class="o">:</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">excludedServersSpecialKeyRange</span><span class="p">.</span><span class="n">begin</span><span class="p">.</span><span class="n">withSuffix</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">toString</span><span class="p">());</span>
                <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">ValueRef</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">&amp;&amp;</span> <span class="n">localities</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
                <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">failed</span> <span class="o">?</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">failedLocalityForceOptionSpecialKey</span>
                               <span class="o">:</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">excludedLocalityForceOptionSpecialKey</span><span class="p">,</span>
                        <span class="n">ValueRef</span><span class="p">());</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">l</span> <span class="o">:</span> <span class="n">localities</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Key</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">failed</span> <span class="o">?</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">failedLocalitySpecialKeyRange</span><span class="p">.</span><span class="n">begin</span><span class="p">.</span><span class="n">withSuffix</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                                  <span class="o">:</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">excludedLocalitySpecialKeyRange</span><span class="p">.</span><span class="n">begin</span><span class="p">.</span><span class="n">withSuffix</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
                <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">ValueRef</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="n">wait</span><span class="p">(</span><span class="n">safeThreadFutureToFuture</span><span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">()))</span>
</code></pre></div></div>

<p>severs 最终保存到 <code class="language-plaintext highlighter-rouge">excludedServersSpecialKeyRange</code> 中。注意到 transaction 设置了 <code class="language-plaintext highlighter-rouge">SPECIAL_KEY_SPACE_ENABLE_WRITES</code>，在提交给 fdbserver 前，fdbclient 会对 key value 做一些修饰。exclude 对应的 impl 为 <code class="language-plaintext highlighter-rouge">ExcludeServersRangeImpl</code>(<code class="language-plaintext highlighter-rouge">fdbclient/SpecialKeySpace.actor.cpp</code>)，完成检查后，进入 <code class="language-plaintext highlighter-rouge">excludeServers</code>(<code class="language-plaintext highlighter-rouge">fdbclient/ManagementAPI.actor.cpp</code>):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ACTOR</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">excludeServers</span><span class="p">(</span><span class="n">Transaction</span><span class="o">*</span> <span class="n">tr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AddressExclusion</span><span class="o">&gt;</span> <span class="n">servers</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">failed</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tr</span><span class="o">-&gt;</span><span class="n">setOption</span><span class="p">(</span><span class="n">FDBTransactionOptions</span><span class="o">::</span><span class="n">ACCESS_SYSTEM_KEYS</span><span class="p">);</span>
    <span class="n">tr</span><span class="o">-&gt;</span><span class="n">setOption</span><span class="p">(</span><span class="n">FDBTransactionOptions</span><span class="o">::</span><span class="n">PRIORITY_SYSTEM_IMMEDIATE</span><span class="p">);</span>
    <span class="n">tr</span><span class="o">-&gt;</span><span class="n">setOption</span><span class="p">(</span><span class="n">FDBTransactionOptions</span><span class="o">::</span><span class="n">LOCK_AWARE</span><span class="p">);</span>
    <span class="n">tr</span><span class="o">-&gt;</span><span class="n">setOption</span><span class="p">(</span><span class="n">FDBTransactionOptions</span><span class="o">::</span><span class="n">USE_PROVISIONAL_PROXIES</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AddressExclusion</span><span class="o">&gt;</span> <span class="n">excl</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="n">failed</span> <span class="o">?</span> <span class="n">getExcludedFailedServerList</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">:</span> <span class="n">getExcludedServerList</span><span class="p">(</span><span class="n">tr</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">AddressExclusion</span><span class="o">&gt;</span> <span class="n">exclusions</span><span class="p">(</span><span class="n">excl</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">excl</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="kt">bool</span> <span class="n">containNewExclusion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">s</span> <span class="o">:</span> <span class="n">servers</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">exclusions</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="n">exclusions</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">containNewExclusion</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">failed</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">encodeFailedServersKey</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">StringRef</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">encodeExcludedServersKey</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">StringRef</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">containNewExclusion</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">excludeVersionKey</span> <span class="o">=</span> <span class="n">deterministicRandom</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">randomUniqueID</span><span class="p">().</span><span class="n">toString</span><span class="p">();</span>
        <span class="k">auto</span> <span class="n">serversVersionKey</span> <span class="o">=</span> <span class="n">failed</span> <span class="o">?</span> <span class="n">failedServersVersionKey</span> <span class="o">:</span> <span class="n">excludedServersVersionKey</span><span class="p">;</span>
        <span class="n">tr</span><span class="o">-&gt;</span><span class="n">addReadConflictRange</span><span class="p">(</span><span class="n">singleKeyRange</span><span class="p">(</span><span class="n">serversVersionKey</span><span class="p">));</span> <span class="c1">// To conflict with parallel includeServers</span>
        <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">serversVersionKey</span><span class="p">,</span> <span class="n">excludeVersionKey</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>最终写入到 key <code class="language-plaintext highlighter-rouge">\xff\xff/conf/excluded/$server</code> 中。</p>

<h2 id="标记-worker-为-excluded">标记 worker 为 excluded</h2>

<p>fdbserver 的 cluster controller 在执行完 cluster recovery 后，会启动一个 actor <code class="language-plaintext highlighter-rouge">configurationMonitor</code> （<code class="language-plaintext highlighter-rouge">fdbserver/ClusterRecovery.actor.cpp</code>）监听 <code class="language-plaintext highlighter-rouge">excludedServersVersionKey</code> 的变化。一旦发生变化，则重新读取 <code class="language-plaintext highlighter-rouge">DatabaseConfiguration</code>，当其与内存中记录的 configuration 不同时触发 registration：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RangeResult</span> <span class="n">results</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">getRange</span><span class="p">(</span><span class="n">configKeys</span><span class="p">,</span> <span class="n">CLIENT_KNOBS</span><span class="o">-&gt;</span><span class="n">TOO_MANY</span><span class="p">));</span>
<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">results</span><span class="p">.</span><span class="n">more</span> <span class="o">&amp;&amp;</span> <span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">CLIENT_KNOBS</span><span class="o">-&gt;</span><span class="n">TOO_MANY</span><span class="p">);</span>

<span class="n">DatabaseConfiguration</span> <span class="n">conf</span><span class="p">;</span>
<span class="n">conf</span><span class="p">.</span><span class="n">fromKeyValues</span><span class="p">((</span><span class="n">VectorRef</span><span class="o">&lt;</span><span class="n">KeyValueRef</span><span class="o">&gt;</span><span class="p">)</span><span class="n">results</span><span class="p">);</span>
<span class="n">TraceEvent</span><span class="p">(</span><span class="s">"ConfigurationMonitor"</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dbgid</span><span class="p">)</span>
    <span class="p">.</span><span class="n">detail</span><span class="p">(</span><span class="n">getRecoveryEventName</span><span class="p">(</span><span class="n">ClusterRecoveryEventType</span><span class="o">::</span><span class="n">CLUSTER_RECOVERY_STATE_EVENT_NAME</span><span class="p">).</span><span class="n">c_str</span><span class="p">(),</span>
            <span class="n">self</span><span class="o">-&gt;</span><span class="n">recoveryState</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">conf</span> <span class="o">!=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">configuration</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">recoveryState</span> <span class="o">!=</span> <span class="n">RecoveryState</span><span class="o">::</span><span class="n">ALL_LOGS_RECRUITED</span> <span class="o">&amp;&amp;</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">recoveryState</span> <span class="o">!=</span> <span class="n">RecoveryState</span><span class="o">::</span><span class="n">FULLY_RECOVERED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">controllerData</span><span class="o">-&gt;</span><span class="n">shouldCommitSuicide</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">throw</span> <span class="n">restart_cluster_controller</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">self</span><span class="o">-&gt;</span><span class="n">configuration</span> <span class="o">=</span> <span class="n">conf</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">registrationTrigger</span><span class="p">.</span><span class="n">trigger</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另一个 actor <code class="language-plaintext highlighter-rouge">updateRegistration</code> 会等待 <code class="language-plaintext highlighter-rouge">registrationTrigger</code>，最后调用 <code class="language-plaintext highlighter-rouge">sendMasterRegistration</code> ；后者将新的 configuration 通过 <code class="language-plaintext highlighter-rouge">RegisterMasterRequest</code> 发送给 cluster controller。</p>

<p>Cluster controller 的 <code class="language-plaintext highlighter-rouge">clusterRegisterMaster</code>(<code class="language-plaintext highlighter-rouge">fdbserver/ClusterController.actor.cpp</code>) 负责处理 <code class="language-plaintext highlighter-rouge">RegisterMasterRequest</code> 。对于每一个 worker，cluster controller 会将其信息记录在 <code class="language-plaintext highlighter-rouge">WorkerInfo</code> 中；<code class="language-plaintext highlighter-rouge">WorkerInfo</code> 的成员 <code class="language-plaintext highlighter-rouge">priorityInfo</code> 中记录了 <code class="language-plaintext highlighter-rouge">isExcluded</code> 字段，表示是否通过 <code class="language-plaintext highlighter-rouge">exclude</code> 命令标记。<code class="language-plaintext highlighter-rouge">clusterRegisterMaster</code> 会遍历 <code class="language-plaintext highlighter-rouge">RegisterMasterRequest</code> 中携带的 configuration，并将 excluded 的 server 标记为 <code class="language-plaintext highlighter-rouge">isExcluded = true</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">db</span><span class="o">-&gt;</span><span class="n">fullyRecoveredConfig</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">configuration</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">it</span> <span class="o">:</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">id_worker</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">isExcludedFromConfig</span> <span class="o">=</span>
        <span class="n">db</span><span class="o">-&gt;</span><span class="n">fullyRecoveredConfig</span><span class="p">.</span><span class="n">isExcludedServer</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">details</span><span class="p">.</span><span class="n">interf</span><span class="p">.</span><span class="n">addresses</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">priorityInfo</span><span class="p">.</span><span class="n">isExcluded</span> <span class="o">!=</span> <span class="n">isExcludedFromConfig</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">priorityInfo</span><span class="p">.</span><span class="n">isExcluded</span> <span class="o">=</span> <span class="n">isExcludedFromConfig</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">reply</span><span class="p">.</span><span class="n">isSet</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">reply</span><span class="p">.</span><span class="n">send</span><span class="p">(</span>
                <span class="n">RegisterWorkerReply</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">details</span><span class="p">.</span><span class="n">processClass</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">priorityInfo</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="执行-recruit">执行 recruit</h2>

<p>除了标记 <code class="language-plaintext highlighter-rouge">isExcluded</code> 外，<code class="language-plaintext highlighter-rouge">clusterRegisterMaster</code> 还会启动一个 actor <code class="language-plaintext highlighter-rouge">doCheckOutstandingRequests</code>（<code class="language-plaintext highlighter-rouge">fdbserver/ClusterController.actor.cpp</code>）；后者会调用 <code class="language-plaintext highlighter-rouge">ClusterControllerData::betterMasterExists</code>：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">betterMasterExists</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">forceMasterFailure</span><span class="p">.</span><span class="n">trigger</span><span class="p">();</span>
    <span class="n">TraceEvent</span><span class="p">(</span><span class="s">"MasterRegistrationKill"</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">).</span><span class="n">detail</span><span class="p">(</span><span class="s">"MasterId"</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">serverInfo</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">().</span><span class="n">master</span><span class="p">.</span><span class="n">id</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">betterMasterExists</code> 会依次遍历 TLog, commit proxy, GRV proxy, resolver，任何一个 process 所在的 worker 的 <code class="language-plaintext highlighter-rouge">isExcluded</code> 为 <code class="language-plaintext highlighter-rouge">true</code>，都会返回 <code class="language-plaintext highlighter-rouge">true</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (commitProxyWorker-&gt;second.priorityInfo.isExcluded) {
    TraceEvent("BetterMasterExists", id)
        .detail("Reason", "CommitProxyExcluded")
        .detail("ProcessID", it.processId);
    return true;
}
</code></pre></div></div>

<p>最后 <code class="language-plaintext highlighter-rouge">forceMasterFailure</code> 会唤醒 <code class="language-plaintext highlighter-rouge">clusterWatchDatabase</code> ，后者做一些当前 epoch 的清理工作后，重新调用：<code class="language-plaintext highlighter-rouge">clusterRecoveryCore</code> 启动新阶段的 transaction system。</p>

<h2 id="storage-会迁移吗">Storage 会迁移吗？</h2>

<p>fdbserver 还有一个 <code class="language-plaintext highlighter-rouge">ExclusionTracker</code>，它负责监听 <code class="language-plaintext highlighter-rouge">excludedServersVersionKey</code>（<code class="language-plaintext highlighter-rouge">fdbserver/include/fdbserver/ExclusionTracker.actor.h</code>)。一旦 excluded servers 发生变化，它会唤醒 ACTOR <code class="language-plaintext highlighter-rouge">trackExcludedServers</code> (<code class="language-plaintext highlighter-rouge">fdbserver/DDTeamCollection.actor.cpp</code>)；后者最终会唤醒 <code class="language-plaintext highlighter-rouge">DDTeamCollectionImpl::storageRecruiter</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ACTOR</span> <span class="k">static</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">trackExcludedServers</span><span class="p">(</span><span class="n">DDTeamCollection</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">state</span> <span class="n">ExclusionTracker</span> <span class="n">exclusionTracker</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dbContext</span><span class="p">());</span>
    <span class="n">loop</span> <span class="p">{</span>
        <span class="c1">// wait for new set of excluded servers</span>
        <span class="n">wait</span><span class="p">(</span><span class="n">exclusionTracker</span><span class="p">.</span><span class="n">changed</span><span class="p">.</span><span class="n">onTrigger</span><span class="p">());</span>

        <span class="k">auto</span> <span class="n">old</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">getKeys</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">o</span> <span class="o">:</span> <span class="n">old</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exclusionTracker</span><span class="p">.</span><span class="n">excluded</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">exclusionTracker</span><span class="p">.</span><span class="n">failed</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                <span class="o">!</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                  <span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">==</span> <span class="n">DDTeamCollection</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">WIGGLING</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">DDTeamCollection</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">NONE</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">n</span> <span class="o">:</span> <span class="n">exclusionTracker</span><span class="p">.</span><span class="n">excluded</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exclusionTracker</span><span class="p">.</span><span class="n">failed</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">DDTeamCollection</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">EXCLUDED</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="p">...</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">restartRecruiting</span><span class="p">.</span><span class="n">trigger</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">storageRecruiter</code> 会收集信息并发送 <code class="language-plaintext highlighter-rouge">RecruitStorageRequest</code> 给 cluster controller:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">AddressExclusion</span><span class="o">&gt;</span> <span class="n">exclusions</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">excl</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">getKeys</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">s</span> <span class="o">:</span> <span class="n">excl</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DDTeamCollection</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">TraceEvent</span><span class="p">(</span><span class="n">SevDebug</span><span class="p">,</span> <span class="s">"DDRecruitExcl2"</span><span class="p">)</span>
            <span class="p">.</span><span class="n">detail</span><span class="p">(</span><span class="s">"Primary"</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">primary</span><span class="p">)</span>
            <span class="p">.</span><span class="n">detail</span><span class="p">(</span><span class="s">"Excluding"</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">toString</span><span class="p">());</span>
        <span class="n">exclusions</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">:</span> <span class="n">exclusions</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rsr</span><span class="p">.</span><span class="n">excludeAddresses</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fCandidateWorker</span><span class="p">.</span><span class="n">isValid</span><span class="p">()</span> <span class="o">||</span> <span class="n">fCandidateWorker</span><span class="p">.</span><span class="n">isReady</span><span class="p">()</span> <span class="o">||</span>
    <span class="n">rsr</span><span class="p">.</span><span class="n">excludeAddresses</span> <span class="o">!=</span> <span class="n">lastRequest</span><span class="p">.</span><span class="n">excludeAddresses</span> <span class="o">||</span>
    <span class="n">rsr</span><span class="p">.</span><span class="n">criticalRecruitment</span> <span class="o">!=</span> <span class="n">lastRequest</span><span class="p">.</span><span class="n">criticalRecruitment</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lastRequest</span> <span class="o">=</span> <span class="n">rsr</span><span class="p">;</span>
    <span class="n">fCandidateWorker</span> <span class="o">=</span>
        <span class="n">brokenPromiseToNever</span><span class="p">(</span><span class="n">recruitStorage</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">().</span><span class="n">getReply</span><span class="p">(</span><span class="n">rsr</span><span class="p">,</span> <span class="n">TaskPriority</span><span class="o">::</span><span class="n">DataDistribution</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>前边设置好的 exclude 会被放到请求的 <code class="language-plaintext highlighter-rouge">excludeAddresses</code> 字段中。cluster controller 会根据请求条件过滤掉不合适的 worker（<code class="language-plaintext highlighter-rouge">fdbserver/include/fdbserver/ClusterController.actor.h</code>:<code class="language-plaintext highlighter-rouge">ClusterControllerData::getStorageWorker</code>）。收到 response 后，<code class="language-plaintext highlighter-rouge">storageRecruiter</code> 会发送 <code class="language-plaintext highlighter-rouge">InitialStorageRequest</code> 给目标进程，完成 recruit 流程。</p>

<p>可以发现，这个过程中并没有判断 storage process 的 failure status，而是直接发送 <code class="language-plaintext highlighter-rouge">RecruitStorageRequest</code>。那么这就意味着不能手动临时 exclude 任何一个 storage，否则都会触发数据迁移。</p>

<h1 id="结论">结论</h1>

<p>通过分析，<code class="language-plaintext highlighter-rouge">exclude</code> 命令的确可以主动触发 recruit 流程，同时如果 process 上有 storage role，它还出触发 recruit storage 流程。</p>

<p>如果我们现在需要取得平滑升级的能力，那么需要以下几个步骤：</p>

<ol>
  <li>列出所有的 process 的 role，如果目标机器上某个 process 有 transaction system 的 role （非 coordinator，非 storage），那么执行 <code class="language-plaintext highlighter-rouge">exclude $IP:$PORT</code></li>
  <li>等到 recovery 完成后，执行 <code class="language-plaintext highlighter-rouge">maintenance on $zone-id</code>，表示禁用 storage process 的 failure detector</li>
  <li>修改配置、重启</li>
  <li>执行 <code class="language-plaintext highlighter-rouge">maintenance off</code></li>
  <li>执行 <code class="language-plaintext highlighter-rouge">include $IP:$PORT</code>，允许 transaction system 的 role 调度回该机器</li>
</ol>


  </div><a class="u-url" href="/2023/07/20/FDB-exclude-cmd.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">W41ter&#39;s Bistro</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">W41ter&#39;s Bistro</li><li><a class="u-email" href="mailto:w41ter.l@gmail.com">w41ter.l@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/w41ter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">w41ter</span></a></li><li><a href="https://www.twitter.com/WalterM56697798"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WalterM56697798</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Focus on distributed storage system, compiler.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
