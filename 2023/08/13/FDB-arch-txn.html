<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>FoundationDB 架构 - 写事务处理流程 | W41ter’s Bistro</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="FoundationDB 架构 - 写事务处理流程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="前一篇文章 FoundationDB 架构概述 从全局视角介绍了 FoundationDB 架构的特点，这篇文章将介绍 FoundationDB 写事务的处理流程以及各个组件间是如何沟通协作的。 Open Database 在与 FoundationDB 集群交互前，client 需要先执行 open database。 执行 open database 时，client 会从 fdb.cluster 文件中获取 connection string，后者指向了集群中的 coordinators；client 发送 OpenDatabaseCoordRequest 请求给 coordinator 进行验证，并获取 ClientDBInfo。 ClientDBInfo 中记录了集群中 GRV proxy 和 Commit proxy 的地址，后续的写请求会用到这两个 proxy 的地址。 提交事务 FoundationDB 依赖一个全局单调递增的时间戳来提供多版本并发控制。每个事务提交时，会分配一个新的版本（Version）；事务间按照 version 大小确定唯一的提交顺序。 FoundationDB 支持交互式事务，开启事务时会获取之前已经提交的最大的事务 version，并在一段时间后才会提交，所以事务间可能存在冲突。FoundationDB 通过检测事务间的 read-write confliction 来避免快照隔离（snapshot isolation, si）带来的 write skew，从而取得序列化快照隔离（serializable snapshot isolation, ssi）。 上述实现又称 write snapshot isolation, 出处见论文： A critique of snapshot isolation。 最后，可以提交的事务会写入 TLog 中完成持久化，再异步地发送到存储系统中。 上图展示了一个写事务提交的完整交互流程，接下来将按照上图详细分析各个流程。 开启新事务时，需要确定新事务的可见范围，也就是当前事务执行时有哪些事务已经提交。为此，Client 会发送 GetReadVersionRequest 给 GRV proxy 以查询已经提交的最大的事务 version；后者积攒一批请求后，发送 GetRawCommitVersionRequest 给 Master 节点，查询记录在 Master 内存中的已经提交的最大的事务 version。 之后的任何写入操作会暂存在 client 的内存中，同时记录下读请求的范围供后续检测事务间的冲突。（读事务的处理流程将在后续的文章中介绍。） 暂存在 client 内存中的数据在提交时通过 CommitTransactionRequest 发送给 Commit proxy，后者将提交过程分成几个步骤： 获取 commit version 解决事务冲突 持久化改动 响应事务提交结果 获取 commit version Commit proxy 积攒一批请求后，发送 GetCommitVersionRequest 给 Master 以获取一个新的提交 version 以及确定事务间的顺序。Master 内存中记录着上一次分配（前一个事务）的 commit version，在上一次的基础上按照时间间隔分配一个新的 version。由于 Master 分配的 version 的大小和时间也有一定关系，所以 GetCommitVersionReply 中会携带前一个事务的 commit version（prev commit version） 和新分配的 commit version。 拿到新 commit version 后，commit proxy 会按照顺序给这一批事务分配 versionstamp，它由两部分组成 &lt;commit version, group id&gt;，其中 group id 是事务在本批次队列中的序号。 FoundationDB 的原子操作中支持将 key 或者 value 的某部分替换成 versionstamp，用于在 client 侧确定一个唯一的事务，分配 versionstamp 的意义就在此。 分配好 versionstamp 后，Commit proxy 会检查每个事务的改动（mutation），并替换掉其中需要设置 versionstamp 的部分 mutation。 解决事务冲突 Resolver 负责解决事务冲突，Commit proxy 会将事务的 read ranges 和 write ranges 以及事务的 prev commit version，commit version 一起通过 ResolveTransactionBatchRequest 发送给 Resolver 。 Resolver 会按照事务 version 顺序处理每个到达请求，事务间的顺序依靠 prev commit version 和 commit version 一起组织起来。如果事务与之前已经提交的事务不存在 read-write confliction，那么就可以提交；否则事务应该被拒绝。 持久化 mutation 解决事务间冲突后，需要将 mutations 通过 TLogCommitRequest 发送给 TLog 完成持久化。集群中可能有多个 TLog 实例，那么这些 mutations 会被发送给每一个 TLog，所有 TLog 完成持久化后，事务才算完成提交。（实际上 mutations 只会发送给一部分 TLog，剩余的只会发送一个空请求，这部分将在后续的文章中介绍） 如果某个事务被拒绝提交，那么它的 mutations 不会被发送到 TLog 持久化。由于 TLog 也是按照事务的 version 顺序依次持久化，所以尽管某一批事务请求都拒绝，Commit proxy 仍然需要发送 TLogCommitRequest 给 TLog ，这样 TLog 才能知道何时可以持久化后续的 mutations。 响应事务提交结果 一旦事务的 mutations 成功持久化到 TLog 后，就算完成了提交请求，但是在回复 client 前，Commit proxy 还需要发送 ReportRawCommittedRequest 给 Master 以更新后者内存中记录的最大的已提交事务的 version。所以，FoundationDB 保证如果 client 收到了提交事务的回复，那么它再开启的新事务一定能够读取到此前已经提交的数据。 异步 apply mutations 存储系统中的 Storage 会发送 TLogPeek 请求，从 TLog 中获取新写入的 mutations，并完成 apply。 到此为止，整个提交事务的流程就介绍完了。其中的一些细节，比如事务冲突处理、TLog 如何持久化 mutations，将在后续的文章中一一介绍。" />
<meta property="og:description" content="前一篇文章 FoundationDB 架构概述 从全局视角介绍了 FoundationDB 架构的特点，这篇文章将介绍 FoundationDB 写事务的处理流程以及各个组件间是如何沟通协作的。 Open Database 在与 FoundationDB 集群交互前，client 需要先执行 open database。 执行 open database 时，client 会从 fdb.cluster 文件中获取 connection string，后者指向了集群中的 coordinators；client 发送 OpenDatabaseCoordRequest 请求给 coordinator 进行验证，并获取 ClientDBInfo。 ClientDBInfo 中记录了集群中 GRV proxy 和 Commit proxy 的地址，后续的写请求会用到这两个 proxy 的地址。 提交事务 FoundationDB 依赖一个全局单调递增的时间戳来提供多版本并发控制。每个事务提交时，会分配一个新的版本（Version）；事务间按照 version 大小确定唯一的提交顺序。 FoundationDB 支持交互式事务，开启事务时会获取之前已经提交的最大的事务 version，并在一段时间后才会提交，所以事务间可能存在冲突。FoundationDB 通过检测事务间的 read-write confliction 来避免快照隔离（snapshot isolation, si）带来的 write skew，从而取得序列化快照隔离（serializable snapshot isolation, ssi）。 上述实现又称 write snapshot isolation, 出处见论文： A critique of snapshot isolation。 最后，可以提交的事务会写入 TLog 中完成持久化，再异步地发送到存储系统中。 上图展示了一个写事务提交的完整交互流程，接下来将按照上图详细分析各个流程。 开启新事务时，需要确定新事务的可见范围，也就是当前事务执行时有哪些事务已经提交。为此，Client 会发送 GetReadVersionRequest 给 GRV proxy 以查询已经提交的最大的事务 version；后者积攒一批请求后，发送 GetRawCommitVersionRequest 给 Master 节点，查询记录在 Master 内存中的已经提交的最大的事务 version。 之后的任何写入操作会暂存在 client 的内存中，同时记录下读请求的范围供后续检测事务间的冲突。（读事务的处理流程将在后续的文章中介绍。） 暂存在 client 内存中的数据在提交时通过 CommitTransactionRequest 发送给 Commit proxy，后者将提交过程分成几个步骤： 获取 commit version 解决事务冲突 持久化改动 响应事务提交结果 获取 commit version Commit proxy 积攒一批请求后，发送 GetCommitVersionRequest 给 Master 以获取一个新的提交 version 以及确定事务间的顺序。Master 内存中记录着上一次分配（前一个事务）的 commit version，在上一次的基础上按照时间间隔分配一个新的 version。由于 Master 分配的 version 的大小和时间也有一定关系，所以 GetCommitVersionReply 中会携带前一个事务的 commit version（prev commit version） 和新分配的 commit version。 拿到新 commit version 后，commit proxy 会按照顺序给这一批事务分配 versionstamp，它由两部分组成 &lt;commit version, group id&gt;，其中 group id 是事务在本批次队列中的序号。 FoundationDB 的原子操作中支持将 key 或者 value 的某部分替换成 versionstamp，用于在 client 侧确定一个唯一的事务，分配 versionstamp 的意义就在此。 分配好 versionstamp 后，Commit proxy 会检查每个事务的改动（mutation），并替换掉其中需要设置 versionstamp 的部分 mutation。 解决事务冲突 Resolver 负责解决事务冲突，Commit proxy 会将事务的 read ranges 和 write ranges 以及事务的 prev commit version，commit version 一起通过 ResolveTransactionBatchRequest 发送给 Resolver 。 Resolver 会按照事务 version 顺序处理每个到达请求，事务间的顺序依靠 prev commit version 和 commit version 一起组织起来。如果事务与之前已经提交的事务不存在 read-write confliction，那么就可以提交；否则事务应该被拒绝。 持久化 mutation 解决事务间冲突后，需要将 mutations 通过 TLogCommitRequest 发送给 TLog 完成持久化。集群中可能有多个 TLog 实例，那么这些 mutations 会被发送给每一个 TLog，所有 TLog 完成持久化后，事务才算完成提交。（实际上 mutations 只会发送给一部分 TLog，剩余的只会发送一个空请求，这部分将在后续的文章中介绍） 如果某个事务被拒绝提交，那么它的 mutations 不会被发送到 TLog 持久化。由于 TLog 也是按照事务的 version 顺序依次持久化，所以尽管某一批事务请求都拒绝，Commit proxy 仍然需要发送 TLogCommitRequest 给 TLog ，这样 TLog 才能知道何时可以持久化后续的 mutations。 响应事务提交结果 一旦事务的 mutations 成功持久化到 TLog 后，就算完成了提交请求，但是在回复 client 前，Commit proxy 还需要发送 ReportRawCommittedRequest 给 Master 以更新后者内存中记录的最大的已提交事务的 version。所以，FoundationDB 保证如果 client 收到了提交事务的回复，那么它再开启的新事务一定能够读取到此前已经提交的数据。 异步 apply mutations 存储系统中的 Storage 会发送 TLogPeek 请求，从 TLog 中获取新写入的 mutations，并完成 apply。 到此为止，整个提交事务的流程就介绍完了。其中的一些细节，比如事务冲突处理、TLog 如何持久化 mutations，将在后续的文章中一一介绍。" />
<link rel="canonical" href="/2023/08/13/FDB-arch-txn.html" />
<meta property="og:url" content="/2023/08/13/FDB-arch-txn.html" />
<meta property="og:site_name" content="W41ter’s Bistro" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-08-13T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="FoundationDB 架构 - 写事务处理流程" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-08-13T00:00:00+08:00","datePublished":"2023-08-13T00:00:00+08:00","description":"前一篇文章 FoundationDB 架构概述 从全局视角介绍了 FoundationDB 架构的特点，这篇文章将介绍 FoundationDB 写事务的处理流程以及各个组件间是如何沟通协作的。 Open Database 在与 FoundationDB 集群交互前，client 需要先执行 open database。 执行 open database 时，client 会从 fdb.cluster 文件中获取 connection string，后者指向了集群中的 coordinators；client 发送 OpenDatabaseCoordRequest 请求给 coordinator 进行验证，并获取 ClientDBInfo。 ClientDBInfo 中记录了集群中 GRV proxy 和 Commit proxy 的地址，后续的写请求会用到这两个 proxy 的地址。 提交事务 FoundationDB 依赖一个全局单调递增的时间戳来提供多版本并发控制。每个事务提交时，会分配一个新的版本（Version）；事务间按照 version 大小确定唯一的提交顺序。 FoundationDB 支持交互式事务，开启事务时会获取之前已经提交的最大的事务 version，并在一段时间后才会提交，所以事务间可能存在冲突。FoundationDB 通过检测事务间的 read-write confliction 来避免快照隔离（snapshot isolation, si）带来的 write skew，从而取得序列化快照隔离（serializable snapshot isolation, ssi）。 上述实现又称 write snapshot isolation, 出处见论文： A critique of snapshot isolation。 最后，可以提交的事务会写入 TLog 中完成持久化，再异步地发送到存储系统中。 上图展示了一个写事务提交的完整交互流程，接下来将按照上图详细分析各个流程。 开启新事务时，需要确定新事务的可见范围，也就是当前事务执行时有哪些事务已经提交。为此，Client 会发送 GetReadVersionRequest 给 GRV proxy 以查询已经提交的最大的事务 version；后者积攒一批请求后，发送 GetRawCommitVersionRequest 给 Master 节点，查询记录在 Master 内存中的已经提交的最大的事务 version。 之后的任何写入操作会暂存在 client 的内存中，同时记录下读请求的范围供后续检测事务间的冲突。（读事务的处理流程将在后续的文章中介绍。） 暂存在 client 内存中的数据在提交时通过 CommitTransactionRequest 发送给 Commit proxy，后者将提交过程分成几个步骤： 获取 commit version 解决事务冲突 持久化改动 响应事务提交结果 获取 commit version Commit proxy 积攒一批请求后，发送 GetCommitVersionRequest 给 Master 以获取一个新的提交 version 以及确定事务间的顺序。Master 内存中记录着上一次分配（前一个事务）的 commit version，在上一次的基础上按照时间间隔分配一个新的 version。由于 Master 分配的 version 的大小和时间也有一定关系，所以 GetCommitVersionReply 中会携带前一个事务的 commit version（prev commit version） 和新分配的 commit version。 拿到新 commit version 后，commit proxy 会按照顺序给这一批事务分配 versionstamp，它由两部分组成 &lt;commit version, group id&gt;，其中 group id 是事务在本批次队列中的序号。 FoundationDB 的原子操作中支持将 key 或者 value 的某部分替换成 versionstamp，用于在 client 侧确定一个唯一的事务，分配 versionstamp 的意义就在此。 分配好 versionstamp 后，Commit proxy 会检查每个事务的改动（mutation），并替换掉其中需要设置 versionstamp 的部分 mutation。 解决事务冲突 Resolver 负责解决事务冲突，Commit proxy 会将事务的 read ranges 和 write ranges 以及事务的 prev commit version，commit version 一起通过 ResolveTransactionBatchRequest 发送给 Resolver 。 Resolver 会按照事务 version 顺序处理每个到达请求，事务间的顺序依靠 prev commit version 和 commit version 一起组织起来。如果事务与之前已经提交的事务不存在 read-write confliction，那么就可以提交；否则事务应该被拒绝。 持久化 mutation 解决事务间冲突后，需要将 mutations 通过 TLogCommitRequest 发送给 TLog 完成持久化。集群中可能有多个 TLog 实例，那么这些 mutations 会被发送给每一个 TLog，所有 TLog 完成持久化后，事务才算完成提交。（实际上 mutations 只会发送给一部分 TLog，剩余的只会发送一个空请求，这部分将在后续的文章中介绍） 如果某个事务被拒绝提交，那么它的 mutations 不会被发送到 TLog 持久化。由于 TLog 也是按照事务的 version 顺序依次持久化，所以尽管某一批事务请求都拒绝，Commit proxy 仍然需要发送 TLogCommitRequest 给 TLog ，这样 TLog 才能知道何时可以持久化后续的 mutations。 响应事务提交结果 一旦事务的 mutations 成功持久化到 TLog 后，就算完成了提交请求，但是在回复 client 前，Commit proxy 还需要发送 ReportRawCommittedRequest 给 Master 以更新后者内存中记录的最大的已提交事务的 version。所以，FoundationDB 保证如果 client 收到了提交事务的回复，那么它再开启的新事务一定能够读取到此前已经提交的数据。 异步 apply mutations 存储系统中的 Storage 会发送 TLogPeek 请求，从 TLog 中获取新写入的 mutations，并完成 apply。 到此为止，整个提交事务的流程就介绍完了。其中的一些细节，比如事务冲突处理、TLog 如何持久化 mutations，将在后续的文章中一一介绍。","headline":"FoundationDB 架构 - 写事务处理流程","mainEntityOfPage":{"@type":"WebPage","@id":"/2023/08/13/FDB-arch-txn.html"},"url":"/2023/08/13/FDB-arch-txn.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="W41ter's Bistro" /><!-- for mathjax support -->
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          extensions: [
          "tex2jax.js",
          "MathMenu.js",
          "MathZoom.js",
          "AssistiveMML.js",
          "a11y/accessibility-menu.js"
        ],
        tex2jax: {      // AND HERE
          inlineMath: [['$', '$']],
          displayMath: [['$$', '$$']]
        },
        jax: ["input/TeX", "output/CommonHTML"],
        TeX: {
          extensions: [
            "AMSmath.js",
            "AMSsymbols.js",
            "noErrors.js",
            "noUndefined.js",
          ],
          equationNumbers: { autoNumber: "AMS" }
        }
      });
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">W41ter&#39;s Bistro</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">FoundationDB 架构 - 写事务处理流程</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-08-13T00:00:00+08:00" itemprop="datePublished">Aug 13, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>前一篇文章 <a href="https://mp.weixin.qq.com/s?__biz=MzU4ODgyOTg5NA==&amp;mid=2247483697&amp;idx=1&amp;sn=7ad949ecc5f298b2061d1a4066e2572c&amp;chksm=fdd78498caa00d8e8df55fa70b3b364edd0e8e688efa03dc8d1110d46a16cda455aa50b7eaf3#rd">FoundationDB 架构概述</a> 从全局视角介绍了 FoundationDB 架构的特点，这篇文章将介绍 FoundationDB 写事务的处理流程以及各个组件间是如何沟通协作的。</p>

<h2 id="open-database">Open Database</h2>

<p>在与 FoundationDB 集群交互前，client 需要先执行 open database。</p>

<p><img src="FDB-arch-txn-imgs/open-database.png" alt="Open Database" /></p>

<p>执行 open database 时，client 会从 <code class="language-plaintext highlighter-rouge">fdb.cluster</code> 文件中获取 <code class="language-plaintext highlighter-rouge">connection string</code>，后者指向了集群中的 coordinators；client 发送 <code class="language-plaintext highlighter-rouge">OpenDatabaseCoordRequest</code> 请求给 coordinator 进行验证，并获取 <code class="language-plaintext highlighter-rouge">ClientDBInfo</code>。</p>

<p><code class="language-plaintext highlighter-rouge">ClientDBInfo</code> 中记录了集群中 GRV proxy 和 Commit proxy 的地址，后续的写请求会用到这两个 proxy 的地址。</p>

<h2 id="提交事务">提交事务</h2>

<p>FoundationDB 依赖一个全局单调递增的时间戳来提供多版本并发控制。每个事务提交时，会分配一个新的版本（Version）；事务间按照 version 大小确定唯一的提交顺序。</p>

<p>FoundationDB 支持交互式事务，开启事务时会获取之前已经提交的最大的事务 version，并在一段时间后才会提交，所以事务间可能存在冲突。FoundationDB 通过检测事务间的 read-write confliction 来避免快照隔离（snapshot isolation, si）带来的 write skew，从而取得序列化快照隔离（serializable snapshot isolation, ssi）。</p>

<blockquote>
  <p>上述实现又称 write snapshot isolation, 出处见论文： A critique of snapshot isolation。</p>
</blockquote>

<p>最后，可以提交的事务会写入 TLog 中完成持久化，再异步地发送到存储系统中。</p>

<p><img src="FDB-arch-txn-imgs/commit-txn.png" alt="Commit Transaction" /></p>

<p>上图展示了一个写事务提交的完整交互流程，接下来将按照上图详细分析各个流程。</p>

<p>开启新事务时，需要确定新事务的可见范围，也就是当前事务执行时有哪些事务已经提交。为此，Client 会发送 <code class="language-plaintext highlighter-rouge">GetReadVersionRequest</code> 给 GRV proxy 以查询已经提交的最大的事务 version；后者积攒一批请求后，发送 <code class="language-plaintext highlighter-rouge">GetRawCommitVersionRequest</code> 给 Master 节点，查询记录在 Master 内存中的已经提交的最大的事务 version。</p>

<p>之后的任何写入操作会暂存在 client 的内存中，同时记录下读请求的范围供后续检测事务间的冲突。（读事务的处理流程将在后续的文章中介绍。）</p>

<p>暂存在 client 内存中的数据在提交时通过 <code class="language-plaintext highlighter-rouge">CommitTransactionRequest</code> 发送给 Commit proxy，后者将提交过程分成几个步骤：</p>

<ol>
  <li>获取 commit version</li>
  <li>解决事务冲突</li>
  <li>持久化改动</li>
  <li>响应事务提交结果</li>
</ol>

<h3 id="获取-commit-version">获取 commit version</h3>

<p>Commit proxy 积攒一批请求后，发送 <code class="language-plaintext highlighter-rouge">GetCommitVersionRequest</code> 给 Master 以获取一个新的提交 version 以及确定事务间的顺序。Master 内存中记录着上一次分配（前一个事务）的 commit version，在上一次的基础上按照时间间隔分配一个新的 version。由于 Master 分配的 version 的大小和时间也有一定关系，所以 <code class="language-plaintext highlighter-rouge">GetCommitVersionReply</code> 中会携带前一个事务的 commit version（prev commit version） 和新分配的 commit version。</p>

<p>拿到新 commit version 后，commit proxy 会按照顺序给这一批事务分配 versionstamp，它由两部分组成 <code class="language-plaintext highlighter-rouge">&lt;commit version, group id&gt;</code>，其中 group id 是事务在本批次队列中的序号。</p>

<blockquote>
  <p>FoundationDB 的原子操作中支持将 key 或者 value 的某部分替换成 versionstamp，用于在 client 侧确定一个唯一的事务，分配 versionstamp 的意义就在此。</p>
</blockquote>

<p>分配好 versionstamp 后，Commit proxy 会检查每个事务的改动（mutation），并替换掉其中需要设置 versionstamp 的部分 mutation。</p>

<h3 id="解决事务冲突">解决事务冲突</h3>

<p>Resolver 负责解决事务冲突，Commit proxy 会将事务的 read ranges 和 write ranges 以及事务的 prev commit version，commit version 一起通过 <code class="language-plaintext highlighter-rouge">ResolveTransactionBatchRequest</code> 发送给 Resolver 。</p>

<p>Resolver 会按照事务 version 顺序处理每个到达请求，事务间的顺序依靠 prev commit version 和 commit version 一起组织起来。如果事务与之前已经提交的事务不存在 read-write confliction，那么就可以提交；否则事务应该被拒绝。</p>

<h3 id="持久化-mutation">持久化 mutation</h3>

<p>解决事务间冲突后，需要将 mutations 通过 <code class="language-plaintext highlighter-rouge">TLogCommitRequest</code> 发送给 TLog 完成持久化。集群中可能有多个 TLog 实例，那么这些 mutations 会被发送给每一个 TLog，所有 TLog 完成持久化后，事务才算完成提交。（实际上 mutations 只会发送给一部分 TLog，剩余的只会发送一个空请求，这部分将在后续的文章中介绍）</p>

<p>如果某个事务被拒绝提交，那么它的 mutations 不会被发送到 TLog 持久化。由于 TLog 也是按照事务的 version 顺序依次持久化，所以尽管某一批事务请求都拒绝，Commit proxy 仍然需要发送 <code class="language-plaintext highlighter-rouge">TLogCommitRequest</code> 给 TLog ，这样 TLog 才能知道何时可以持久化后续的 mutations。</p>

<h3 id="响应事务提交结果">响应事务提交结果</h3>

<p>一旦事务的 mutations 成功持久化到 TLog 后，就算完成了提交请求，但是在回复 client 前，Commit proxy 还需要发送 <code class="language-plaintext highlighter-rouge">ReportRawCommittedRequest</code> 给 Master 以更新后者内存中记录的最大的已提交事务的 version。所以，FoundationDB 保证如果 client 收到了提交事务的回复，那么它再开启的新事务一定能够读取到此前已经提交的数据。</p>

<h3 id="异步-apply-mutations">异步 apply mutations</h3>

<p>存储系统中的 Storage 会发送 <code class="language-plaintext highlighter-rouge">TLogPeek</code> 请求，从 TLog 中获取新写入的 mutations，并完成 apply。</p>

<p>到此为止，整个提交事务的流程就介绍完了。其中的一些细节，比如事务冲突处理、TLog 如何持久化 mutations，将在后续的文章中一一介绍。</p>


  </div><a class="u-url" href="/2023/08/13/FDB-arch-txn.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">W41ter&#39;s Bistro</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">W41ter&#39;s Bistro</li><li><a class="u-email" href="mailto:w41ter.l@gmail.com">w41ter.l@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/w41ter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">w41ter</span></a></li><li><a href="https://www.twitter.com/WalterM56697798"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WalterM56697798</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Focus on distributed storage system, compiler.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
