<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>FoundationDB 架构 - 只读事务 | W41ter’s Bistro</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="FoundationDB 架构 - 只读事务" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="前一篇文章介绍了 FoundationDB 架构 - 事务数据的存储 FoundationDB 数据是如何存储的。这篇文章将介绍如何从 FoundationDB 中读取已写入的数据。 开启事务 同写事务相同，读事务开启时也需要先通过 GRV proxy 间接地从 master 获取已经提交事务的最大 version。因为写事务只需要将数据持久化到 TLog 就算完成，而 storage 拉取 message 的步骤并不在写事务提交的关键路径上。因此需要 client 在请求中携带上它能观察到的最大的 version，storage 才能通过这个 version 判断本地数据是否完整。 路由 Client 并不知道数据是如何分布在 storage 中以及每个 storage 的地址，它需要向 FoundationDB 集群查询 key 到 storage server 的路由项（称为 location）。 因为任何对 key 到 server 映射关系的变更操作都需要通过 commit proxy 持久化到 TLog 中（这部分细节将在后续的文章中介绍），所以 commit proxy 知晓整个集群的 location。Client 通过发送 GetKeyServerLocations 请求给 commit proxy 以查询 locations。 由于 location 变更是个低频操作，缓存 location 能够有效降低查询 commit proxy 的次数。每次发送请求前，client 都会先查询缓存，如果未命中才会向 commit proxy 请求 location；此外，如果 location 过期，那么 storage 会拒绝服务，这种情况下 client 会清理缓存，再次向 commit proxy 获取最新的 location。 读数据 拿到 location 后，client 会发送 getValue 请求给 storage。前一篇文章已经介绍了，storage 中的数据分为两部分，第一部分存在多版本窗口中，第二部分存在磁盘 key value store 中。 Storage 会先在内存中查找 key，如果未命中再从磁盘 key value 中读取。这里需要注意的是磁盘中的数据是没有版本信息的，所以无法判断这部分数据是否能够被指定版本的读请求读取到，因此如果一个请求携带的 version 已经超过了多版本窗口（默认为 5s），那么 storage 将返回 transaction too old，迫使 client 重新尝试。 另一个需要注意的情况是，如果 storage 收到请求时，还没有从 TLog 拉取到对应 version 的数据，那么 storage 会阻塞该请求，直到数据可以被访问。 到此，FoundationDB 事务的读写流程已经介绍完了。在后面的文章中，将介绍 FoundationDB 如何提供高可扩展的能力。" />
<meta property="og:description" content="前一篇文章介绍了 FoundationDB 架构 - 事务数据的存储 FoundationDB 数据是如何存储的。这篇文章将介绍如何从 FoundationDB 中读取已写入的数据。 开启事务 同写事务相同，读事务开启时也需要先通过 GRV proxy 间接地从 master 获取已经提交事务的最大 version。因为写事务只需要将数据持久化到 TLog 就算完成，而 storage 拉取 message 的步骤并不在写事务提交的关键路径上。因此需要 client 在请求中携带上它能观察到的最大的 version，storage 才能通过这个 version 判断本地数据是否完整。 路由 Client 并不知道数据是如何分布在 storage 中以及每个 storage 的地址，它需要向 FoundationDB 集群查询 key 到 storage server 的路由项（称为 location）。 因为任何对 key 到 server 映射关系的变更操作都需要通过 commit proxy 持久化到 TLog 中（这部分细节将在后续的文章中介绍），所以 commit proxy 知晓整个集群的 location。Client 通过发送 GetKeyServerLocations 请求给 commit proxy 以查询 locations。 由于 location 变更是个低频操作，缓存 location 能够有效降低查询 commit proxy 的次数。每次发送请求前，client 都会先查询缓存，如果未命中才会向 commit proxy 请求 location；此外，如果 location 过期，那么 storage 会拒绝服务，这种情况下 client 会清理缓存，再次向 commit proxy 获取最新的 location。 读数据 拿到 location 后，client 会发送 getValue 请求给 storage。前一篇文章已经介绍了，storage 中的数据分为两部分，第一部分存在多版本窗口中，第二部分存在磁盘 key value store 中。 Storage 会先在内存中查找 key，如果未命中再从磁盘 key value 中读取。这里需要注意的是磁盘中的数据是没有版本信息的，所以无法判断这部分数据是否能够被指定版本的读请求读取到，因此如果一个请求携带的 version 已经超过了多版本窗口（默认为 5s），那么 storage 将返回 transaction too old，迫使 client 重新尝试。 另一个需要注意的情况是，如果 storage 收到请求时，还没有从 TLog 拉取到对应 version 的数据，那么 storage 会阻塞该请求，直到数据可以被访问。 到此，FoundationDB 事务的读写流程已经介绍完了。在后面的文章中，将介绍 FoundationDB 如何提供高可扩展的能力。" />
<link rel="canonical" href="/2023/10/28/FDB-arch-read-txn.html" />
<meta property="og:url" content="/2023/10/28/FDB-arch-read-txn.html" />
<meta property="og:site_name" content="W41ter’s Bistro" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-10-28T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="FoundationDB 架构 - 只读事务" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-10-28T00:00:00+08:00","datePublished":"2023-10-28T00:00:00+08:00","description":"前一篇文章介绍了 FoundationDB 架构 - 事务数据的存储 FoundationDB 数据是如何存储的。这篇文章将介绍如何从 FoundationDB 中读取已写入的数据。 开启事务 同写事务相同，读事务开启时也需要先通过 GRV proxy 间接地从 master 获取已经提交事务的最大 version。因为写事务只需要将数据持久化到 TLog 就算完成，而 storage 拉取 message 的步骤并不在写事务提交的关键路径上。因此需要 client 在请求中携带上它能观察到的最大的 version，storage 才能通过这个 version 判断本地数据是否完整。 路由 Client 并不知道数据是如何分布在 storage 中以及每个 storage 的地址，它需要向 FoundationDB 集群查询 key 到 storage server 的路由项（称为 location）。 因为任何对 key 到 server 映射关系的变更操作都需要通过 commit proxy 持久化到 TLog 中（这部分细节将在后续的文章中介绍），所以 commit proxy 知晓整个集群的 location。Client 通过发送 GetKeyServerLocations 请求给 commit proxy 以查询 locations。 由于 location 变更是个低频操作，缓存 location 能够有效降低查询 commit proxy 的次数。每次发送请求前，client 都会先查询缓存，如果未命中才会向 commit proxy 请求 location；此外，如果 location 过期，那么 storage 会拒绝服务，这种情况下 client 会清理缓存，再次向 commit proxy 获取最新的 location。 读数据 拿到 location 后，client 会发送 getValue 请求给 storage。前一篇文章已经介绍了，storage 中的数据分为两部分，第一部分存在多版本窗口中，第二部分存在磁盘 key value store 中。 Storage 会先在内存中查找 key，如果未命中再从磁盘 key value 中读取。这里需要注意的是磁盘中的数据是没有版本信息的，所以无法判断这部分数据是否能够被指定版本的读请求读取到，因此如果一个请求携带的 version 已经超过了多版本窗口（默认为 5s），那么 storage 将返回 transaction too old，迫使 client 重新尝试。 另一个需要注意的情况是，如果 storage 收到请求时，还没有从 TLog 拉取到对应 version 的数据，那么 storage 会阻塞该请求，直到数据可以被访问。 到此，FoundationDB 事务的读写流程已经介绍完了。在后面的文章中，将介绍 FoundationDB 如何提供高可扩展的能力。","headline":"FoundationDB 架构 - 只读事务","mainEntityOfPage":{"@type":"WebPage","@id":"/2023/10/28/FDB-arch-read-txn.html"},"url":"/2023/10/28/FDB-arch-read-txn.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="W41ter's Bistro" /><!-- for mathjax support -->
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          extensions: [
          "tex2jax.js",
          "MathMenu.js",
          "MathZoom.js",
          "AssistiveMML.js",
          "a11y/accessibility-menu.js"
        ],
        tex2jax: {      // AND HERE
          inlineMath: [['$', '$']],
          displayMath: [['$$', '$$']]
        },
        jax: ["input/TeX", "output/CommonHTML"],
        TeX: {
          extensions: [
            "AMSmath.js",
            "AMSsymbols.js",
            "noErrors.js",
            "noUndefined.js",
          ],
          equationNumbers: { autoNumber: "AMS" }
        }
      });
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">W41ter&#39;s Bistro</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">FoundationDB 架构 - 只读事务</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-10-28T00:00:00+08:00" itemprop="datePublished">Oct 28, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>前一篇文章介绍了 <a href="https://mp.weixin.qq.com/s?__biz=MzU4ODgyOTg5NA==&amp;mid=2247483728&amp;idx=1&amp;sn=87b85f293fe91bc57f589a09be84b7a2&amp;chksm=fdd784f9caa00def578dfacc61ef7ba1ab31f64b87826c9f279bae385bf44022f9923e853dd6&amp;token=1055659193&amp;lang=zh_CN#rd">FoundationDB 架构 - 事务数据的存储</a> FoundationDB 数据是如何存储的。这篇文章将介绍如何从 FoundationDB 中读取已写入的数据。</p>

<p><img src="FDB-arch-read-txn-imgs/read-path.png" alt="读请求路径" /></p>

<h2 id="开启事务">开启事务</h2>

<p>同写事务相同，读事务开启时也需要先通过 GRV proxy 间接地从 master 获取已经提交事务的最大 version。因为写事务只需要将数据持久化到 TLog 就算完成，而 storage 拉取 message 的步骤并不在写事务提交的关键路径上。因此需要 client 在请求中携带上它能观察到的最大的 version，storage 才能通过这个 version 判断本地数据是否完整。</p>

<h2 id="路由">路由</h2>

<p>Client 并不知道数据是如何分布在 storage 中以及每个 storage 的地址，它需要向 FoundationDB 集群查询 key 到 storage server 的路由项（称为 location）。</p>

<p>因为任何对 key 到 server 映射关系的变更操作都需要通过 commit proxy 持久化到 TLog 中（这部分细节将在后续的文章中介绍），所以 commit proxy 知晓整个集群的 location。Client 通过发送 <code class="language-plaintext highlighter-rouge">GetKeyServerLocations</code> 请求给 commit proxy 以查询 locations。</p>

<p>由于 location 变更是个低频操作，缓存 location 能够有效降低查询 commit proxy 的次数。每次发送请求前，client 都会先查询缓存，如果未命中才会向 commit proxy 请求 location；此外，如果 location 过期，那么 storage 会拒绝服务，这种情况下 client 会清理缓存，再次向 commit proxy 获取最新的 location。</p>

<h2 id="读数据">读数据</h2>

<p>拿到 location 后，client 会发送 <code class="language-plaintext highlighter-rouge">getValue</code> 请求给 storage。前一篇文章已经介绍了，storage 中的数据分为两部分，第一部分存在多版本窗口中，第二部分存在磁盘 key value store 中。</p>

<p>Storage 会先在内存中查找 key，如果未命中再从磁盘 key value 中读取。这里需要注意的是磁盘中的数据是没有版本信息的，所以无法判断这部分数据是否能够被指定版本的读请求读取到，因此如果一个请求携带的 version 已经超过了多版本窗口（默认为 5s），那么 storage 将返回 transaction too old，迫使 client 重新尝试。</p>

<p>另一个需要注意的情况是，如果 storage 收到请求时，还没有从 TLog 拉取到对应 version 的数据，那么 storage 会阻塞该请求，直到数据可以被访问。</p>

<p>到此，FoundationDB 事务的读写流程已经介绍完了。在后面的文章中，将介绍 FoundationDB 如何提供高可扩展的能力。</p>


  </div><a class="u-url" href="/2023/10/28/FDB-arch-read-txn.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">W41ter&#39;s Bistro</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">W41ter&#39;s Bistro</li><li><a class="u-email" href="mailto:w41ter.l@gmail.com">w41ter.l@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/w41ter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">w41ter</span></a></li><li><a href="https://www.twitter.com/WalterM56697798"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WalterM56697798</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Focus on distributed storage system, compiler.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
