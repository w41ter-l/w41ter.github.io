<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>OpenGL traceball | W41ter’s Bistro</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="OpenGL traceball" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="这是图形学的一个作业，记录在此。 这次作业要求实现一个 traceball，需求如下： 鼠标按住滑动，物体跟随鼠标转动 滑动后释放鼠标，则物体保持最后旋转方向继续转动 直接点击则可以停止旋转 现在需要把三个要求转换为程序实现，这里使用 freeglut 库开发。" />
<meta property="og:description" content="这是图形学的一个作业，记录在此。 这次作业要求实现一个 traceball，需求如下： 鼠标按住滑动，物体跟随鼠标转动 滑动后释放鼠标，则物体保持最后旋转方向继续转动 直接点击则可以停止旋转 现在需要把三个要求转换为程序实现，这里使用 freeglut 库开发。" />
<link rel="canonical" href="/2016/11/22/OpenGL-traceball.html" />
<meta property="og:url" content="/2016/11/22/OpenGL-traceball.html" />
<meta property="og:site_name" content="W41ter’s Bistro" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-11-22T04:48:43+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="OpenGL traceball" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-11-22T04:48:43+08:00","datePublished":"2016-11-22T04:48:43+08:00","description":"这是图形学的一个作业，记录在此。 这次作业要求实现一个 traceball，需求如下： 鼠标按住滑动，物体跟随鼠标转动 滑动后释放鼠标，则物体保持最后旋转方向继续转动 直接点击则可以停止旋转 现在需要把三个要求转换为程序实现，这里使用 freeglut 库开发。","headline":"OpenGL traceball","mainEntityOfPage":{"@type":"WebPage","@id":"/2016/11/22/OpenGL-traceball.html"},"url":"/2016/11/22/OpenGL-traceball.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="W41ter's Bistro" /><!-- for mathjax support -->
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">W41ter&#39;s Bistro</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">OpenGL traceball</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-11-22T04:48:43+08:00" itemprop="datePublished">Nov 22, 2016
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>这是图形学的一个作业，记录在此。</p>

<p>这次作业要求实现一个 traceball，需求如下：</p>

<ol>
  <li>鼠标按住滑动，物体跟随鼠标转动</li>
  <li>滑动后释放鼠标，则物体保持最后旋转方向继续转动</li>
  <li>直接点击则可以停止旋转</li>
</ol>

<p>现在需要把三个要求转换为程序实现，这里使用 freeglut 库开发。</p>

<!-- more -->

<h2 id="设计">设计</h2>

<p>设计时需要考虑到的问题主要有下面两点。</p>

<h3 id="物体旋转">物体旋转</h3>

<p>OpenGL 中旋转通过 <code class="language-plaintext highlighter-rouge">glRotate*()</code> 函数实现，该函数需要提供两种含义的参数：1、旋转角度；2、旋转轴矢量。即用户改变旋转状态时，只需找出旋转角度与旋转轴矢量。除此之外，具体实现时我们还需要记录旋转前的状态，即每次绘制图像时先旋转到先前位置，然后进行下一步旋转。因此，多个旋转组合，理论上左乘顺序，依次给出旋转的矩阵。然而CTM实现是右乘属性。这里用栈操作实现不了顺序，只能靠自己编程设置矩阵保存上次旋转后的组合矩阵，再CTM右乘它。公式为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>初始：CTM(0)=I, M(0)=I

CTM(i)=I*R(i)*M(i-1); 
M(i)=CTM(i）;
</code></pre></div></div>

<h3 id="鼠标跟随">鼠标跟随</h3>

<p>这里假设我们的视点放在 Z 轴上，方向朝向远点，正方向为上。因此我们可以把屏幕上任意一点看成(x, y, 0)，方便后续计算。OpenGL 提供了鼠标相关回掉设置，可以监听鼠标移动和点击事件。对于鼠标移动，可以每次记录当前位置和前一刻位置，算出鼠标移动矢量 a。算出与矢量 a 垂直的平面，可以算出 xoy 平面和该平面的交线即为旋转轴。旋转角度则可以通过旋转方向矢量长度计算。</p>

<p>现在可以监听鼠标按键信息，按下表示开始旋转，弹起表示监控旋转结束；如果按下和弹起位置一样，那么停止旋转，否则继续保持旋转。</p>

<h2 id="code">Code</h2>

<p>下面直接给出源码，其中有部分完成作业中其他需求部分也保留了。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;GL/glut.h&gt;

#define PI 3.1415926

#define ORITHOGRAPHIC 1
#define PERSPECTIVE   2

typedef GLfloat Point3f[3];

void Idle(void);
void Gasket(void);
void Render(void);
void Initialize(void);
void Reshape(int w, int h);
void Perspective(int w, int h);
void MouseMotion(int x, int y);
void Orthographic(int w, int h);
void Keyboard(unsigned char key, int x, int y);
void MouseEvent(int button, int state, int x, int y);

int gProjectStyle;
int gWindowWidth, gWindowHeight;
int gCurrentX, gCurrentY;
int gStartX, gStartY;
int gGasketLevel;

// lookAt 相关
GLfloat gZNear = 3.f, gZFar = 10.f;
GLfloat gZeye = 5.f;

// trackball 相关
GLfloat gLastPosition[3] = { 0.f, 0.f, 0.f };
GLfloat gAxis[3] = { 0.f, 0.f, 0.1f };
GLfloat gAngle = 0.f;
bool gIsRedrawContinue = false;

// 保存矩阵
GLfloat CompositeTransMatrix[4][4];

int main(int argc, char **argv)
{
    gWindowWidth = gWindowHeight = 600;

    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(gWindowWidth, gWindowHeight);
    glutCreateWindow("trackball Color Gasket");

    Initialize();

    glutMainLoop();
}

void Identity(GLfloat matrix[4][4])
{
    for (int i = 0; i &lt; 4; ++i) {
        for (int j = 0; j &lt; 4; ++j) {
            matrix[i][j] = i == j ? 1.f : 0.f;
        }
    }
}

void MenuSelect(int item)
{
    if (item == ORITHOGRAPHIC) {
        Orthographic(gWindowWidth, gWindowHeight);
        gProjectStyle = ORITHOGRAPHIC;
        glutPostRedisplay();
    }
    else if (item == PERSPECTIVE) {
        Perspective(gWindowWidth, gWindowHeight);
        gProjectStyle = PERSPECTIVE;
        glutPostRedisplay();
    }
}

void InitMenu(void)
{
    glutCreateMenu(MenuSelect);
    glutAddMenuEntry("Orthographic", ORITHOGRAPHIC);
    glutAddMenuEntry("Perspective", PERSPECTIVE);
    glutAttachMenu(GLUT_RIGHT_BUTTON);
}

void InitCallback(void)
{
    glutReshapeFunc(Reshape);
    glutDisplayFunc(Render);
    glutIdleFunc(Idle);
    glutMouseFunc(MouseEvent);
    glutMotionFunc(MouseMotion);
    glutKeyboardFunc(Keyboard);
}

void Initialize(void)
{
    InitCallback();
    InitMenu();

    gGasketLevel = 3;
    Identity(CompositeTransMatrix);

    glEnable(GL_DEPTH_TEST);
    glShadeModel(GL_FLAT);
    glClearColor(1.0, 1.0, 1.0, 1.0);

    gProjectStyle = ORITHOGRAPHIC;
    Orthographic(gWindowWidth, gWindowHeight);
}

void Reshape(int w, int h)
{
    if (gProjectStyle == ORITHOGRAPHIC)
        Orthographic(w, h);
    else
        Perspective(w, h);
}

void Idle(void)
{
    if (gIsRedrawContinue == true) {
        gAngle = 0.01f;
        glutPostRedisplay();
    }
}

// 
// 计算透视窗口
// 
void CalView(int w, int h, GLfloat *left, GLfloat *right, GLfloat *bottom, GLfloat *top)
{
    if (w &lt;= h) {
        *left = -2.0f;
        *right = 2.0f;
        *bottom = -2.0f * h / w;
        *top = 2.0f * h / w;
    } 
    else {
        *left = -2.0f * w / h;
        *right = 2.0f * w / h;
        *bottom = -2.0f;
        *top = 2.0f;
    }
}

void Perspective(int w, int h)
{
    GLfloat left, right, bottom, top;
    CalView(w, h, &amp;left, &amp;right, &amp;bottom, &amp;top);

    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(left, right, bottom, top, gZNear, gZFar);
    glutPostRedisplay();

    gWindowWidth = w;
    gWindowHeight = h;
}

void Orthographic(int w, int h)
{
    GLfloat left, right, bottom, top;
    CalView(w, h, &amp;left, &amp;right, &amp;bottom, &amp;top);

    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(left, right, bottom, top, gZNear, gZFar);
    glMatrixMode(GL_MODELVIEW);
    glutPostRedisplay();

    gWindowWidth = w;
    gWindowHeight = h;
}

// 
// 将屏幕坐标转换到 vector3f
// 
void TrackballPToV(int x, int y, int w, int h, GLfloat v[3])
{
    v[0] = (2.0f*x - w) / w;
    v[1] = (h - 2.0f*y) / h;
    float d = sqrtf(v[0] * v[0] + v[1] * v[1]);
    v[2] = cosf((PI / 2.0f) * ((d &lt; 1.0f) ? d : 1.0f));
    float a = 1.0f / sqrtf(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    v[0] *= a;
    v[1] *= a;
    v[2] *= a;
}

void MouseMotion(int x, int y)
{
    float curPos[3], dx, dy, dz;
    TrackballPToV(x, y, gWindowWidth, gWindowHeight, curPos);

    dx = curPos[0] - gLastPosition[0];
    dy = curPos[1] - gLastPosition[1];
    dz = curPos[2] - gLastPosition[2];

    if (dx || dy || dz) {
        gAngle = 90.0F * sqrtf(dx*dx + dy*dy + dz*dz);

        gAxis[0] = gLastPosition[1] * curPos[2] - gLastPosition[2] * curPos[1];
        gAxis[1] = gLastPosition[2] * curPos[0] - gLastPosition[0] * curPos[2];
        gAxis[2] = gLastPosition[0] * curPos[1] - gLastPosition[1] * curPos[0];

        gLastPosition[0] = curPos[0];
        gLastPosition[1] = curPos[1];
        gLastPosition[2] = curPos[2];
    }

    glutPostRedisplay();
}

void StartMotion(int x, int y)
{
    gIsRedrawContinue = false;
    gStartX = x; 
    gStartY = y;
    gCurrentX = x;
    gCurrentY = y;
    TrackballPToV(x, y, gWindowWidth, gWindowHeight, gLastPosition);
}

void StopMotion(int x, int y)
{
    if (gStartX != x &amp;&amp; gStartY != y) {
        gIsRedrawContinue = true;
    }
    else {
        gAngle = 0.0f;
        gIsRedrawContinue = false;
    }
}

void MouseEvent(int Botton, int State, int MouseX, int MouseY)
{
    if (Botton == GLUT_LEFT_BUTTON) {
        switch (State)
        {
        case GLUT_DOWN:
            StartMotion(MouseX, MouseY);
            break;
        case GLUT_UP:
            StopMotion(MouseX, MouseY);
            break;
        }
    }
}

void Render(void)
{
    GLfloat *pCompositeTransMatrix = *CompositeTransMatrix;

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    /* 多个旋转组合 */
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glRotatef(gAngle, gAxis[0], gAxis[1], gAxis[2]);
    glMultMatrixf(pCompositeTransMatrix);
    glGetFloatv(GL_MODELVIEW_MATRIX, pCompositeTransMatrix);

    // 设置 lookAtMatrix 应该在最开始的位置
    glLoadIdentity();
    gluLookAt(0, 0, gZeye, 0, 0, 0, 0, 1, 0);
    glMultMatrixf(pCompositeTransMatrix);

    Gasket();

    glutSwapBuffers();
}

void Keyboard(unsigned char key, int x, int y)
{
    if ('0' &lt;= key &amp;&amp; key &lt;= '3') {
        gGasketLevel = key - '0';
        glutPostRedisplay();
    }
    else if (key == 'q' || key == 'Q') {
        exit(0);
    }
}

void Triangle(const Point3f p1, const Point3f p2, const Point3f p3, const Point3f color)
{
    glBegin(GL_POLYGON);
    {
        glColor3fv(color);
        glVertex3fv(p1);
        glVertex3fv(p2);
        glVertex3fv(p3);
    }
    glEnd();
}

void Tetrahedron(const Point3f p1, const Point3f p2, const Point3f p3, const Point3f p4)
{
    const static Point3f Color[] = {
        { 1.f, 0.f, 0.f },
        { 0.f, 1.f, 0.f },
        { 0.f, 0.f, 1.f },
        { 1.f, 1.f, 0.1f },
    };

    Triangle(p1, p2, p3, Color[0]);
    Triangle(p1, p2, p4, Color[1]);
    Triangle(p1, p3, p4, Color[2]);
    Triangle(p2, p4, p3, Color[3]);
}

void DivideVertices(Point3f p1, Point3f p2, Point3f p3, Point3f p4, int level)
{
    Point3f v0, v1, v2, v3, v4, v5;
    if (level &gt; 0) {
        for (int j = 0; j&lt;3; j++) v0[j] = (p1[j] + p2[j]) / 2;
        for (int j = 0; j&lt;3; j++) v1[j] = (p1[j] + p3[j]) / 2;
        for (int j = 0; j&lt;3; j++) v2[j] = (p1[j] + p4[j]) / 2;
        for (int j = 0; j&lt;3; j++) v3[j] = (p2[j] + p3[j]) / 2;
        for (int j = 0; j&lt;3; j++) v4[j] = (p2[j] + p4[j]) / 2;
        for (int j = 0; j&lt;3; j++) v5[j] = (p4[j] + p3[j]) / 2;
        DivideVertices(p1, v0, v1, v2, level - 1);
        DivideVertices(v0, p2, v3, v4, level - 1);
        DivideVertices(v1, v3, p3, v5, level - 1);
        DivideVertices(v2, v4, v5, p4, level - 1);
    } 
    else {
        Tetrahedron(p1, p2, p3, p4);
    }
}

void Gasket(void)
{
    static Point3f Vertices[] = {
        { -1.f, -1.f, 0.5773f },
        { 0.f, -1.f, -1.15475 },
        { 1.0f, -1.0f, 0.5773f },
        { 0.0f, 1.0f, 0.0f },
    };
    DivideVertices(Vertices[0], Vertices[1], Vertices[2], Vertices[3], gGasketLevel);
}
</code></pre></div></div>

  </div><a class="u-url" href="/2016/11/22/OpenGL-traceball.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">W41ter&#39;s Bistro</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">W41ter&#39;s Bistro</li><li><a class="u-email" href="mailto:w41ter.l@gmail.com">w41ter.l@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/w41ter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">w41ter</span></a></li><li><a href="https://www.twitter.com/WalterM56697798"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WalterM56697798</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Focus on distributed storage system, compiler.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
