<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-10-28T15:43:09+08:00</updated><id>/feed.xml</id><title type="html">W41ter’s Bistro</title><subtitle>Focus on distributed storage system, compiler.</subtitle><entry><title type="html">FoundationDB 架构 - 只读事务</title><link href="/2023/10/28/FDB-arch-read-txn.html" rel="alternate" type="text/html" title="FoundationDB 架构 - 只读事务" /><published>2023-10-28T00:00:00+08:00</published><updated>2023-10-28T00:00:00+08:00</updated><id>/2023/10/28/FDB-arch-read-txn</id><content type="html" xml:base="/2023/10/28/FDB-arch-read-txn.html"><![CDATA[<p>前一篇文章介绍了 <a href="https://mp.weixin.qq.com/s?__biz=MzU4ODgyOTg5NA==&amp;mid=2247483728&amp;idx=1&amp;sn=87b85f293fe91bc57f589a09be84b7a2&amp;chksm=fdd784f9caa00def578dfacc61ef7ba1ab31f64b87826c9f279bae385bf44022f9923e853dd6&amp;token=1055659193&amp;lang=zh_CN#rd">FoundationDB 架构 - 事务数据的存储</a> FoundationDB 数据是如何存储的。这篇文章将介绍如何从 FoundationDB 中读取已写入的数据。</p>

<p><img src="assets/FDB-arch-read-txn-imgs/read-path.png" alt="读请求路径" /></p>

<h2 id="开启事务">开启事务</h2>

<p>同写事务相同，读事务开启时也需要先通过 GRV proxy 间接地从 master 获取已经提交事务的最大 version。因为写事务只需要将数据持久化到 TLog 就算完成，而 storage 拉取 message 的步骤并不在写事务提交的关键路径上。因此需要 client 在请求中携带上它能观察到的最大的 version，storage 才能通过这个 version 判断本地数据是否完整。</p>

<h2 id="路由">路由</h2>

<p>Client 并不知道数据是如何分布在 storage 中以及每个 storage 的地址，它需要向 FoundationDB 集群查询 key 到 storage server 的路由项（称为 location）。</p>

<p>因为任何对 key 到 server 映射关系的变更操作都需要通过 commit proxy 持久化到 TLog 中（这部分细节将在后续的文章中介绍），所以 commit proxy 知晓整个集群的 location。Client 通过发送 <code class="language-plaintext highlighter-rouge">GetKeyServerLocations</code> 请求给 commit proxy 以查询 locations。</p>

<p>由于 location 变更是个低频操作，缓存 location 能够有效降低查询 commit proxy 的次数。每次发送请求前，client 都会先查询缓存，如果未命中才会向 commit proxy 请求 location；此外，如果 location 过期，那么 storage 会拒绝服务，这种情况下 client 会清理缓存，再次向 commit proxy 获取最新的 location。</p>

<h2 id="读数据">读数据</h2>

<p>拿到 location 后，client 会发送 <code class="language-plaintext highlighter-rouge">getValue</code> 请求给 storage。前一篇文章已经介绍了，storage 中的数据分为两部分，第一部分存在多版本窗口中，第二部分存在磁盘 key value store 中。</p>

<p>Storage 会先在内存中查找 key，如果未命中再从磁盘 key value 中读取。这里需要注意的是磁盘中的数据是没有版本信息的，所以无法判断这部分数据是否能够被指定版本的读请求读取到，因此如果一个请求携带的 version 已经超过了多版本窗口（默认为 5s），那么 storage 将返回 transaction too old，迫使 client 重新尝试。</p>

<p>另一个需要注意的情况是，如果 storage 收到请求时，还没有从 TLog 拉取到对应 version 的数据，那么 storage 会阻塞该请求，直到数据可以被访问。</p>

<p>到此，FoundationDB 事务的读写流程已经介绍完了。在后面的文章中，将介绍 FoundationDB 如何提供高可扩展的能力。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[前一篇文章介绍了 FoundationDB 架构 - 事务数据的存储 FoundationDB 数据是如何存储的。这篇文章将介绍如何从 FoundationDB 中读取已写入的数据。 开启事务 同写事务相同，读事务开启时也需要先通过 GRV proxy 间接地从 master 获取已经提交事务的最大 version。因为写事务只需要将数据持久化到 TLog 就算完成，而 storage 拉取 message 的步骤并不在写事务提交的关键路径上。因此需要 client 在请求中携带上它能观察到的最大的 version，storage 才能通过这个 version 判断本地数据是否完整。 路由 Client 并不知道数据是如何分布在 storage 中以及每个 storage 的地址，它需要向 FoundationDB 集群查询 key 到 storage server 的路由项（称为 location）。 因为任何对 key 到 server 映射关系的变更操作都需要通过 commit proxy 持久化到 TLog 中（这部分细节将在后续的文章中介绍），所以 commit proxy 知晓整个集群的 location。Client 通过发送 GetKeyServerLocations 请求给 commit proxy 以查询 locations。 由于 location 变更是个低频操作，缓存 location 能够有效降低查询 commit proxy 的次数。每次发送请求前，client 都会先查询缓存，如果未命中才会向 commit proxy 请求 location；此外，如果 location 过期，那么 storage 会拒绝服务，这种情况下 client 会清理缓存，再次向 commit proxy 获取最新的 location。 读数据 拿到 location 后，client 会发送 getValue 请求给 storage。前一篇文章已经介绍了，storage 中的数据分为两部分，第一部分存在多版本窗口中，第二部分存在磁盘 key value store 中。 Storage 会先在内存中查找 key，如果未命中再从磁盘 key value 中读取。这里需要注意的是磁盘中的数据是没有版本信息的，所以无法判断这部分数据是否能够被指定版本的读请求读取到，因此如果一个请求携带的 version 已经超过了多版本窗口（默认为 5s），那么 storage 将返回 transaction too old，迫使 client 重新尝试。 另一个需要注意的情况是，如果 storage 收到请求时，还没有从 TLog 拉取到对应 version 的数据，那么 storage 会阻塞该请求，直到数据可以被访问。 到此，FoundationDB 事务的读写流程已经介绍完了。在后面的文章中，将介绍 FoundationDB 如何提供高可扩展的能力。]]></summary></entry><entry><title type="html">FoundationDB 架构 - 数据存储</title><link href="/2023/10/02/FDB-arch-txn-store.html" rel="alternate" type="text/html" title="FoundationDB 架构 - 数据存储" /><published>2023-10-02T00:00:00+08:00</published><updated>2023-10-02T00:00:00+08:00</updated><id>/2023/10/02/FDB-arch-txn-store</id><content type="html" xml:base="/2023/10/02/FDB-arch-txn-store.html"><![CDATA[<p>前一篇文章详细介绍了可序列化快照隔离级别以及 FoundationDB 的实现，这篇文章将介绍在通过事务冲突处理后，FoundationDB 是如何持久化数据的。</p>

<p>在 FoundationDB 中负责持久化数据的主要有两个组件：</p>

<ul>
  <li>TLog: 类似于 RDMS 中的 WAL（write ahead log），提供日志的持久化能力；</li>
  <li>Storage: 负责应用日志、存取 key value 数据。</li>
</ul>

<p>Commit proxy 检查完事务冲突后，将可提交的 mutations 打包到一个 message 中，并通过 <code class="language-plaintext highlighter-rouge">TLogCommitRequest</code> 发送给所有 TLog 。</p>

<h2 id="tlog">TLog</h2>

<p><img src="assets/FDB-arch-txn-store-imgs/TLog.png" alt="TLog 内部结构" /></p>

<p>TLog 首先需要将日志按照事务提交顺序持久化。和 resolver 一样，TLog 收到的 <code class="language-plaintext highlighter-rouge">TLogCommitRequest</code> 请求可能和事务的 commit version 不同，它会在内存中对请求进行排序再进行持久化。</p>

<p>日志持久化由 disk queue 负责，日志在序列化后，写入 disk queue 的内存中；后者按照 4KB 为单位将日志切分成多个 page；一批数据写完后再写入磁盘。Disk queue 磁盘结构也很简单，它是两个文件组成的一个 WAL。每次写入时，将数据追加到后一个文件的末尾；如果前一个文件中的数据已经被消费完（可以清除），那么会交换两个文件顺序，之前的前一个文件会被清空，且新数据将依次追加到文件末尾。</p>

<p>在通常情况下，不同 storage 负责的 key 范围不一样，如果都统一从 disk queue 拉取日志，那么将读取到很多不需要的日志。为了减少 storage 拉取日志时的开销，TLog 会提前准备好每个 storage 所需要的日志。</p>

<p>FoundationDB 会为每个 storage 分配一个 tag，key 到 storage 的映射就等价于 key 到 tag 的映射；将 key 按照 tag 划分，得到的就是某个 storage 负责的 key 范围。Commit proxy 在准备提交请求到 TLog 前，会按照 message 中的 key 为 message 打上不同的 tag；而 TLog 会根据 message 中的 tag，将 message 按照顺序暂存在按 tag 分类的 memory queue 中。这样 storage 拉取日志时，只需要从对应 tag 的内存队列中拉取即可。</p>

<p>内存中的数据始终是有上限的，storage 消费并完成对日志数据的持久化后，TLog 就能释放内存中、磁盘上的数据；如果 storage 消费不及时，当 TLog 内存数据达到上限后会触发反压，拒绝新请求直到 storage 的消费速度跟上写入速度。</p>

<h2 id="storage">Storage</h2>

<p><img src="assets/FDB-arch-txn-store-imgs/Storage.png" alt="Storage 内部结构" /></p>

<p>Storage 会通过 <code class="language-plaintext highlighter-rouge">TLogPeekRequest</code> 从 TLog 拉取最新的日志。这些日志暂存在 storage 的内存中，最终持久化到 key value store 中。</p>

<p>Storage 会在内存中维护一个多版本窗口，每个版本由一棵 partial tree 组成；从 TLog 拉取的日志会按照版本生成 partial tree，并按照版本顺序组成队列。所谓的 partial tree 是 key value pairs 组成的一个 map，它只记录了一个事务版本中更新的数据。</p>

<p>超过窗口的数据（默认为 5s）会从内存队列中移出，并通过专用的线程写入到 key value store 中。FoundationDB 有多种 key value store 的实现，默认情况下使用 sqlite 作为底层存储引擎，此外还有 memory，redwood，rocksdb 可供选择。</p>

<p>Key value store 中的 key value 没有记录版本信息，因此一旦内存中的 partial tree 写入到 key value store 中，那么之前的版本信息就会丢失，而小于该版本的事务读将会被拒绝，即返回错误：<code class="language-plaintext highlighter-rouge">transaction too old</code>。</p>

<p>一旦数据被持久化到 key value store 中，storage 就可以通知 TLog 释放对应 tag 的内存数据；某个日志如果没有任何 tag 引用，那么就能安全地释放它所占用的磁盘空间。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[前一篇文章详细介绍了可序列化快照隔离级别以及 FoundationDB 的实现，这篇文章将介绍在通过事务冲突处理后，FoundationDB 是如何持久化数据的。 在 FoundationDB 中负责持久化数据的主要有两个组件： TLog: 类似于 RDMS 中的 WAL（write ahead log），提供日志的持久化能力； Storage: 负责应用日志、存取 key value 数据。 Commit proxy 检查完事务冲突后，将可提交的 mutations 打包到一个 message 中，并通过 TLogCommitRequest 发送给所有 TLog 。 TLog TLog 首先需要将日志按照事务提交顺序持久化。和 resolver 一样，TLog 收到的 TLogCommitRequest 请求可能和事务的 commit version 不同，它会在内存中对请求进行排序再进行持久化。 日志持久化由 disk queue 负责，日志在序列化后，写入 disk queue 的内存中；后者按照 4KB 为单位将日志切分成多个 page；一批数据写完后再写入磁盘。Disk queue 磁盘结构也很简单，它是两个文件组成的一个 WAL。每次写入时，将数据追加到后一个文件的末尾；如果前一个文件中的数据已经被消费完（可以清除），那么会交换两个文件顺序，之前的前一个文件会被清空，且新数据将依次追加到文件末尾。 在通常情况下，不同 storage 负责的 key 范围不一样，如果都统一从 disk queue 拉取日志，那么将读取到很多不需要的日志。为了减少 storage 拉取日志时的开销，TLog 会提前准备好每个 storage 所需要的日志。 FoundationDB 会为每个 storage 分配一个 tag，key 到 storage 的映射就等价于 key 到 tag 的映射；将 key 按照 tag 划分，得到的就是某个 storage 负责的 key 范围。Commit proxy 在准备提交请求到 TLog 前，会按照 message 中的 key 为 message 打上不同的 tag；而 TLog 会根据 message 中的 tag，将 message 按照顺序暂存在按 tag 分类的 memory queue 中。这样 storage 拉取日志时，只需要从对应 tag 的内存队列中拉取即可。 内存中的数据始终是有上限的，storage 消费并完成对日志数据的持久化后，TLog 就能释放内存中、磁盘上的数据；如果 storage 消费不及时，当 TLog 内存数据达到上限后会触发反压，拒绝新请求直到 storage 的消费速度跟上写入速度。 Storage Storage 会通过 TLogPeekRequest 从 TLog 拉取最新的日志。这些日志暂存在 storage 的内存中，最终持久化到 key value store 中。 Storage 会在内存中维护一个多版本窗口，每个版本由一棵 partial tree 组成；从 TLog 拉取的日志会按照版本生成 partial tree，并按照版本顺序组成队列。所谓的 partial tree 是 key value pairs 组成的一个 map，它只记录了一个事务版本中更新的数据。 超过窗口的数据（默认为 5s）会从内存队列中移出，并通过专用的线程写入到 key value store 中。FoundationDB 有多种 key value store 的实现，默认情况下使用 sqlite 作为底层存储引擎，此外还有 memory，redwood，rocksdb 可供选择。 Key value store 中的 key value 没有记录版本信息，因此一旦内存中的 partial tree 写入到 key value store 中，那么之前的版本信息就会丢失，而小于该版本的事务读将会被拒绝，即返回错误：transaction too old。 一旦数据被持久化到 key value store 中，storage 就可以通知 TLog 释放对应 tag 的内存数据；某个日志如果没有任何 tag 引用，那么就能安全地释放它所占用的磁盘空间。]]></summary></entry><entry><title type="html">FoundationDB 架构 - 事务冲突处理</title><link href="/2023/09/09/FDB-arch-txn-conflicts.html" rel="alternate" type="text/html" title="FoundationDB 架构 - 事务冲突处理" /><published>2023-09-09T00:00:00+08:00</published><updated>2023-09-09T00:00:00+08:00</updated><id>/2023/09/09/FDB-arch-txn-conflicts</id><content type="html" xml:base="/2023/09/09/FDB-arch-txn-conflicts.html"><![CDATA[<p>前一篇文章中提到，FoundationDB 提供了可序列化快照隔离（serializable snapshot isolation, ssi）级别，这篇文章将深入介绍 SSI 以及 FoundationDB 是如何实现的。</p>

<h2 id="快照隔离">快照隔离</h2>

<p>快照隔离是一种事务隔离级别，它属于多版本并发控制（multiversion concurreny control, MVCC），它的每个事务读都只读取该事务开始时已经提交的数据的快照。</p>

<p><img src="assets/FDB-arch-txn-conflicts-imgs/isolation-level-and-their-relationship.png" alt="A diagram of the isolation levels and their relationships. From a critique of ANSI Isolation" /></p>

<p>不同事务访问相同资源时会产生竞争，处理竞争的方式可能会影响事务吞吐，比如加读写锁会让读写请求间相互等待。快照隔离可以避免读写竞争，从而提升事务的吞吐。因为在快照隔离中，任何改动都会生成一份新的快照，而后者对于已经持有数据快照的事务读是不可见的，所以只要能够维护数据快照，事务读请求就不会被阻塞。</p>

<p><img src="assets/FDB-arch-txn-conflicts-imgs/snapshot-read.png" alt="Snapshot Read" /></p>

<p>能避免读写竞争的优点让快照隔离有了非常广泛的应用，但它仍然不完美，离理想的可序列化仍然有差距。在论文 A Critique of ANSI Isolation 中就详细介绍了快照隔离和它存在的幻象（Phantoms）： Write Skew。</p>

<h3 id="write-skew">Write Skew</h3>

<p>Write skew 是这样一种现象：两个事务分别读取不同数据，然后修改另一个事务读取的数据，并提交。在快照隔离中，由于读取的数据都是快照，和写入没有冲突，所以两个事务理论上都能提交；如果这两个数据间存在某种约束，那么这个约束将被打破，产生异常（anomaly）。</p>

<p>Write skew 的执行历史可以形式化定义为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A5B: r1[x]...r2[y]...w1[y]...w2[x]...(c1 and c2 occur)
</code></pre></div></div>

<p>其中 1 和 2 是两个事务，r,w,c 分别是读、写和提交。</p>

<h2 id="write-snapshot-isolation">Write Snapshot Isolation</h2>

<p>仔细观察前面的例子可以发现，约束被打破的原因是其中一个事务提交时，它所读取到的数据已经被其他事务修改并提交了；而快照隔离只处理了写-写冲突（write-write confliction），所以无法观察到这一事实。</p>

<p>针对这个情况，论文 A Critique of Snapshot Isolation，提出了 write snapshot isolation，它的主要改动是：事务提交时，检查事务读所涉及到的数据是否已经被其他事务修改过。Write snapshot isolation 不再处理写-写冲突，它只关心事务间的读-写冲突（read-write confliction），如果一个事务在提交时发现读取的数据已经被其他已提交事务修改过，那么该事务无法提交。</p>

<p>通过检查读-写冲突来避免 write skew 异常，write snapshot isolation 能够在保留快照隔离优点的同时取得可序列化的隔离级别。FoundationDB 也正是基于这个理论来处理事务间的冲突。</p>

<h2 id="in-foundationdb">In FoundationDB</h2>

<p>FoundationDB 的 resolver 负责处理事务间的冲突，它在内存中记录着已经提交的事务修改的数据范围和版本。</p>

<p>每个事务提交前，会将其读取的数据范围与 resolver 中记录的数据范围进行比较，如果存在交集说明则说明存在事务冲突，事务将被拒绝提交。需要注意的是，只有事务读数据的版本小于事务写的版本，才算存在交集；如果事务读的版本大于等于 resolver 中记录的数据的版本，那么它们之间本来就存在着先后关系，一定不存在冲突。</p>

<p>如果事务可提交，它改动的数据范围和版本将会更新在 resolver 中。为了保证上述数据不会超过内存限制，resolver 只会在内存中记录提交时间在 5 秒内的事务的修改范围，超过时间的将被丢弃，所以 FoundationDB client 开启的交互式事务最长生命周期为 5 秒，超过后将收到错误：<code class="language-plaintext highlighter-rouge">transaction too old</code>。</p>

<p>由于事务间存在顺序关系，它由 commit version 决定，而后者又是通过 master 分配给 commit proxy 的，所以 resolver 收到的 commit 请求的顺序可能和 commit version 的顺序不同。Resolver 会在内存中对 commit 请求进行排队，并按照 commit version 顺序进行处理。</p>

<p>下面来看一个处理冲突的具体例子。</p>

<p><img src="assets/FDB-arch-txn-conflicts-imgs/resolve-txn-conflicts.png" alt="处理事务冲突" /></p>

<p>假设有两个事务 1,2 分别在时刻 200, 100 开始，事务 1 读取 <code class="language-plaintext highlighter-rouge">a,b</code> 修改 <code class="language-plaintext highlighter-rouge">c</code>，事务 2 读取 <code class="language-plaintext highlighter-rouge">a,c</code> 修改 <code class="language-plaintext highlighter-rouge">b</code>；它们分别发送给不同的 commit proxy 完成提交，其中事务 1 拿到的提交时间为 300，事务 2 为 400，所以 resolver 先处理事务 1，再处理事务 2。</p>

<p>假设此时 resolver 内存中记录的已提交数据集（write conflict range）为 <code class="language-plaintext highlighter-rouge">50: [d]</code>（50 为版本，<code class="language-plaintext highlighter-rouge">[d]</code> 表示修改数据范围）。事务 1 的 read conflict range: <code class="language-plaintext highlighter-rouge">200: [a, b]</code> 与 resolver 的 write conflict range 不存在冲突，所以事务 1 可以提交。</p>

<p>Resolver 将事务 1 的 write conflict range 合并到内存中，此时 resolver 的 write conflict range 为:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>50: [d]
300: [c]
</code></pre></div></div>

<p>事务 2 的 read conflict range 为: <code class="language-plaintext highlighter-rouge">100: [a, c]</code>，它与 resolver 的 <code class="language-plaintext highlighter-rouge">300: [c]</code> 存在冲突，所以事务 2 将被拒绝。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[前一篇文章中提到，FoundationDB 提供了可序列化快照隔离（serializable snapshot isolation, ssi）级别，这篇文章将深入介绍 SSI 以及 FoundationDB 是如何实现的。 快照隔离 快照隔离是一种事务隔离级别，它属于多版本并发控制（multiversion concurreny control, MVCC），它的每个事务读都只读取该事务开始时已经提交的数据的快照。 不同事务访问相同资源时会产生竞争，处理竞争的方式可能会影响事务吞吐，比如加读写锁会让读写请求间相互等待。快照隔离可以避免读写竞争，从而提升事务的吞吐。因为在快照隔离中，任何改动都会生成一份新的快照，而后者对于已经持有数据快照的事务读是不可见的，所以只要能够维护数据快照，事务读请求就不会被阻塞。 能避免读写竞争的优点让快照隔离有了非常广泛的应用，但它仍然不完美，离理想的可序列化仍然有差距。在论文 A Critique of ANSI Isolation 中就详细介绍了快照隔离和它存在的幻象（Phantoms）： Write Skew。 Write Skew Write skew 是这样一种现象：两个事务分别读取不同数据，然后修改另一个事务读取的数据，并提交。在快照隔离中，由于读取的数据都是快照，和写入没有冲突，所以两个事务理论上都能提交；如果这两个数据间存在某种约束，那么这个约束将被打破，产生异常（anomaly）。 Write skew 的执行历史可以形式化定义为： A5B: r1[x]...r2[y]...w1[y]...w2[x]...(c1 and c2 occur) 其中 1 和 2 是两个事务，r,w,c 分别是读、写和提交。 Write Snapshot Isolation 仔细观察前面的例子可以发现，约束被打破的原因是其中一个事务提交时，它所读取到的数据已经被其他事务修改并提交了；而快照隔离只处理了写-写冲突（write-write confliction），所以无法观察到这一事实。 针对这个情况，论文 A Critique of Snapshot Isolation，提出了 write snapshot isolation，它的主要改动是：事务提交时，检查事务读所涉及到的数据是否已经被其他事务修改过。Write snapshot isolation 不再处理写-写冲突，它只关心事务间的读-写冲突（read-write confliction），如果一个事务在提交时发现读取的数据已经被其他已提交事务修改过，那么该事务无法提交。 通过检查读-写冲突来避免 write skew 异常，write snapshot isolation 能够在保留快照隔离优点的同时取得可序列化的隔离级别。FoundationDB 也正是基于这个理论来处理事务间的冲突。 In FoundationDB FoundationDB 的 resolver 负责处理事务间的冲突，它在内存中记录着已经提交的事务修改的数据范围和版本。 每个事务提交前，会将其读取的数据范围与 resolver 中记录的数据范围进行比较，如果存在交集说明则说明存在事务冲突，事务将被拒绝提交。需要注意的是，只有事务读数据的版本小于事务写的版本，才算存在交集；如果事务读的版本大于等于 resolver 中记录的数据的版本，那么它们之间本来就存在着先后关系，一定不存在冲突。 如果事务可提交，它改动的数据范围和版本将会更新在 resolver 中。为了保证上述数据不会超过内存限制，resolver 只会在内存中记录提交时间在 5 秒内的事务的修改范围，超过时间的将被丢弃，所以 FoundationDB client 开启的交互式事务最长生命周期为 5 秒，超过后将收到错误：transaction too old。 由于事务间存在顺序关系，它由 commit version 决定，而后者又是通过 master 分配给 commit proxy 的，所以 resolver 收到的 commit 请求的顺序可能和 commit version 的顺序不同。Resolver 会在内存中对 commit 请求进行排队，并按照 commit version 顺序进行处理。 下面来看一个处理冲突的具体例子。 假设有两个事务 1,2 分别在时刻 200, 100 开始，事务 1 读取 a,b 修改 c，事务 2 读取 a,c 修改 b；它们分别发送给不同的 commit proxy 完成提交，其中事务 1 拿到的提交时间为 300，事务 2 为 400，所以 resolver 先处理事务 1，再处理事务 2。 假设此时 resolver 内存中记录的已提交数据集（write conflict range）为 50: [d]（50 为版本，[d] 表示修改数据范围）。事务 1 的 read conflict range: 200: [a, b] 与 resolver 的 write conflict range 不存在冲突，所以事务 1 可以提交。 Resolver 将事务 1 的 write conflict range 合并到内存中，此时 resolver 的 write conflict range 为: 50: [d] 300: [c] 事务 2 的 read conflict range 为: 100: [a, c]，它与 resolver 的 300: [c] 存在冲突，所以事务 2 将被拒绝。]]></summary></entry><entry><title type="html">FoundationDB 架构 - 写事务处理流程</title><link href="/2023/08/13/FDB-arch-txn.html" rel="alternate" type="text/html" title="FoundationDB 架构 - 写事务处理流程" /><published>2023-08-13T00:00:00+08:00</published><updated>2023-08-13T00:00:00+08:00</updated><id>/2023/08/13/FDB-arch-txn</id><content type="html" xml:base="/2023/08/13/FDB-arch-txn.html"><![CDATA[<p>前一篇文章 <a href="https://mp.weixin.qq.com/s?__biz=MzU4ODgyOTg5NA==&amp;mid=2247483697&amp;idx=1&amp;sn=7ad949ecc5f298b2061d1a4066e2572c&amp;chksm=fdd78498caa00d8e8df55fa70b3b364edd0e8e688efa03dc8d1110d46a16cda455aa50b7eaf3#rd">FoundationDB 架构概述</a> 从全局视角介绍了 FoundationDB 架构的特点，这篇文章将介绍 FoundationDB 写事务的处理流程以及各个组件间是如何沟通协作的。</p>

<h2 id="open-database">Open Database</h2>

<p>在与 FoundationDB 集群交互前，client 需要先执行 open database。</p>

<p><img src="assets/FDB-arch-txn-imgs/open-database.png" alt="Open Database" /></p>

<p>执行 open database 时，client 会从 <code class="language-plaintext highlighter-rouge">fdb.cluster</code> 文件中获取 <code class="language-plaintext highlighter-rouge">connection string</code>，后者指向了集群中的 coordinators；client 发送 <code class="language-plaintext highlighter-rouge">OpenDatabaseCoordRequest</code> 请求给 coordinator 进行验证，并获取 <code class="language-plaintext highlighter-rouge">ClientDBInfo</code>。</p>

<p><code class="language-plaintext highlighter-rouge">ClientDBInfo</code> 中记录了集群中 GRV proxy 和 Commit proxy 的地址，后续的写请求会用到这两个 proxy 的地址。</p>

<h2 id="提交事务">提交事务</h2>

<p>FoundationDB 依赖一个全局单调递增的时间戳来提供多版本并发控制。每个事务提交时，会分配一个新的版本（Version）；事务间按照 version 大小确定唯一的提交顺序。</p>

<p>FoundationDB 支持交互式事务，开启事务时会获取之前已经提交的最大的事务 version，并在一段时间后才会提交，所以事务间可能存在冲突。FoundationDB 通过检测事务间的 read-write confliction 来避免快照隔离（snapshot isolation, si）带来的 write skew，从而取得序列化快照隔离（serializable snapshot isolation, ssi）。</p>

<blockquote>
  <p>上述实现又称 write snapshot isolation, 出处见论文： A critique of snapshot isolation。</p>
</blockquote>

<p>最后，可以提交的事务会写入 TLog 中完成持久化，再异步地发送到存储系统中。</p>

<p><img src="assets/FDB-arch-txn-imgs/commit-txn.png" alt="Commit Transaction" /></p>

<p>上图展示了一个写事务提交的完整交互流程，接下来将按照上图详细分析各个流程。</p>

<p>开启新事务时，需要确定新事务的可见范围，也就是当前事务执行时有哪些事务已经提交。为此，Client 会发送 <code class="language-plaintext highlighter-rouge">GetReadVersionRequest</code> 给 GRV proxy 以查询已经提交的最大的事务 version；后者积攒一批请求后，发送 <code class="language-plaintext highlighter-rouge">GetRawCommitVersionRequest</code> 给 Master 节点，查询记录在 Master 内存中的已经提交的最大的事务 version。</p>

<p>之后的任何写入操作会暂存在 client 的内存中，同时记录下读请求的范围供后续检测事务间的冲突。（读事务的处理流程将在后续的文章中介绍。）</p>

<p>暂存在 client 内存中的数据在提交时通过 <code class="language-plaintext highlighter-rouge">CommitTransactionRequest</code> 发送给 Commit proxy，后者将提交过程分成几个步骤：</p>

<ol>
  <li>获取 commit version</li>
  <li>解决事务冲突</li>
  <li>持久化改动</li>
  <li>响应事务提交结果</li>
</ol>

<h3 id="获取-commit-version">获取 commit version</h3>

<p>Commit proxy 积攒一批请求后，发送 <code class="language-plaintext highlighter-rouge">GetCommitVersionRequest</code> 给 Master 以获取一个新的提交 version 以及确定事务间的顺序。Master 内存中记录着上一次分配（前一个事务）的 commit version，在上一次的基础上按照时间间隔分配一个新的 version。由于 Master 分配的 version 的大小和时间也有一定关系，所以 <code class="language-plaintext highlighter-rouge">GetCommitVersionReply</code> 中会携带前一个事务的 commit version（prev commit version） 和新分配的 commit version。</p>

<p>拿到新 commit version 后，commit proxy 会按照顺序给这一批事务分配 versionstamp，它由两部分组成 <code class="language-plaintext highlighter-rouge">&lt;commit version, group id&gt;</code>，其中 group id 是事务在本批次队列中的序号。</p>

<blockquote>
  <p>FoundationDB 的原子操作中支持将 key 或者 value 的某部分替换成 versionstamp，用于在 client 侧确定一个唯一的事务，分配 versionstamp 的意义就在此。</p>
</blockquote>

<p>分配好 versionstamp 后，Commit proxy 会检查每个事务的改动（mutation），并替换掉其中需要设置 versionstamp 的部分 mutation。</p>

<h3 id="解决事务冲突">解决事务冲突</h3>

<p>Resolver 负责解决事务冲突，Commit proxy 会将事务的 read ranges 和 write ranges 以及事务的 prev commit version，commit version 一起通过 <code class="language-plaintext highlighter-rouge">ResolveTransactionBatchRequest</code> 发送给 Resolver 。</p>

<p>Resolver 会按照事务 version 顺序处理每个到达请求，事务间的顺序依靠 prev commit version 和 commit version 一起组织起来。如果事务与之前已经提交的事务不存在 read-write confliction，那么就可以提交；否则事务应该被拒绝。</p>

<h3 id="持久化-mutation">持久化 mutation</h3>

<p>解决事务间冲突后，需要将 mutations 通过 <code class="language-plaintext highlighter-rouge">TLogCommitRequest</code> 发送给 TLog 完成持久化。集群中可能有多个 TLog 实例，那么这些 mutations 会被发送给每一个 TLog，所有 TLog 完成持久化后，事务才算完成提交。（实际上 mutations 只会发送给一部分 TLog，剩余的只会发送一个空请求，这部分将在后续的文章中介绍）</p>

<p>如果某个事务被拒绝提交，那么它的 mutations 不会被发送到 TLog 持久化。由于 TLog 也是按照事务的 version 顺序依次持久化，所以尽管某一批事务请求都拒绝，Commit proxy 仍然需要发送 <code class="language-plaintext highlighter-rouge">TLogCommitRequest</code> 给 TLog ，这样 TLog 才能知道何时可以持久化后续的 mutations。</p>

<h3 id="响应事务提交结果">响应事务提交结果</h3>

<p>一旦事务的 mutations 成功持久化到 TLog 后，就算完成了提交请求，但是在回复 client 前，Commit proxy 还需要发送 <code class="language-plaintext highlighter-rouge">ReportRawCommittedRequest</code> 给 Master 以更新后者内存中记录的最大的已提交事务的 version。所以，FoundationDB 保证如果 client 收到了提交事务的回复，那么它再开启的新事务一定能够读取到此前已经提交的数据。</p>

<h3 id="异步-apply-mutations">异步 apply mutations</h3>

<p>存储系统中的 Storage 会发送 <code class="language-plaintext highlighter-rouge">TLogPeek</code> 请求，从 TLog 中获取新写入的 mutations，并完成 apply。</p>

<p>到此为止，整个提交事务的流程就介绍完了。其中的一些细节，比如事务冲突处理、TLog 如何持久化 mutations，将在后续的文章中一一介绍。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[前一篇文章 FoundationDB 架构概述 从全局视角介绍了 FoundationDB 架构的特点，这篇文章将介绍 FoundationDB 写事务的处理流程以及各个组件间是如何沟通协作的。 Open Database 在与 FoundationDB 集群交互前，client 需要先执行 open database。 执行 open database 时，client 会从 fdb.cluster 文件中获取 connection string，后者指向了集群中的 coordinators；client 发送 OpenDatabaseCoordRequest 请求给 coordinator 进行验证，并获取 ClientDBInfo。 ClientDBInfo 中记录了集群中 GRV proxy 和 Commit proxy 的地址，后续的写请求会用到这两个 proxy 的地址。 提交事务 FoundationDB 依赖一个全局单调递增的时间戳来提供多版本并发控制。每个事务提交时，会分配一个新的版本（Version）；事务间按照 version 大小确定唯一的提交顺序。 FoundationDB 支持交互式事务，开启事务时会获取之前已经提交的最大的事务 version，并在一段时间后才会提交，所以事务间可能存在冲突。FoundationDB 通过检测事务间的 read-write confliction 来避免快照隔离（snapshot isolation, si）带来的 write skew，从而取得序列化快照隔离（serializable snapshot isolation, ssi）。 上述实现又称 write snapshot isolation, 出处见论文： A critique of snapshot isolation。 最后，可以提交的事务会写入 TLog 中完成持久化，再异步地发送到存储系统中。 上图展示了一个写事务提交的完整交互流程，接下来将按照上图详细分析各个流程。 开启新事务时，需要确定新事务的可见范围，也就是当前事务执行时有哪些事务已经提交。为此，Client 会发送 GetReadVersionRequest 给 GRV proxy 以查询已经提交的最大的事务 version；后者积攒一批请求后，发送 GetRawCommitVersionRequest 给 Master 节点，查询记录在 Master 内存中的已经提交的最大的事务 version。 之后的任何写入操作会暂存在 client 的内存中，同时记录下读请求的范围供后续检测事务间的冲突。（读事务的处理流程将在后续的文章中介绍。） 暂存在 client 内存中的数据在提交时通过 CommitTransactionRequest 发送给 Commit proxy，后者将提交过程分成几个步骤： 获取 commit version 解决事务冲突 持久化改动 响应事务提交结果 获取 commit version Commit proxy 积攒一批请求后，发送 GetCommitVersionRequest 给 Master 以获取一个新的提交 version 以及确定事务间的顺序。Master 内存中记录着上一次分配（前一个事务）的 commit version，在上一次的基础上按照时间间隔分配一个新的 version。由于 Master 分配的 version 的大小和时间也有一定关系，所以 GetCommitVersionReply 中会携带前一个事务的 commit version（prev commit version） 和新分配的 commit version。 拿到新 commit version 后，commit proxy 会按照顺序给这一批事务分配 versionstamp，它由两部分组成 &lt;commit version, group id&gt;，其中 group id 是事务在本批次队列中的序号。 FoundationDB 的原子操作中支持将 key 或者 value 的某部分替换成 versionstamp，用于在 client 侧确定一个唯一的事务，分配 versionstamp 的意义就在此。 分配好 versionstamp 后，Commit proxy 会检查每个事务的改动（mutation），并替换掉其中需要设置 versionstamp 的部分 mutation。 解决事务冲突 Resolver 负责解决事务冲突，Commit proxy 会将事务的 read ranges 和 write ranges 以及事务的 prev commit version，commit version 一起通过 ResolveTransactionBatchRequest 发送给 Resolver 。 Resolver 会按照事务 version 顺序处理每个到达请求，事务间的顺序依靠 prev commit version 和 commit version 一起组织起来。如果事务与之前已经提交的事务不存在 read-write confliction，那么就可以提交；否则事务应该被拒绝。 持久化 mutation 解决事务间冲突后，需要将 mutations 通过 TLogCommitRequest 发送给 TLog 完成持久化。集群中可能有多个 TLog 实例，那么这些 mutations 会被发送给每一个 TLog，所有 TLog 完成持久化后，事务才算完成提交。（实际上 mutations 只会发送给一部分 TLog，剩余的只会发送一个空请求，这部分将在后续的文章中介绍） 如果某个事务被拒绝提交，那么它的 mutations 不会被发送到 TLog 持久化。由于 TLog 也是按照事务的 version 顺序依次持久化，所以尽管某一批事务请求都拒绝，Commit proxy 仍然需要发送 TLogCommitRequest 给 TLog ，这样 TLog 才能知道何时可以持久化后续的 mutations。 响应事务提交结果 一旦事务的 mutations 成功持久化到 TLog 后，就算完成了提交请求，但是在回复 client 前，Commit proxy 还需要发送 ReportRawCommittedRequest 给 Master 以更新后者内存中记录的最大的已提交事务的 version。所以，FoundationDB 保证如果 client 收到了提交事务的回复，那么它再开启的新事务一定能够读取到此前已经提交的数据。 异步 apply mutations 存储系统中的 Storage 会发送 TLogPeek 请求，从 TLog 中获取新写入的 mutations，并完成 apply。 到此为止，整个提交事务的流程就介绍完了。其中的一些细节，比如事务冲突处理、TLog 如何持久化 mutations，将在后续的文章中一一介绍。]]></summary></entry><entry><title type="html">FoundationDB 架构 - 概述</title><link href="/2023/08/12/FDB-arch-overview.html" rel="alternate" type="text/html" title="FoundationDB 架构 - 概述" /><published>2023-08-12T00:00:00+08:00</published><updated>2023-08-12T00:00:00+08:00</updated><id>/2023/08/12/FDB-arch-overview</id><content type="html" xml:base="/2023/08/12/FDB-arch-overview.html"><![CDATA[<p><img src="https://www.foundationdb.org/assets/images/logo@2x-e7437ad1.png" alt="FDB" /></p>

<p>FoundationDB 是一款分布式强一致、高可扩展的 key value 数据库，它提供多版本并发控制（MVCC），同时提供了可序列化快照隔离级别（SSI）。</p>

<p>这里将从架构、元数据组织、数据组织三个方面，简述 FoundationDB 的架构设计，更详细的设计细节会在后续文章中介绍。</p>

<h2 id="架构">架构</h2>

<p>总的来说，FoundationDB 的架构可以分成三部分：控制系统，事务系统以及存储系统。</p>

<p><img src="assets/FDB-arch-overview-imgs/architecture.png" alt="FoundationDB Architecture" /></p>

<p>控制系统部分提供了类似 zookeeper, etcd 等元数据管理系统的功能。它使用 disk paxos 实现选举、协调与元数据多副本的一致性。</p>

<p>存储系统是依赖单机 key value store 构建的一个多副本的 key value store。底层的 kv store 支持多种实现，目前有：sqlite （default），redwood 和 rocksdb。其中 redwood 是一款用于替代 sqlite 的基于 btree 的 kv store，目前主要是 snowflake 在负责开发。根据反馈，使用 redwood 作为引擎底座，在性能上比依赖 sqlite 的版本强上不少。</p>

<p>最复杂的是事务系统，它所涉及的组件最多。事务系统主要解决两个问题：</p>
<ol>
  <li>写入事务的持久化，类似于单机 RDMS 的 WAL</li>
  <li>判断事务间是否存在冲突，是否能够提交。</li>
</ol>

<h2 id="元数据">元数据</h2>

<p><img src="assets/FDB-arch-overview-imgs/metadata.png" alt="Metadata" /></p>

<p>FoundationDB 的元数据组织也可以按架构分成三部分。每个 FoundationDB 集群有一个唯一的地址，保存在 <code class="language-plaintext highlighter-rouge">fdb.cluster</code> 文件中；通过这个地址，可以定位到控制系统。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>description:ID@IP:PORT,IP:PORT,...
</code></pre></div></div>

<p>控制系统中记录了事务系统的元数据，TLog 的位置、当前事务系统的版本号，都记录在控制系统中；client 也能通过查询控制系统，获取到事务系统的路由表。</p>

<p>事务系统中又记录着存储系统的元数据，key 到 storage 的映射就保存在事务系统中。</p>

<p>通过上述的层级关系，任何一个 client 或 server 只要能拿到 <code class="language-plaintext highlighter-rouge">fdb.cluster</code>，就能访问到集群中的任何一个节点。</p>

<h2 id="数据组织">数据组织</h2>

<p><img src="assets/FDB-arch-overview-imgs/keyspace.png" alt="Key space" /></p>

<p>FoundationDB 将 key space 划分成两部分，其中前缀为 <code class="language-plaintext highlighter-rouge">0xFF</code> 的被保留为系统空间，也就是记录在事务系统中的存储系统的元数据。</p>

<p>剩余的 <code class="language-plaintext highlighter-rouge">[0x00, 0xFF)</code> 则用于存储用户数据。用户数据会按照 range 切分成一个个 shard，一个 shard 有多个副本，保存在不同的 storage server 上。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[FoundationDB 是一款分布式强一致、高可扩展的 key value 数据库，它提供多版本并发控制（MVCC），同时提供了可序列化快照隔离级别（SSI）。 这里将从架构、元数据组织、数据组织三个方面，简述 FoundationDB 的架构设计，更详细的设计细节会在后续文章中介绍。 架构 总的来说，FoundationDB 的架构可以分成三部分：控制系统，事务系统以及存储系统。 控制系统部分提供了类似 zookeeper, etcd 等元数据管理系统的功能。它使用 disk paxos 实现选举、协调与元数据多副本的一致性。 存储系统是依赖单机 key value store 构建的一个多副本的 key value store。底层的 kv store 支持多种实现，目前有：sqlite （default），redwood 和 rocksdb。其中 redwood 是一款用于替代 sqlite 的基于 btree 的 kv store，目前主要是 snowflake 在负责开发。根据反馈，使用 redwood 作为引擎底座，在性能上比依赖 sqlite 的版本强上不少。 最复杂的是事务系统，它所涉及的组件最多。事务系统主要解决两个问题： 写入事务的持久化，类似于单机 RDMS 的 WAL 判断事务间是否存在冲突，是否能够提交。 元数据 FoundationDB 的元数据组织也可以按架构分成三部分。每个 FoundationDB 集群有一个唯一的地址，保存在 fdb.cluster 文件中；通过这个地址，可以定位到控制系统。 description:ID@IP:PORT,IP:PORT,... 控制系统中记录了事务系统的元数据，TLog 的位置、当前事务系统的版本号，都记录在控制系统中；client 也能通过查询控制系统，获取到事务系统的路由表。 事务系统中又记录着存储系统的元数据，key 到 storage 的映射就保存在事务系统中。 通过上述的层级关系，任何一个 client 或 server 只要能拿到 fdb.cluster，就能访问到集群中的任何一个节点。 数据组织 FoundationDB 将 key space 划分成两部分，其中前缀为 0xFF 的被保留为系统空间，也就是记录在事务系统中的存储系统的元数据。 剩余的 [0x00, 0xFF) 则用于存储用户数据。用户数据会按照 range 切分成一个个 shard，一个 shard 有多个副本，保存在不同的 storage server 上。]]></summary></entry><entry><title type="html">FoundationDB exclude command</title><link href="/2023/07/20/FDB-exclude-cmd.html" rel="alternate" type="text/html" title="FoundationDB exclude command" /><published>2023-07-20T00:00:00+08:00</published><updated>2023-07-20T00:00:00+08:00</updated><id>/2023/07/20/FDB-exclude-cmd</id><content type="html" xml:base="/2023/07/20/FDB-exclude-cmd.html"><![CDATA[<h1 id="背景">背景</h1>

<p>从<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODgyOTg5NA==&amp;mid=2247483676&amp;idx=1&amp;sn=3f8175c1b2996a9690ac620e053b9034&amp;chksm=fdd784b5caa00da338f85dc606152eda51c25bdd7c052370fdc6de3dc789fede709a6437f7fe&amp;=873428723&amp;=zh_CN#rd">FoundationDB 源码阅读：maintenace 模式的作用</a>中可知 FDB 的 <code class="language-plaintext highlighter-rouge">maintenance</code> 模式并不会主动触发 recruit 流程，如果待操作的机器上有 transaction system 的进程，那么重启操作将会引起 3~5s 的服务中断，原因是等待直到 failure detectors 判断机器故障后，cluster controller 才会触发 recruit 流程。</p>

<p>我们需要找到一个机制触发 recruit 流程，同时不触发任何数据迁移，使用 <code class="language-plaintext highlighter-rouge">exclude</code> 和 <code class="language-plaintext highlighter-rouge">maintenance</code> 配合是否能够取得这个目标呢？这就是本文研究的目的。</p>

<p>FDB 的 <code class="language-plaintext highlighter-rouge">exclude</code> 命令用于在不影响可用性和容错的情况下，从集群中临时或永久地移除机器、进程。详情参考：<a href="https://apple.github.io/foundationdb/administration.html#removing-machines-from-a-cluster" title="removing-machines-from-a-cluster">removing-machines-from-a-cluster</a>。</p>

<h1 id="代码分析">代码分析</h1>

<h2 id="设置-exclude-选项">设置 exclude 选项</h2>

<p>在 fdbcli 中输入 exclude ip:port no_wait 后，会进入 excludeCommandActor(fdbcli/ExcludeCommand.actor.cpp)；完成一系列检查后和准备后，进入 excludeSeversAndLocalities：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ACTOR</span> <span class="n">Future</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">excludeServersAndLocalities</span><span class="p">(</span><span class="n">Reference</span><span class="o">&lt;</span><span class="n">IDatabase</span><span class="o">&gt;</span> <span class="n">db</span><span class="p">,</span>
                                               <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AddressExclusion</span><span class="o">&gt;</span> <span class="n">servers</span><span class="p">,</span>
                                               <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">localities</span><span class="p">,</span>
                                               <span class="kt">bool</span> <span class="n">failed</span><span class="p">,</span>
                                               <span class="kt">bool</span> <span class="n">force</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">state</span> <span class="n">Reference</span><span class="o">&lt;</span><span class="n">ITransaction</span><span class="o">&gt;</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">createTransaction</span><span class="p">();</span>
    <span class="n">loop</span> <span class="p">{</span>
        <span class="n">tr</span><span class="o">-&gt;</span><span class="n">setOption</span><span class="p">(</span><span class="n">FDBTransactionOptions</span><span class="o">::</span><span class="n">SPECIAL_KEY_SPACE_ENABLE_WRITES</span><span class="p">);</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">&amp;&amp;</span> <span class="n">servers</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
                <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">failed</span> <span class="o">?</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">failedForceOptionSpecialKey</span> <span class="o">:</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">excludedForceOptionSpecialKey</span><span class="p">,</span>
                        <span class="n">ValueRef</span><span class="p">());</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">s</span> <span class="o">:</span> <span class="n">servers</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Key</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">failed</span> <span class="o">?</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">failedServersSpecialKeyRange</span><span class="p">.</span><span class="n">begin</span><span class="p">.</span><span class="n">withSuffix</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">toString</span><span class="p">())</span>
                                  <span class="o">:</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">excludedServersSpecialKeyRange</span><span class="p">.</span><span class="n">begin</span><span class="p">.</span><span class="n">withSuffix</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">toString</span><span class="p">());</span>
                <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">ValueRef</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">&amp;&amp;</span> <span class="n">localities</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
                <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">failed</span> <span class="o">?</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">failedLocalityForceOptionSpecialKey</span>
                               <span class="o">:</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">excludedLocalityForceOptionSpecialKey</span><span class="p">,</span>
                        <span class="n">ValueRef</span><span class="p">());</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">l</span> <span class="o">:</span> <span class="n">localities</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Key</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">failed</span> <span class="o">?</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">failedLocalitySpecialKeyRange</span><span class="p">.</span><span class="n">begin</span><span class="p">.</span><span class="n">withSuffix</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                                  <span class="o">:</span> <span class="n">fdb_cli</span><span class="o">::</span><span class="n">excludedLocalitySpecialKeyRange</span><span class="p">.</span><span class="n">begin</span><span class="p">.</span><span class="n">withSuffix</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
                <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">ValueRef</span><span class="p">());</span>
            <span class="p">}</span>
            <span class="n">wait</span><span class="p">(</span><span class="n">safeThreadFutureToFuture</span><span class="p">(</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">()))</span>
</code></pre></div></div>

<p>severs 最终保存到 <code class="language-plaintext highlighter-rouge">excludedServersSpecialKeyRange</code> 中。注意到 transaction 设置了 <code class="language-plaintext highlighter-rouge">SPECIAL_KEY_SPACE_ENABLE_WRITES</code>，在提交给 fdbserver 前，fdbclient 会对 key value 做一些修饰。exclude 对应的 impl 为 <code class="language-plaintext highlighter-rouge">ExcludeServersRangeImpl</code>(<code class="language-plaintext highlighter-rouge">fdbclient/SpecialKeySpace.actor.cpp</code>)，完成检查后，进入 <code class="language-plaintext highlighter-rouge">excludeServers</code>(<code class="language-plaintext highlighter-rouge">fdbclient/ManagementAPI.actor.cpp</code>):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ACTOR</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">excludeServers</span><span class="p">(</span><span class="n">Transaction</span><span class="o">*</span> <span class="n">tr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AddressExclusion</span><span class="o">&gt;</span> <span class="n">servers</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">failed</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tr</span><span class="o">-&gt;</span><span class="n">setOption</span><span class="p">(</span><span class="n">FDBTransactionOptions</span><span class="o">::</span><span class="n">ACCESS_SYSTEM_KEYS</span><span class="p">);</span>
    <span class="n">tr</span><span class="o">-&gt;</span><span class="n">setOption</span><span class="p">(</span><span class="n">FDBTransactionOptions</span><span class="o">::</span><span class="n">PRIORITY_SYSTEM_IMMEDIATE</span><span class="p">);</span>
    <span class="n">tr</span><span class="o">-&gt;</span><span class="n">setOption</span><span class="p">(</span><span class="n">FDBTransactionOptions</span><span class="o">::</span><span class="n">LOCK_AWARE</span><span class="p">);</span>
    <span class="n">tr</span><span class="o">-&gt;</span><span class="n">setOption</span><span class="p">(</span><span class="n">FDBTransactionOptions</span><span class="o">::</span><span class="n">USE_PROVISIONAL_PROXIES</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AddressExclusion</span><span class="o">&gt;</span> <span class="n">excl</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="n">failed</span> <span class="o">?</span> <span class="n">getExcludedFailedServerList</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span> <span class="o">:</span> <span class="n">getExcludedServerList</span><span class="p">(</span><span class="n">tr</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">AddressExclusion</span><span class="o">&gt;</span> <span class="n">exclusions</span><span class="p">(</span><span class="n">excl</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">excl</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="kt">bool</span> <span class="n">containNewExclusion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">s</span> <span class="o">:</span> <span class="n">servers</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">exclusions</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="n">exclusions</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">containNewExclusion</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">failed</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">encodeFailedServersKey</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">StringRef</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">encodeExcludedServersKey</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">StringRef</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">containNewExclusion</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">excludeVersionKey</span> <span class="o">=</span> <span class="n">deterministicRandom</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">randomUniqueID</span><span class="p">().</span><span class="n">toString</span><span class="p">();</span>
        <span class="k">auto</span> <span class="n">serversVersionKey</span> <span class="o">=</span> <span class="n">failed</span> <span class="o">?</span> <span class="n">failedServersVersionKey</span> <span class="o">:</span> <span class="n">excludedServersVersionKey</span><span class="p">;</span>
        <span class="n">tr</span><span class="o">-&gt;</span><span class="n">addReadConflictRange</span><span class="p">(</span><span class="n">singleKeyRange</span><span class="p">(</span><span class="n">serversVersionKey</span><span class="p">));</span> <span class="c1">// To conflict with parallel includeServers</span>
        <span class="n">tr</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">serversVersionKey</span><span class="p">,</span> <span class="n">excludeVersionKey</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>最终写入到 key <code class="language-plaintext highlighter-rouge">\xff\xff/conf/excluded/$server</code> 中。</p>

<h2 id="标记-worker-为-excluded">标记 worker 为 excluded</h2>

<p>fdbserver 的 cluster controller 在执行完 cluster recovery 后，会启动一个 actor <code class="language-plaintext highlighter-rouge">configurationMonitor</code> （<code class="language-plaintext highlighter-rouge">fdbserver/ClusterRecovery.actor.cpp</code>）监听 <code class="language-plaintext highlighter-rouge">excludedServersVersionKey</code> 的变化。一旦发生变化，则重新读取 <code class="language-plaintext highlighter-rouge">DatabaseConfiguration</code>，当其与内存中记录的 configuration 不同时触发 registration：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RangeResult</span> <span class="n">results</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="n">tr</span><span class="p">.</span><span class="n">getRange</span><span class="p">(</span><span class="n">configKeys</span><span class="p">,</span> <span class="n">CLIENT_KNOBS</span><span class="o">-&gt;</span><span class="n">TOO_MANY</span><span class="p">));</span>
<span class="n">ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">results</span><span class="p">.</span><span class="n">more</span> <span class="o">&amp;&amp;</span> <span class="n">results</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">CLIENT_KNOBS</span><span class="o">-&gt;</span><span class="n">TOO_MANY</span><span class="p">);</span>

<span class="n">DatabaseConfiguration</span> <span class="n">conf</span><span class="p">;</span>
<span class="n">conf</span><span class="p">.</span><span class="n">fromKeyValues</span><span class="p">((</span><span class="n">VectorRef</span><span class="o">&lt;</span><span class="n">KeyValueRef</span><span class="o">&gt;</span><span class="p">)</span><span class="n">results</span><span class="p">);</span>
<span class="n">TraceEvent</span><span class="p">(</span><span class="s">"ConfigurationMonitor"</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">dbgid</span><span class="p">)</span>
    <span class="p">.</span><span class="n">detail</span><span class="p">(</span><span class="n">getRecoveryEventName</span><span class="p">(</span><span class="n">ClusterRecoveryEventType</span><span class="o">::</span><span class="n">CLUSTER_RECOVERY_STATE_EVENT_NAME</span><span class="p">).</span><span class="n">c_str</span><span class="p">(),</span>
            <span class="n">self</span><span class="o">-&gt;</span><span class="n">recoveryState</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">conf</span> <span class="o">!=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">configuration</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">recoveryState</span> <span class="o">!=</span> <span class="n">RecoveryState</span><span class="o">::</span><span class="n">ALL_LOGS_RECRUITED</span> <span class="o">&amp;&amp;</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">recoveryState</span> <span class="o">!=</span> <span class="n">RecoveryState</span><span class="o">::</span><span class="n">FULLY_RECOVERED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="o">-&gt;</span><span class="n">controllerData</span><span class="o">-&gt;</span><span class="n">shouldCommitSuicide</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">throw</span> <span class="n">restart_cluster_controller</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">self</span><span class="o">-&gt;</span><span class="n">configuration</span> <span class="o">=</span> <span class="n">conf</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">registrationTrigger</span><span class="p">.</span><span class="n">trigger</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另一个 actor <code class="language-plaintext highlighter-rouge">updateRegistration</code> 会等待 <code class="language-plaintext highlighter-rouge">registrationTrigger</code>，最后调用 <code class="language-plaintext highlighter-rouge">sendMasterRegistration</code> ；后者将新的 configuration 通过 <code class="language-plaintext highlighter-rouge">RegisterMasterRequest</code> 发送给 cluster controller。</p>

<p>Cluster controller 的 <code class="language-plaintext highlighter-rouge">clusterRegisterMaster</code>(<code class="language-plaintext highlighter-rouge">fdbserver/ClusterController.actor.cpp</code>) 负责处理 <code class="language-plaintext highlighter-rouge">RegisterMasterRequest</code> 。对于每一个 worker，cluster controller 会将其信息记录在 <code class="language-plaintext highlighter-rouge">WorkerInfo</code> 中；<code class="language-plaintext highlighter-rouge">WorkerInfo</code> 的成员 <code class="language-plaintext highlighter-rouge">priorityInfo</code> 中记录了 <code class="language-plaintext highlighter-rouge">isExcluded</code> 字段，表示是否通过 <code class="language-plaintext highlighter-rouge">exclude</code> 命令标记。<code class="language-plaintext highlighter-rouge">clusterRegisterMaster</code> 会遍历 <code class="language-plaintext highlighter-rouge">RegisterMasterRequest</code> 中携带的 configuration，并将 excluded 的 server 标记为 <code class="language-plaintext highlighter-rouge">isExcluded = true</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">db</span><span class="o">-&gt;</span><span class="n">fullyRecoveredConfig</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">configuration</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">it</span> <span class="o">:</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">id_worker</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">isExcludedFromConfig</span> <span class="o">=</span>
        <span class="n">db</span><span class="o">-&gt;</span><span class="n">fullyRecoveredConfig</span><span class="p">.</span><span class="n">isExcludedServer</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">details</span><span class="p">.</span><span class="n">interf</span><span class="p">.</span><span class="n">addresses</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">priorityInfo</span><span class="p">.</span><span class="n">isExcluded</span> <span class="o">!=</span> <span class="n">isExcludedFromConfig</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">priorityInfo</span><span class="p">.</span><span class="n">isExcluded</span> <span class="o">=</span> <span class="n">isExcludedFromConfig</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">reply</span><span class="p">.</span><span class="n">isSet</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">reply</span><span class="p">.</span><span class="n">send</span><span class="p">(</span>
                <span class="n">RegisterWorkerReply</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">details</span><span class="p">.</span><span class="n">processClass</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">priorityInfo</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="执行-recruit">执行 recruit</h2>

<p>除了标记 <code class="language-plaintext highlighter-rouge">isExcluded</code> 外，<code class="language-plaintext highlighter-rouge">clusterRegisterMaster</code> 还会启动一个 actor <code class="language-plaintext highlighter-rouge">doCheckOutstandingRequests</code>（<code class="language-plaintext highlighter-rouge">fdbserver/ClusterController.actor.cpp</code>）；后者会调用 <code class="language-plaintext highlighter-rouge">ClusterControllerData::betterMasterExists</code>：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">betterMasterExists</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">forceMasterFailure</span><span class="p">.</span><span class="n">trigger</span><span class="p">();</span>
    <span class="n">TraceEvent</span><span class="p">(</span><span class="s">"MasterRegistrationKill"</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">).</span><span class="n">detail</span><span class="p">(</span><span class="s">"MasterId"</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">serverInfo</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">().</span><span class="n">master</span><span class="p">.</span><span class="n">id</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">betterMasterExists</code> 会依次遍历 TLog, commit proxy, GRV proxy, resolver，任何一个 process 所在的 worker 的 <code class="language-plaintext highlighter-rouge">isExcluded</code> 为 <code class="language-plaintext highlighter-rouge">true</code>，都会返回 <code class="language-plaintext highlighter-rouge">true</code>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (commitProxyWorker-&gt;second.priorityInfo.isExcluded) {
    TraceEvent("BetterMasterExists", id)
        .detail("Reason", "CommitProxyExcluded")
        .detail("ProcessID", it.processId);
    return true;
}
</code></pre></div></div>

<p>最后 <code class="language-plaintext highlighter-rouge">forceMasterFailure</code> 会唤醒 <code class="language-plaintext highlighter-rouge">clusterWatchDatabase</code> ，后者做一些当前 epoch 的清理工作后，重新调用：<code class="language-plaintext highlighter-rouge">clusterRecoveryCore</code> 启动新阶段的 transaction system。</p>

<h2 id="storage-会迁移吗">Storage 会迁移吗？</h2>

<p>fdbserver 还有一个 <code class="language-plaintext highlighter-rouge">ExclusionTracker</code>，它负责监听 <code class="language-plaintext highlighter-rouge">excludedServersVersionKey</code>（<code class="language-plaintext highlighter-rouge">fdbserver/include/fdbserver/ExclusionTracker.actor.h</code>)。一旦 excluded servers 发生变化，它会唤醒 ACTOR <code class="language-plaintext highlighter-rouge">trackExcludedServers</code> (<code class="language-plaintext highlighter-rouge">fdbserver/DDTeamCollection.actor.cpp</code>)；后者最终会唤醒 <code class="language-plaintext highlighter-rouge">DDTeamCollectionImpl::storageRecruiter</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ACTOR</span> <span class="k">static</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">trackExcludedServers</span><span class="p">(</span><span class="n">DDTeamCollection</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">state</span> <span class="n">ExclusionTracker</span> <span class="n">exclusionTracker</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">dbContext</span><span class="p">());</span>
    <span class="n">loop</span> <span class="p">{</span>
        <span class="c1">// wait for new set of excluded servers</span>
        <span class="n">wait</span><span class="p">(</span><span class="n">exclusionTracker</span><span class="p">.</span><span class="n">changed</span><span class="p">.</span><span class="n">onTrigger</span><span class="p">());</span>

        <span class="k">auto</span> <span class="n">old</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">getKeys</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">o</span> <span class="o">:</span> <span class="n">old</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exclusionTracker</span><span class="p">.</span><span class="n">excluded</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">exclusionTracker</span><span class="p">.</span><span class="n">failed</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                <span class="o">!</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                  <span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">==</span> <span class="n">DDTeamCollection</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">WIGGLING</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">DDTeamCollection</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">NONE</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">n</span> <span class="o">:</span> <span class="n">exclusionTracker</span><span class="p">.</span><span class="n">excluded</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exclusionTracker</span><span class="p">.</span><span class="n">failed</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">DDTeamCollection</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">EXCLUDED</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="p">...</span>

        <span class="n">self</span><span class="o">-&gt;</span><span class="n">restartRecruiting</span><span class="p">.</span><span class="n">trigger</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">storageRecruiter</code> 会收集信息并发送 <code class="language-plaintext highlighter-rouge">RecruitStorageRequest</code> 给 cluster controller:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">AddressExclusion</span><span class="o">&gt;</span> <span class="n">exclusions</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">excl</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">getKeys</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">s</span> <span class="o">:</span> <span class="n">excl</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">excludedServers</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DDTeamCollection</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">TraceEvent</span><span class="p">(</span><span class="n">SevDebug</span><span class="p">,</span> <span class="s">"DDRecruitExcl2"</span><span class="p">)</span>
            <span class="p">.</span><span class="n">detail</span><span class="p">(</span><span class="s">"Primary"</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">primary</span><span class="p">)</span>
            <span class="p">.</span><span class="n">detail</span><span class="p">(</span><span class="s">"Excluding"</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">toString</span><span class="p">());</span>
        <span class="n">exclusions</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">:</span> <span class="n">exclusions</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rsr</span><span class="p">.</span><span class="n">excludeAddresses</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fCandidateWorker</span><span class="p">.</span><span class="n">isValid</span><span class="p">()</span> <span class="o">||</span> <span class="n">fCandidateWorker</span><span class="p">.</span><span class="n">isReady</span><span class="p">()</span> <span class="o">||</span>
    <span class="n">rsr</span><span class="p">.</span><span class="n">excludeAddresses</span> <span class="o">!=</span> <span class="n">lastRequest</span><span class="p">.</span><span class="n">excludeAddresses</span> <span class="o">||</span>
    <span class="n">rsr</span><span class="p">.</span><span class="n">criticalRecruitment</span> <span class="o">!=</span> <span class="n">lastRequest</span><span class="p">.</span><span class="n">criticalRecruitment</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lastRequest</span> <span class="o">=</span> <span class="n">rsr</span><span class="p">;</span>
    <span class="n">fCandidateWorker</span> <span class="o">=</span>
        <span class="n">brokenPromiseToNever</span><span class="p">(</span><span class="n">recruitStorage</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">().</span><span class="n">getReply</span><span class="p">(</span><span class="n">rsr</span><span class="p">,</span> <span class="n">TaskPriority</span><span class="o">::</span><span class="n">DataDistribution</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>前边设置好的 exclude 会被放到请求的 <code class="language-plaintext highlighter-rouge">excludeAddresses</code> 字段中。cluster controller 会根据请求条件过滤掉不合适的 worker（<code class="language-plaintext highlighter-rouge">fdbserver/include/fdbserver/ClusterController.actor.h</code>:<code class="language-plaintext highlighter-rouge">ClusterControllerData::getStorageWorker</code>）。收到 response 后，<code class="language-plaintext highlighter-rouge">storageRecruiter</code> 会发送 <code class="language-plaintext highlighter-rouge">InitialStorageRequest</code> 给目标进程，完成 recruit 流程。</p>

<p>可以发现，这个过程中并没有判断 storage process 的 failure status，而是直接发送 <code class="language-plaintext highlighter-rouge">RecruitStorageRequest</code>。那么这就意味着不能手动临时 exclude 任何一个 storage，否则都会触发数据迁移。</p>

<h1 id="结论">结论</h1>

<p>通过分析，<code class="language-plaintext highlighter-rouge">exclude</code> 命令的确可以主动触发 recruit 流程，同时如果 process 上有 storage role，它还出触发 recruit storage 流程。</p>

<p>如果我们现在需要取得平滑升级的能力，那么需要以下几个步骤：</p>

<ol>
  <li>列出所有的 process 的 role，如果目标机器上某个 process 有 transaction system 的 role （非 coordinator，非 storage），那么执行 <code class="language-plaintext highlighter-rouge">exclude $IP:$PORT</code></li>
  <li>等到 recovery 完成后，执行 <code class="language-plaintext highlighter-rouge">maintenance on $zone-id</code>，表示禁用 storage process 的 failure detector</li>
  <li>修改配置、重启</li>
  <li>执行 <code class="language-plaintext highlighter-rouge">maintenance off</code></li>
  <li>执行 <code class="language-plaintext highlighter-rouge">include $IP:$PORT</code>，允许 transaction system 的 role 调度回该机器</li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[背景 从FoundationDB 源码阅读：maintenace 模式的作用中可知 FDB 的 maintenance 模式并不会主动触发 recruit 流程，如果待操作的机器上有 transaction system 的进程，那么重启操作将会引起 3~5s 的服务中断，原因是等待直到 failure detectors 判断机器故障后，cluster controller 才会触发 recruit 流程。 我们需要找到一个机制触发 recruit 流程，同时不触发任何数据迁移，使用 exclude 和 maintenance 配合是否能够取得这个目标呢？这就是本文研究的目的。 FDB 的 exclude 命令用于在不影响可用性和容错的情况下，从集群中临时或永久地移除机器、进程。详情参考：removing-machines-from-a-cluster。 代码分析 设置 exclude 选项 在 fdbcli 中输入 exclude ip:port no_wait 后，会进入 excludeCommandActor(fdbcli/ExcludeCommand.actor.cpp)；完成一系列检查后和准备后，进入 excludeSeversAndLocalities： ACTOR Future&lt;bool&gt; excludeServersAndLocalities(Reference&lt;IDatabase&gt; db, std::vector&lt;AddressExclusion&gt; servers, std::unordered_set&lt;std::string&gt; localities, bool failed, bool force) { state Reference&lt;ITransaction&gt; tr = db-&gt;createTransaction(); loop { tr-&gt;setOption(FDBTransactionOptions::SPECIAL_KEY_SPACE_ENABLE_WRITES); try { if (force &amp;&amp; servers.size()) tr-&gt;set(failed ? fdb_cli::failedForceOptionSpecialKey : fdb_cli::excludedForceOptionSpecialKey, ValueRef()); for (const auto&amp; s : servers) { Key addr = failed ? fdb_cli::failedServersSpecialKeyRange.begin.withSuffix(s.toString()) : fdb_cli::excludedServersSpecialKeyRange.begin.withSuffix(s.toString()); tr-&gt;set(addr, ValueRef()); } if (force &amp;&amp; localities.size()) tr-&gt;set(failed ? fdb_cli::failedLocalityForceOptionSpecialKey : fdb_cli::excludedLocalityForceOptionSpecialKey, ValueRef()); for (const auto&amp; l : localities) { Key addr = failed ? fdb_cli::failedLocalitySpecialKeyRange.begin.withSuffix(l) : fdb_cli::excludedLocalitySpecialKeyRange.begin.withSuffix(l); tr-&gt;set(addr, ValueRef()); } wait(safeThreadFutureToFuture(tr-&gt;commit())) severs 最终保存到 excludedServersSpecialKeyRange 中。注意到 transaction 设置了 SPECIAL_KEY_SPACE_ENABLE_WRITES，在提交给 fdbserver 前，fdbclient 会对 key value 做一些修饰。exclude 对应的 impl 为 ExcludeServersRangeImpl(fdbclient/SpecialKeySpace.actor.cpp)，完成检查后，进入 excludeServers(fdbclient/ManagementAPI.actor.cpp): ACTOR Future&lt;Void&gt; excludeServers(Transaction* tr, std::vector&lt;AddressExclusion&gt; servers, bool failed) { tr-&gt;setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS); tr-&gt;setOption(FDBTransactionOptions::PRIORITY_SYSTEM_IMMEDIATE); tr-&gt;setOption(FDBTransactionOptions::LOCK_AWARE); tr-&gt;setOption(FDBTransactionOptions::USE_PROVISIONAL_PROXIES); std::vector&lt;AddressExclusion&gt; excl = wait(failed ? getExcludedFailedServerList(tr) : getExcludedServerList(tr)); std::set&lt;AddressExclusion&gt; exclusions(excl.begin(), excl.end()); bool containNewExclusion = false; for (auto&amp; s : servers) { if (exclusions.find(s) != exclusions.end()) { continue; } containNewExclusion = true; if (failed) { tr-&gt;set(encodeFailedServersKey(s), StringRef()); } else { tr-&gt;set(encodeExcludedServersKey(s), StringRef()); } } if (containNewExclusion) { std::string excludeVersionKey = deterministicRandom()-&gt;randomUniqueID().toString(); auto serversVersionKey = failed ? failedServersVersionKey : excludedServersVersionKey; tr-&gt;addReadConflictRange(singleKeyRange(serversVersionKey)); // To conflict with parallel includeServers tr-&gt;set(serversVersionKey, excludeVersionKey); } 最终写入到 key \xff\xff/conf/excluded/$server 中。 标记 worker 为 excluded fdbserver 的 cluster controller 在执行完 cluster recovery 后，会启动一个 actor configurationMonitor （fdbserver/ClusterRecovery.actor.cpp）监听 excludedServersVersionKey 的变化。一旦发生变化，则重新读取 DatabaseConfiguration，当其与内存中记录的 configuration 不同时触发 registration： RangeResult results = wait(tr.getRange(configKeys, CLIENT_KNOBS-&gt;TOO_MANY)); ASSERT(!results.more &amp;&amp; results.size() &lt; CLIENT_KNOBS-&gt;TOO_MANY); DatabaseConfiguration conf; conf.fromKeyValues((VectorRef&lt;KeyValueRef&gt;)results); TraceEvent("ConfigurationMonitor", self-&gt;dbgid) .detail(getRecoveryEventName(ClusterRecoveryEventType::CLUSTER_RECOVERY_STATE_EVENT_NAME).c_str(), self-&gt;recoveryState); if (conf != self-&gt;configuration) { if (self-&gt;recoveryState != RecoveryState::ALL_LOGS_RECRUITED &amp;&amp; self-&gt;recoveryState != RecoveryState::FULLY_RECOVERED) { self-&gt;controllerData-&gt;shouldCommitSuicide = true; throw restart_cluster_controller(); } self-&gt;configuration = conf; self-&gt;registrationTrigger.trigger(); } 另一个 actor updateRegistration 会等待 registrationTrigger，最后调用 sendMasterRegistration ；后者将新的 configuration 通过 RegisterMasterRequest 发送给 cluster controller。 Cluster controller 的 clusterRegisterMaster(fdbserver/ClusterController.actor.cpp) 负责处理 RegisterMasterRequest 。对于每一个 worker，cluster controller 会将其信息记录在 WorkerInfo 中；WorkerInfo 的成员 priorityInfo 中记录了 isExcluded 字段，表示是否通过 exclude 命令标记。clusterRegisterMaster 会遍历 RegisterMasterRequest 中携带的 configuration，并将 excluded 的 server 标记为 isExcluded = true: db-&gt;fullyRecoveredConfig = req.configuration.get(); for (auto&amp; it : self-&gt;id_worker) { bool isExcludedFromConfig = db-&gt;fullyRecoveredConfig.isExcludedServer(it.second.details.interf.addresses()); if (it.second.priorityInfo.isExcluded != isExcludedFromConfig) { it.second.priorityInfo.isExcluded = isExcludedFromConfig; if (!it.second.reply.isSet()) { it.second.reply.send( RegisterWorkerReply(it.second.details.processClass, it.second.priorityInfo)); } } } 执行 recruit 除了标记 isExcluded 外，clusterRegisterMaster 还会启动一个 actor doCheckOutstandingRequests（fdbserver/ClusterController.actor.cpp）；后者会调用 ClusterControllerData::betterMasterExists： if (self-&gt;betterMasterExists()) { self-&gt;db.forceMasterFailure.trigger(); TraceEvent("MasterRegistrationKill", self-&gt;id).detail("MasterId", self-&gt;db.serverInfo-&gt;get().master.id()); } betterMasterExists 会依次遍历 TLog, commit proxy, GRV proxy, resolver，任何一个 process 所在的 worker 的 isExcluded 为 true，都会返回 true： if (commitProxyWorker-&gt;second.priorityInfo.isExcluded) { TraceEvent("BetterMasterExists", id) .detail("Reason", "CommitProxyExcluded") .detail("ProcessID", it.processId); return true; } 最后 forceMasterFailure 会唤醒 clusterWatchDatabase ，后者做一些当前 epoch 的清理工作后，重新调用：clusterRecoveryCore 启动新阶段的 transaction system。 Storage 会迁移吗？ fdbserver 还有一个 ExclusionTracker，它负责监听 excludedServersVersionKey（fdbserver/include/fdbserver/ExclusionTracker.actor.h)。一旦 excluded servers 发生变化，它会唤醒 ACTOR trackExcludedServers (fdbserver/DDTeamCollection.actor.cpp)；后者最终会唤醒 DDTeamCollectionImpl::storageRecruiter: ACTOR static Future&lt;Void&gt; trackExcludedServers(DDTeamCollection* self) { state ExclusionTracker exclusionTracker(self-&gt;dbContext()); loop { // wait for new set of excluded servers wait(exclusionTracker.changed.onTrigger()); auto old = self-&gt;excludedServers.getKeys(); for (const auto&amp; o : old) { if (!exclusionTracker.excluded.count(o) &amp;&amp; !exclusionTracker.failed.count(o) &amp;&amp; !(self-&gt;excludedServers.count(o) &amp;&amp; self-&gt;excludedServers.get(o) == DDTeamCollection::Status::WIGGLING)) { self-&gt;excludedServers.set(o, DDTeamCollection::Status::NONE); } } for (const auto&amp; n : exclusionTracker.excluded) { if (!exclusionTracker.failed.count(n)) { self-&gt;excludedServers.set(n, DDTeamCollection::Status::EXCLUDED); } } ... self-&gt;restartRecruiting.trigger(); } } storageRecruiter 会收集信息并发送 RecruitStorageRequest 给 cluster controller: std::set&lt;AddressExclusion&gt; exclusions; auto excl = self-&gt;excludedServers.getKeys(); for (const auto&amp; s : excl) { if (self-&gt;excludedServers.get(s) != DDTeamCollection::Status::NONE) { TraceEvent(SevDebug, "DDRecruitExcl2") .detail("Primary", self-&gt;primary) .detail("Excluding", s.toString()); exclusions.insert(s); } } for (auto it : exclusions) { rsr.excludeAddresses.push_back(it); } if (!fCandidateWorker.isValid() || fCandidateWorker.isReady() || rsr.excludeAddresses != lastRequest.excludeAddresses || rsr.criticalRecruitment != lastRequest.criticalRecruitment) { lastRequest = rsr; fCandidateWorker = brokenPromiseToNever(recruitStorage-&gt;get().getReply(rsr, TaskPriority::DataDistribution)); } 前边设置好的 exclude 会被放到请求的 excludeAddresses 字段中。cluster controller 会根据请求条件过滤掉不合适的 worker（fdbserver/include/fdbserver/ClusterController.actor.h:ClusterControllerData::getStorageWorker）。收到 response 后，storageRecruiter 会发送 InitialStorageRequest 给目标进程，完成 recruit 流程。 可以发现，这个过程中并没有判断 storage process 的 failure status，而是直接发送 RecruitStorageRequest。那么这就意味着不能手动临时 exclude 任何一个 storage，否则都会触发数据迁移。 结论 通过分析，exclude 命令的确可以主动触发 recruit 流程，同时如果 process 上有 storage role，它还出触发 recruit storage 流程。 如果我们现在需要取得平滑升级的能力，那么需要以下几个步骤： 列出所有的 process 的 role，如果目标机器上某个 process 有 transaction system 的 role （非 coordinator，非 storage），那么执行 exclude $IP:$PORT 等到 recovery 完成后，执行 maintenance on $zone-id，表示禁用 storage process 的 failure detector 修改配置、重启 执行 maintenance off 执行 include $IP:$PORT，允许 transaction system 的 role 调度回该机器]]></summary></entry><entry><title type="html">grpc 的一些踩坑经验</title><link href="/2023/07/09/grpc-and-vip.html" rel="alternate" type="text/html" title="grpc 的一些踩坑经验" /><published>2023-07-09T00:00:00+08:00</published><updated>2023-07-09T00:00:00+08:00</updated><id>/2023/07/09/grpc-and-vip</id><content type="html" xml:base="/2023/07/09/grpc-and-vip.html"><![CDATA[<p>最近的工作需要对某个系统的 RPC 部分做优化。这个系统有多个组件，分别使用不同语言编写，此次我需要优化的组件分别由 java 和 c++ 编写，java 使用 grpc 访问使用 brpc 的 c++ 服务。</p>

<p>该系统在编写之初为了省事，将 c++ 服务放在四层负载均衡 VIP 之后，以利用其提供的负载均衡、探活熔断的能力。这种图省事的操作为系统留下了几个隐患：</p>
<ol>
  <li>如果 java 组件部署数量不够，那么无法保证通过 VIP 建立的连接数能够均衡分布到每个 RS</li>
  <li>如果不重启 java 组件，那么新加入的 RS 无法获得新连接。</li>
</ol>

<h2 id="一些尝试">一些尝试</h2>

<p>刚开始接受这个任务时，我的思路主要集中在能否通过简单改造 rpc 来解决前面两个问题。</p>

<p>针对第一个问题，我的初步思路是能否为每个 VIP 提供一些 tag，这样 grpc 在建立 channel 时，可以为某个 IP 建立多个连接，并使用 round-robin 的方式提供负载均衡。</p>

<p>我首先尝试编写一个 <code class="language-plaintext highlighter-rouge">Resolver</code>，它在 <code class="language-plaintext highlighter-rouge">DnsResolver</code> 的基础上，为每个 <code class="language-plaintext highlighter-rouge">EquivalentAddressGroup</code> 增加一个描述 tag 的 <code class="language-plaintext highlighter-rouge">Attribute</code>。不过很快我就发现，grpc 默认提供的 <code class="language-plaintext highlighter-rouge">RoundRobinLoadBalancer</code> 会清除所有通过 <code class="language-plaintext highlighter-rouge">Resolver</code> 返回的 <code class="language-plaintext highlighter-rouge">Attribute</code>，因此这种办法是不可行的。</p>

<p>那么进一步就是增加自定义的 <code class="language-plaintext highlighter-rouge">RoundRobinLoadBalaner</code>，去掉清除 tag 的逻辑。不过我并未按照这个方案实施，主要是它太复杂，且只解决了一个问题，难以说服项目负责人接受。</p>

<h2 id="其他视角的解决办法">其他视角的解决办法</h2>

<p>改造 rpc 的方案不行后，我将目光放在了修改使用 rpc 的方式上，很快我就发现从这里入手会简单许多。</p>

<p>在目前的代码里，java 服务会建立一个 <code class="language-plaintext highlighter-rouge">ManagedChannel</code>，并通过该 channel 访问 C++ 服务。其中 <code class="language-plaintext highlighter-rouge">ManagedChannel</code> 是通过 <code class="language-plaintext highlighter-rouge">NettyChannelBuilder</code> 创建的，其底层会为每个 <code class="language-plaintext highlighter-rouge">Resolver</code> 返回的 <code class="language-plaintext highlighter-rouge">EquivalentAddressGroup</code> 创建一个 <code class="language-plaintext highlighter-rouge">NettyTransport</code>（也就是 socket）。而阿里云、腾讯云提供的 VIP 只有一个 IP 地址，因此每个 java 服务最终只会创建一条到 C++ 服务的 socket。显然，只需要创建多个 <code class="language-plaintext highlighter-rouge">ManagedChannel</code>，就能建立多条 socket；再通过模拟 round-robin 算法，每次发起 rpc 前选择一个 channel，就能在很大程度上保证每个 RS 接收到的 rpc 请求是均衡的。</p>

<p>当然这只解决了第一个问题。VIP 机制下没有渠道可以获取到 RS 是否发生变更，因此只能从连接本身入手。一种方式是使用短连接，但它在每次访问时都需要创建一个 <code class="language-plaintext highlighter-rouge">ManagedChannel</code>，且并发数受限于可用端口数量，因此不是最优选择；另一种方式是为每个连接设置一段时间，超过时间后回收并重建连接，这样就保证在一段时间后就能与新加入的 RS 建立连接。</p>

<p>我选择使用第二种方式，为每个连接设置一段存活时间，超过时间后回收连接。grpc 协议提供了类似的支持：<a href="https://github.com/grpc/proposal/blob/master/A9-server-side-conn-mgt.md">A9-server-side-conn-mgt</a>，它允许在 server 端配置每个连接的 <code class="language-plaintext highlighter-rouge">MAX_CONNECTION_AGE</code>，超过时间后 server 端会给 client 发送 <code class="language-plaintext highlighter-rouge">GOAWAY</code> 通知 client 关闭该连接。当然，这个协议只有 grpc server 才支持，而我们的 C++ 服务使用的 brpc 并没有提供类似的机制，所以我们需要自己提供类似的功能。该功能实现也比较简单，每次建立连接时，会在某个时间范围内随机选择一个值作为 deadline；每次发送 rpc 请求时，先判断 deadline 是否已经到达，如果超过了 deadline，那么会调用 <code class="language-plaintext highlighter-rouge">ManagedChannel.terminate()</code> 并重建连接。</p>

<h2 id="connection-refused-问题">Connection refused 问题</h2>

<p>在实施上述方案的过程中，我们还碰到了另一个 grpc 的问题：尽管后端 C++ 服务已经启动，java client 仍然会不时抛出 <code class="language-plaintext highlighter-rouge">Connection refused</code> 异常。</p>

<p>通过分析代码，我们发现 grpc netty 实现中，如果碰到了连接异常，会调用 <code class="language-plaintext highlighter-rouge">InternalSubChannel::scheduleBackoff</code>。它主要做了两件事情：</p>
<ol>
  <li>在一段时间后，调用 <code class="language-plaintext highlighter-rouge">InternalSubChannel::startNewTransport</code> 重新建立连接。</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">gotoState(ConnectivityStateInfo.forTransactionFailure(status))</code>，将错误信息保存到 subchannel picker 中。</li>
</ol>

<p>而 <code class="language-plaintext highlighter-rouge">ManagedChannelImpl::ChannelTransportProvider::get()</code> 中会读取 subchannel picker 中保存的状态，如果对应的状态满足 <code class="language-plaintext highlighter-rouge">isWaitForReady() == false</code>，那么直接返回 <code class="language-plaintext highlighter-rouge">FaillingClientTransport</code>，最终抛出 <code class="language-plaintext highlighter-rouge">Connection refused</code> 异常。</p>

<p>也就是说，在 backoff 期间，所有在该 channel 上发起的 rpc 请求都会抛出 <code class="language-plaintext highlighter-rouge">Connection refused</code> 异常。而不幸的是：<code class="language-plaintext highlighter-rouge">InternalChannel.backoffPolicy</code> 是在 <code class="language-plaintext highlighter-rouge">AbstractManagedChannelImplBuilder</code> 中通过 <code class="language-plaintext highlighter-rouge">new ExponentialBackoffPolicy.Provider()</code> 设置的，没有提供自定义选项；而 <code class="language-plaintext highlighter-rouge">ExponentialBackoffPolicy</code> 中时间相关参数为常数，没有提供可修改选项，最大时间间隔为两分钟。显然，grpc java 的作者希望通过 backoff 来减小对 server 重连的压力，而我们则希望尽可能减少服务不可用时间。</p>

<p>幸运的是 <code class="language-plaintext highlighter-rouge">ManagedChannel</code> 提供了一个方法可以获取当前 channel 的状态。我们通过使用该接口，在每次请求前获取当前 channel 状态，如果是 <code class="language-plaintext highlighter-rouge">TRANSIENT_FAILURE</code>， 则关闭 channel 并重建。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[最近的工作需要对某个系统的 RPC 部分做优化。这个系统有多个组件，分别使用不同语言编写，此次我需要优化的组件分别由 java 和 c++ 编写，java 使用 grpc 访问使用 brpc 的 c++ 服务。 该系统在编写之初为了省事，将 c++ 服务放在四层负载均衡 VIP 之后，以利用其提供的负载均衡、探活熔断的能力。这种图省事的操作为系统留下了几个隐患： 如果 java 组件部署数量不够，那么无法保证通过 VIP 建立的连接数能够均衡分布到每个 RS 如果不重启 java 组件，那么新加入的 RS 无法获得新连接。 一些尝试 刚开始接受这个任务时，我的思路主要集中在能否通过简单改造 rpc 来解决前面两个问题。 针对第一个问题，我的初步思路是能否为每个 VIP 提供一些 tag，这样 grpc 在建立 channel 时，可以为某个 IP 建立多个连接，并使用 round-robin 的方式提供负载均衡。 我首先尝试编写一个 Resolver，它在 DnsResolver 的基础上，为每个 EquivalentAddressGroup 增加一个描述 tag 的 Attribute。不过很快我就发现，grpc 默认提供的 RoundRobinLoadBalancer 会清除所有通过 Resolver 返回的 Attribute，因此这种办法是不可行的。 那么进一步就是增加自定义的 RoundRobinLoadBalaner，去掉清除 tag 的逻辑。不过我并未按照这个方案实施，主要是它太复杂，且只解决了一个问题，难以说服项目负责人接受。 其他视角的解决办法 改造 rpc 的方案不行后，我将目光放在了修改使用 rpc 的方式上，很快我就发现从这里入手会简单许多。 在目前的代码里，java 服务会建立一个 ManagedChannel，并通过该 channel 访问 C++ 服务。其中 ManagedChannel 是通过 NettyChannelBuilder 创建的，其底层会为每个 Resolver 返回的 EquivalentAddressGroup 创建一个 NettyTransport（也就是 socket）。而阿里云、腾讯云提供的 VIP 只有一个 IP 地址，因此每个 java 服务最终只会创建一条到 C++ 服务的 socket。显然，只需要创建多个 ManagedChannel，就能建立多条 socket；再通过模拟 round-robin 算法，每次发起 rpc 前选择一个 channel，就能在很大程度上保证每个 RS 接收到的 rpc 请求是均衡的。 当然这只解决了第一个问题。VIP 机制下没有渠道可以获取到 RS 是否发生变更，因此只能从连接本身入手。一种方式是使用短连接，但它在每次访问时都需要创建一个 ManagedChannel，且并发数受限于可用端口数量，因此不是最优选择；另一种方式是为每个连接设置一段时间，超过时间后回收并重建连接，这样就保证在一段时间后就能与新加入的 RS 建立连接。 我选择使用第二种方式，为每个连接设置一段存活时间，超过时间后回收连接。grpc 协议提供了类似的支持：A9-server-side-conn-mgt，它允许在 server 端配置每个连接的 MAX_CONNECTION_AGE，超过时间后 server 端会给 client 发送 GOAWAY 通知 client 关闭该连接。当然，这个协议只有 grpc server 才支持，而我们的 C++ 服务使用的 brpc 并没有提供类似的机制，所以我们需要自己提供类似的功能。该功能实现也比较简单，每次建立连接时，会在某个时间范围内随机选择一个值作为 deadline；每次发送 rpc 请求时，先判断 deadline 是否已经到达，如果超过了 deadline，那么会调用 ManagedChannel.terminate() 并重建连接。 Connection refused 问题 在实施上述方案的过程中，我们还碰到了另一个 grpc 的问题：尽管后端 C++ 服务已经启动，java client 仍然会不时抛出 Connection refused 异常。 通过分析代码，我们发现 grpc netty 实现中，如果碰到了连接异常，会调用 InternalSubChannel::scheduleBackoff。它主要做了两件事情： 在一段时间后，调用 InternalSubChannel::startNewTransport 重新建立连接。 调用 gotoState(ConnectivityStateInfo.forTransactionFailure(status))，将错误信息保存到 subchannel picker 中。 而 ManagedChannelImpl::ChannelTransportProvider::get() 中会读取 subchannel picker 中保存的状态，如果对应的状态满足 isWaitForReady() == false，那么直接返回 FaillingClientTransport，最终抛出 Connection refused 异常。 也就是说，在 backoff 期间，所有在该 channel 上发起的 rpc 请求都会抛出 Connection refused 异常。而不幸的是：InternalChannel.backoffPolicy 是在 AbstractManagedChannelImplBuilder 中通过 new ExponentialBackoffPolicy.Provider() 设置的，没有提供自定义选项；而 ExponentialBackoffPolicy 中时间相关参数为常数，没有提供可修改选项，最大时间间隔为两分钟。显然，grpc java 的作者希望通过 backoff 来减小对 server 重连的压力，而我们则希望尽可能减少服务不可用时间。 幸运的是 ManagedChannel 提供了一个方法可以获取当前 channel 的状态。我们通过使用该接口，在每次请求前获取当前 channel 状态，如果是 TRANSIENT_FAILURE， 则关闭 channel 并重建。]]></summary></entry><entry><title type="html">The space reclaiming of PhotonDB</title><link href="/2022/12/07/The-space-reclaiming-of-PhotonDB.html" rel="alternate" type="text/html" title="The space reclaiming of PhotonDB" /><published>2022-12-07T00:00:00+08:00</published><updated>2022-12-07T00:00:00+08:00</updated><id>/2022/12/07/The-space-reclaiming-of-PhotonDB</id><content type="html" xml:base="/2022/12/07/The-space-reclaiming-of-PhotonDB.html"><![CDATA[<p>最近的一段时间我们分析并改进了 PhotonDB 的空间回收机制。</p>

<h1 id="background">Background</h1>

<p>PhotonDB 的 page store 可以视作一个 log structured page allocator。</p>

<p>在实现上，它分为持久化和内存中的两部分，其中内存部分由串有序的 write buffer 组成。write buffer 是一段连续的内存空间，新的 delta page 从最后一个 write buffer 中分配。每个 delta page 均有唯一的逻辑地址，该地址按照分配次序递增；其他 page 可以通过这个逻辑地址访问到该 delta page。其中从根节点出发能访问到的 delta page 称为活跃的；当 page 更新后，相关的 delta page 将不再被访问，所以会被归还（dealloc）给 page store。</p>

<p>当 write buffer 的空间分配完后，其中仍活跃的 delta page 会持久化到存储设备上，保存到一个新的 page file 中。除了记录 delta page 外，Page file 还记录了一些元数据，包括 delta page 到 page id 的映射；先前生成的 page files 中已经归还（dealloc）的 delta page 的地址；每个 delta page 的在 write buffer 中的偏移。每个 page file 在内存中维护着一个数据结构：<code class="language-plaintext highlighter-rouge">FileMeta</code>，其中记录着 delta page 的逻辑地址到文件偏移的映射关系。</p>

<p>每个 write buffer 有一个唯一且递增的 ID，它是 delta page 的逻辑地址的组成部分：逻辑地址由 buffer id 和 delta page 在 buffer 中的偏移组成（<code class="language-plaintext highlighter-rouge">logical address = (buffer id &lt;&lt; 32) | offset</code>）。Write buffer 转储时生成的 page file 拥有相同的 ID，因此对于任意一个逻辑地址，可以直接定位到 write buffer 或者 page file，并找到 delta page （对 page file ，还需要通过查询 <code class="language-plaintext highlighter-rouge">FileMeta</code>，找到文件偏移）。</p>

<p>前面提到了 page files 中还记录着已归还的 delta pages 的逻辑地址，虽然这些地址对应的数据将不再会被访问，但它们占用的磁盘空间仍然被保留着。我们称这部分空间为空白页。为了保证有足够的空间容纳新写入的数据，这些具有空白页的 page files 需要被整理，释放出空白页占据的空间。找到合适的 page files 并进行过程称为空间回收。</p>

<h1 id="framework">Framework</h1>

<p>空间回收实现时需要回答三个问题，何时进行？最优化目标？处理方法？这三个问题勾勒出空间回收机制实现的基本轮廓：</p>
<ol>
  <li>空间回收触发时机</li>
  <li>候选 page file 的选择策略</li>
  <li>page file 的处理方法</li>
</ol>

<p>当某些指标达到触发条件时，使用选择策略选择出候选 page files，并对 page file 按照某种方法进行处理，最终释放出空闲空间。后文将按照顺序，依次介绍 PhotonDB 解决这三个问题的方案。</p>

<h2 id="trigger">Trigger</h2>

<p>首先讨论的是空间回收的触发机制。PhotonDB 关注两个指标：1、使用空间；2、空间放大。在使用空间超过高水位线或者空间放大超过上限时，PhotonDB 触发空间回收，直到相关指标落到阈值下。为使用空间设置水位线，用于保证在剩余空间的比例；为空间放大设置上线，用于将整体的回收代价均摊到程序的整个运行时间段上。当然，只有存在过期 delta page 时，才能释放出空闲空间；因此只有拥有可回收空间时，使用空间的指标才会生效。</p>

<h2 id="efficient-strategy">Efficient strategy</h2>

<p>空间回收需要占用 IO 资源，它需要重定位候选 page files 中的活跃 delta page。这个过程的开销与过期 delta page 的数量有关系。显然过期的 delta page 越多，重定位的 IO 开销就越小。</p>

<p>候选文件选择策略的目标就是找到最适合回收的 page files，使得总的 IO 开销最小。</p>

<h3 id="minimize-of-io-cost">Minimize of IO cost</h3>

<p>为了找到这样的一个策略，我们不妨假设某个 page file $i$ 在时刻 $t_n$ 被回收的代价为 $C_i$，回收成本的下降速率（decline rate）为 $\frac{dc_i(t_0)}{dt}$；如果某个时间点 $t_0$ 回收成本为 $C_0$，那么对任意未来的时间 $t$，回收该 page file 的成本为：</p>

<p>$C_i(t) \approx C_i(t_0) + \frac{dc_i(t_0)}{dt} (t - t_0)$</p>

<p>假设有 $k$ 个 page file，每次处理一个，那么总的成本为：</p>

<p>$Cost = \sum_{i=1}^{k} c_i(t_0) - \sum_{i=1}^{k}-\frac{dc_i(t_0)}{dt}(t_i-t_0)$</p>

<p>观察发现，上述公式后半部分的值越大，最终的成本越小。显然当 $-\frac{dc_i(t_0)}{dt}$ 按照顺序排列时，后半部分的值越大。因此，优先处理 decline rate 最小的 page files，最后处理 decline rate 最大的 page files，总的代价最小。</p>

<p>我们把上述公式给出的回收策略称为 Min Decline Rate 策略。它显然符合直觉：如果成本能在未来一段时间内大幅下降，那么等待一段时间再处理是值得的。</p>

<h3 id="decline-rate">Decline rate</h3>

<p>有了理论指导后，下一步是为每个 page file 计算 decline rate。假设一个 page file 中空白页占比为 $E$，那么回收一个文件的空间，需要回收 $1/E$ 个有空闲页的 page file。其中放大部分为 $1/E(1-E)$。那么，写一个 page file 的 IO 成本为：</p>

<p>$Cost = \frac{1}{E} reads + \frac{1}{E} (1-E) writes + 1 = \frac{2}{E}$</p>

<p>进一步，IO 成本的 decline rate 为：</p>

<p>$\frac{d(Cost)}{dt} = (\frac{-2}{E^2})(\frac{dF}{du}) \approx \frac{−2(1 − E)}{E^2}f\Delta E$</p>

<p>其中 $f$ 是每个 page 的更新频率，$\Delta E$ 是每次更新时 $E$ 的变化率。文件的更新频率为 $f$ 乘上活跃 page 数。</p>

<p>每个 page 的更新频率可以通过如下方式估计：</p>

<p>$f = \frac{2}{t_{now}-t_{up2}}$</p>

<p>其中 $t_{up2}$ 表示倒数第二次更新某个 page 时的逻辑时间。</p>

<p>Min Decline Rate 策略来自于论文：<a href="https://arxiv.org/abs/2005.00044">Efficiently Reclaiming Space in a Log Structured Store</a>，如果对推导过程感兴趣，可以参考原论文。PhotonDB 使用 Min Decline Rate 作为候选 page files 选择策略。每次进行空间回收时，使用上面的公式计算每个 page file 的 decline rate 并排序。除了成本的计算外，原论文还指出，回收过程中可以使用更新频率对 delta page 进行分类，进一步降低回收成本。</p>

<h2 id="reclaim-file">Reclaim file</h2>

<p>处理候选 page file 时，需要保证活跃的 delta page 在处理完成后仍然能够访问。由于不考虑原地更新，那么回收一个 page file 就要求实现将其中仍活跃的 delta page 复制到其他位置。</p>

<p>最直接的办法是将 delta page 复制到一块新开辟的空间里，同时更新对 delta page 的引用，将其指向复制后的位置。这个过程我们称为重定向，它有一个明显的缺陷：更换了 delta page 的逻辑地址。每个活跃的 delta page 均可从根节点访问到，对它的引用可能存在于 page table 中，也可能存在于同一 delta chain 上的前驱节点；对于后者，更换逻辑地址意味着需要遍历整个 delta chain，找到对应的前驱节点进行替换。对于 immutable 的数据结构而言，替换就意味着需要引入一种新的 delta page，它负责将原逻辑地址映射到新的逻辑地址上。</p>

<p>为了避免额外的复杂度，0.2 版本的 PhotonDB 使用了 page rewriting 的机制来避免上述问题。</p>

<h3 id="problem-with-page-rewriting">Problem with page rewriting</h3>

<p>PhotonDB 使用的 page rewriting 机制类似于 consolidation 操作，因此它们能够复用一些逻辑。consolidation 会将 delta chain 合并，并使用生成的 delta page 替换掉 delta chain。</p>

<p>page rewriting 与 consolidation 略有不同，主要分两个方面：</p>
<ol>
  <li>page rewriting 仍然有重定位的作用，即使 delta chain 长度为 1，页需要生成新的 delta page 并替换。</li>
  <li>page rewriting 可能会生成一条 delta chain，而不是一个 delta page。比如 split delta 在没有应用到父节点前，不能被合并到新 delta page 中。</li>
</ol>

<p>Page rewriting 机制的缺点也是明显的，合并 delta chain 的过程中有大量的 IO 扇入扇出。Page rewriting 的另一个问题是没有跟踪这些新 delta page 的更新频率。与论文中的做法不同，出于性能考虑 PhotonDB 只跟踪了 page file 的更新频率，没有跟踪 delta page 的更新频率。这些 rewriting 生成的 delta page 被当作全新的写入，与用户写入的 delta page 混合到一起，导致了更新频率的失真。</p>

<h3 id="solution">Solution</h3>

<p>如果我们引入一层全局的转换层，它负责将逻辑地址中的 page file ID 映射到物理地址（文件，偏移）上，那么也可以做到不修改 delta page 的逻辑地址的同时回收 page file。显然这个转换层已经存在了，它就是前面提到的 FileMeta。因此，我们只需要将活跃的 delta page 复制到新的文件中，并修改 FileMeta 中的映射，就完成了 page file 的回收。</p>

<p>不过随着归还的 delta page 越来越多，新文件会越来越小、越来越碎片化，需要付出更大的开销来维护这些小文件的元数据；同时 IO 的预取、批处理等效率也有较低。为此，我们引入了一种新的文件格式：mapping file。Mapping file 将多个 page files 中活跃的 delta page 打包到一个文件中，同时记录下逻辑地址与物理地址的映射关系。</p>

<p>除了减少碎片化、避免 page rewriting 引入的 IO 放大外，mapping file 提供了提到的按照更新频率对 delta page 分类的能力；将更新频率接近的 delta page 放到一起，可以达到冷热分离的效果。从实验数据上看，mapping file 的引入，让 0.3 版本的 PhotonDB 在 zipfan 和 uniform workload 下较前一个版本分别减少了 ~5 倍和 ~2.5 倍的写放大。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[最近的一段时间我们分析并改进了 PhotonDB 的空间回收机制。 Background PhotonDB 的 page store 可以视作一个 log structured page allocator。 在实现上，它分为持久化和内存中的两部分，其中内存部分由串有序的 write buffer 组成。write buffer 是一段连续的内存空间，新的 delta page 从最后一个 write buffer 中分配。每个 delta page 均有唯一的逻辑地址，该地址按照分配次序递增；其他 page 可以通过这个逻辑地址访问到该 delta page。其中从根节点出发能访问到的 delta page 称为活跃的；当 page 更新后，相关的 delta page 将不再被访问，所以会被归还（dealloc）给 page store。 当 write buffer 的空间分配完后，其中仍活跃的 delta page 会持久化到存储设备上，保存到一个新的 page file 中。除了记录 delta page 外，Page file 还记录了一些元数据，包括 delta page 到 page id 的映射；先前生成的 page files 中已经归还（dealloc）的 delta page 的地址；每个 delta page 的在 write buffer 中的偏移。每个 page file 在内存中维护着一个数据结构：FileMeta，其中记录着 delta page 的逻辑地址到文件偏移的映射关系。 每个 write buffer 有一个唯一且递增的 ID，它是 delta page 的逻辑地址的组成部分：逻辑地址由 buffer id 和 delta page 在 buffer 中的偏移组成（logical address = (buffer id &lt;&lt; 32) | offset）。Write buffer 转储时生成的 page file 拥有相同的 ID，因此对于任意一个逻辑地址，可以直接定位到 write buffer 或者 page file，并找到 delta page （对 page file ，还需要通过查询 FileMeta，找到文件偏移）。 前面提到了 page files 中还记录着已归还的 delta pages 的逻辑地址，虽然这些地址对应的数据将不再会被访问，但它们占用的磁盘空间仍然被保留着。我们称这部分空间为空白页。为了保证有足够的空间容纳新写入的数据，这些具有空白页的 page files 需要被整理，释放出空白页占据的空间。找到合适的 page files 并进行过程称为空间回收。 Framework 空间回收实现时需要回答三个问题，何时进行？最优化目标？处理方法？这三个问题勾勒出空间回收机制实现的基本轮廓： 空间回收触发时机 候选 page file 的选择策略 page file 的处理方法 当某些指标达到触发条件时，使用选择策略选择出候选 page files，并对 page file 按照某种方法进行处理，最终释放出空闲空间。后文将按照顺序，依次介绍 PhotonDB 解决这三个问题的方案。 Trigger 首先讨论的是空间回收的触发机制。PhotonDB 关注两个指标：1、使用空间；2、空间放大。在使用空间超过高水位线或者空间放大超过上限时，PhotonDB 触发空间回收，直到相关指标落到阈值下。为使用空间设置水位线，用于保证在剩余空间的比例；为空间放大设置上线，用于将整体的回收代价均摊到程序的整个运行时间段上。当然，只有存在过期 delta page 时，才能释放出空闲空间；因此只有拥有可回收空间时，使用空间的指标才会生效。 Efficient strategy 空间回收需要占用 IO 资源，它需要重定位候选 page files 中的活跃 delta page。这个过程的开销与过期 delta page 的数量有关系。显然过期的 delta page 越多，重定位的 IO 开销就越小。 候选文件选择策略的目标就是找到最适合回收的 page files，使得总的 IO 开销最小。 Minimize of IO cost 为了找到这样的一个策略，我们不妨假设某个 page file $i$ 在时刻 $t_n$ 被回收的代价为 $C_i$，回收成本的下降速率（decline rate）为 $\frac{dc_i(t_0)}{dt}$；如果某个时间点 $t_0$ 回收成本为 $C_0$，那么对任意未来的时间 $t$，回收该 page file 的成本为： $C_i(t) \approx C_i(t_0) + \frac{dc_i(t_0)}{dt} (t - t_0)$ 假设有 $k$ 个 page file，每次处理一个，那么总的成本为： $Cost = \sum_{i=1}^{k} c_i(t_0) - \sum_{i=1}^{k}-\frac{dc_i(t_0)}{dt}(t_i-t_0)$ 观察发现，上述公式后半部分的值越大，最终的成本越小。显然当 $-\frac{dc_i(t_0)}{dt}$ 按照顺序排列时，后半部分的值越大。因此，优先处理 decline rate 最小的 page files，最后处理 decline rate 最大的 page files，总的代价最小。 我们把上述公式给出的回收策略称为 Min Decline Rate 策略。它显然符合直觉：如果成本能在未来一段时间内大幅下降，那么等待一段时间再处理是值得的。 Decline rate 有了理论指导后，下一步是为每个 page file 计算 decline rate。假设一个 page file 中空白页占比为 $E$，那么回收一个文件的空间，需要回收 $1/E$ 个有空闲页的 page file。其中放大部分为 $1/E(1-E)$。那么，写一个 page file 的 IO 成本为： $Cost = \frac{1}{E} reads + \frac{1}{E} (1-E) writes + 1 = \frac{2}{E}$ 进一步，IO 成本的 decline rate 为： $\frac{d(Cost)}{dt} = (\frac{-2}{E^2})(\frac{dF}{du}) \approx \frac{−2(1 − E)}{E^2}f\Delta E$ 其中 $f$ 是每个 page 的更新频率，$\Delta E$ 是每次更新时 $E$ 的变化率。文件的更新频率为 $f$ 乘上活跃 page 数。 每个 page 的更新频率可以通过如下方式估计： $f = \frac{2}{t_{now}-t_{up2}}$ 其中 $t_{up2}$ 表示倒数第二次更新某个 page 时的逻辑时间。 Min Decline Rate 策略来自于论文：Efficiently Reclaiming Space in a Log Structured Store，如果对推导过程感兴趣，可以参考原论文。PhotonDB 使用 Min Decline Rate 作为候选 page files 选择策略。每次进行空间回收时，使用上面的公式计算每个 page file 的 decline rate 并排序。除了成本的计算外，原论文还指出，回收过程中可以使用更新频率对 delta page 进行分类，进一步降低回收成本。 Reclaim file 处理候选 page file 时，需要保证活跃的 delta page 在处理完成后仍然能够访问。由于不考虑原地更新，那么回收一个 page file 就要求实现将其中仍活跃的 delta page 复制到其他位置。 最直接的办法是将 delta page 复制到一块新开辟的空间里，同时更新对 delta page 的引用，将其指向复制后的位置。这个过程我们称为重定向，它有一个明显的缺陷：更换了 delta page 的逻辑地址。每个活跃的 delta page 均可从根节点访问到，对它的引用可能存在于 page table 中，也可能存在于同一 delta chain 上的前驱节点；对于后者，更换逻辑地址意味着需要遍历整个 delta chain，找到对应的前驱节点进行替换。对于 immutable 的数据结构而言，替换就意味着需要引入一种新的 delta page，它负责将原逻辑地址映射到新的逻辑地址上。 为了避免额外的复杂度，0.2 版本的 PhotonDB 使用了 page rewriting 的机制来避免上述问题。 Problem with page rewriting PhotonDB 使用的 page rewriting 机制类似于 consolidation 操作，因此它们能够复用一些逻辑。consolidation 会将 delta chain 合并，并使用生成的 delta page 替换掉 delta chain。 page rewriting 与 consolidation 略有不同，主要分两个方面： page rewriting 仍然有重定位的作用，即使 delta chain 长度为 1，页需要生成新的 delta page 并替换。 page rewriting 可能会生成一条 delta chain，而不是一个 delta page。比如 split delta 在没有应用到父节点前，不能被合并到新 delta page 中。 Page rewriting 机制的缺点也是明显的，合并 delta chain 的过程中有大量的 IO 扇入扇出。Page rewriting 的另一个问题是没有跟踪这些新 delta page 的更新频率。与论文中的做法不同，出于性能考虑 PhotonDB 只跟踪了 page file 的更新频率，没有跟踪 delta page 的更新频率。这些 rewriting 生成的 delta page 被当作全新的写入，与用户写入的 delta page 混合到一起，导致了更新频率的失真。 Solution 如果我们引入一层全局的转换层，它负责将逻辑地址中的 page file ID 映射到物理地址（文件，偏移）上，那么也可以做到不修改 delta page 的逻辑地址的同时回收 page file。显然这个转换层已经存在了，它就是前面提到的 FileMeta。因此，我们只需要将活跃的 delta page 复制到新的文件中，并修改 FileMeta 中的映射，就完成了 page file 的回收。 不过随着归还的 delta page 越来越多，新文件会越来越小、越来越碎片化，需要付出更大的开销来维护这些小文件的元数据；同时 IO 的预取、批处理等效率也有较低。为此，我们引入了一种新的文件格式：mapping file。Mapping file 将多个 page files 中活跃的 delta page 打包到一个文件中，同时记录下逻辑地址与物理地址的映射关系。 除了减少碎片化、避免 page rewriting 引入的 IO 放大外，mapping file 提供了提到的按照更新频率对 delta page 分类的能力；将更新频率接近的 delta page 放到一起，可以达到冷热分离的效果。从实验数据上看，mapping file 的引入，让 0.3 版本的 PhotonDB 在 zipfan 和 uniform workload 下较前一个版本分别减少了 ~5 倍和 ~2.5 倍的写放大。]]></summary></entry><entry><title type="html">Rust - The `async fn` generated `Future` is too large?</title><link href="/2022/09/05/rust-async-fn-genrated-futures-is-too-large.html" rel="alternate" type="text/html" title="Rust - The `async fn` generated `Future` is too large?" /><published>2022-09-05T00:00:00+08:00</published><updated>2022-09-05T00:00:00+08:00</updated><id>/2022/09/05/rust-async-fn-genrated-futures-is-too-large</id><content type="html" xml:base="/2022/09/05/rust-async-fn-genrated-futures-is-too-large.html"><![CDATA[<h1 id="背景">背景</h1>

<p>最近开始对 engula 进行性能测试，发现 async fn 的性能损耗非常大，这不符合 zero overhead abstraction，因此开始对 async fn 的性能做一些研究。</p>

<p>通过增加参数 <code class="language-plaintext highlighter-rouge">-Z print-type-size</code>，可以输出每种类型的大小。发现很多 generator 内存大小非常大，其中最不符合直觉的是下面这几个：</p>

<pre><code class="language-log">print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:39:69: 44:6]&gt;`: 1248 bytes, alignment: 8 bytes
print-type-size     field `.0`: 1248 bytes
print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:79:52: 83:6]&gt;`: 1408 bytes, alignment: 8 bytes
print-type-size     field `.0`: 1408 bytes
print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:88:51: 92:6]&gt;`: 1408 bytes, alignment: 8 bytes
print-type-size     field `.0`: 1408 bytes
</code></pre>

<p>node_client.rs 是 tonic grpc client 的简单封装:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">tonic</span><span class="p">::</span><span class="nn">transport</span><span class="p">::</span><span class="n">Channel</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">Clone)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Client</span> <span class="p">{</span>
    <span class="n">client</span><span class="p">:</span> <span class="nn">node_client</span><span class="p">::</span><span class="n">NodeClient</span><span class="o">&lt;</span><span class="n">Channel</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">root_heartbeat</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">req</span><span class="p">:</span> <span class="n">HeartbeatRequest</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">HeartbeatResponse</span><span class="p">,</span> <span class="nn">tonic</span><span class="p">::</span><span class="n">Status</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">client</span> <span class="o">=</span> <span class="k">self</span><span class="py">.client</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">client</span><span class="nf">.root_heartbeat</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">res</span><span class="nf">.into_inner</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">node_client::NodeClient</code> 是 tonic_build 生成的代码：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">NodeClient</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nn">tonic</span><span class="p">::</span><span class="nn">client</span><span class="p">::</span><span class="n">GrpcService</span><span class="o">&lt;</span><span class="nn">tonic</span><span class="p">::</span><span class="nn">body</span><span class="p">::</span><span class="n">BoxBody</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nn">T</span><span class="p">::</span><span class="n">Error</span><span class="p">:</span> <span class="nb">Into</span><span class="o">&lt;</span><span class="n">StdError</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nn">T</span><span class="p">::</span><span class="n">ResponseBody</span><span class="p">:</span> <span class="n">Body</span><span class="o">&lt;</span><span class="n">Data</span> <span class="o">=</span> <span class="n">Bytes</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Send</span> <span class="o">+</span> <span class="k">'static</span><span class="p">,</span>
    <span class="o">&lt;</span><span class="nn">T</span><span class="p">::</span><span class="n">ResponseBody</span> <span class="k">as</span> <span class="n">Body</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Error</span><span class="p">:</span> <span class="nb">Into</span><span class="o">&lt;</span><span class="n">StdError</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Send</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">inner</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">inner</span> <span class="o">=</span> <span class="nn">tonic</span><span class="p">::</span><span class="nn">client</span><span class="p">::</span><span class="nn">Grpc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">inner</span><span class="p">);</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">inner</span> <span class="p">}</span>
    <span class="p">}</span>    
<span class="p">}</span>

<span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">root_heartbeat</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
    <span class="n">request</span><span class="p">:</span> <span class="k">impl</span> <span class="nn">tonic</span><span class="p">::</span><span class="n">IntoRequest</span><span class="o">&lt;</span><span class="k">super</span><span class="p">::</span><span class="n">HeartbeatRequest</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nn">tonic</span><span class="p">::</span><span class="n">Response</span><span class="o">&lt;</span><span class="k">super</span><span class="p">::</span><span class="n">HeartbeatResponse</span><span class="o">&gt;</span><span class="p">,</span> <span class="nn">tonic</span><span class="p">::</span><span class="n">Status</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.inner</span>
        <span class="nf">.ready</span><span class="p">()</span>
        <span class="k">.await</span>
        <span class="nf">.map_err</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="p">{</span>
            <span class="nn">tonic</span><span class="p">::</span><span class="nn">Status</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span>
                <span class="nn">tonic</span><span class="p">::</span><span class="nn">Code</span><span class="p">::</span><span class="n">Unknown</span><span class="p">,</span>
                <span class="nd">format!</span><span class="p">(</span><span class="s">"Service was not ready: {}"</span><span class="p">,</span> <span class="n">e</span><span class="nf">.into</span><span class="p">()),</span>
            <span class="p">)</span>
        <span class="p">})</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">codec</span> <span class="o">=</span> <span class="nn">tonic</span><span class="p">::</span><span class="nn">codec</span><span class="p">::</span><span class="nn">ProstCodec</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">path</span> <span class="o">=</span> <span class="nn">http</span><span class="p">::</span><span class="nn">uri</span><span class="p">::</span><span class="nn">PathAndQuery</span><span class="p">::</span><span class="nf">from_static</span><span class="p">(</span>
        <span class="s">"/engula.server.v1.Node/RootHeartbeat"</span><span class="p">,</span>
    <span class="p">);</span>
    <span class="k">self</span><span class="py">.inner</span><span class="nf">.unary</span><span class="p">(</span><span class="n">request</span><span class="nf">.into_request</span><span class="p">(),</span> <span class="n">path</span><span class="p">,</span> <span class="n">codec</span><span class="p">)</span><span class="k">.await</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也就是说，每次调用 <code class="language-plaintext highlighter-rouge">Grpc::unary</code> 需要在栈上开辟 1K+ 的空间。如果最后使用了 <code class="language-plaintext highlighter-rouge">tokio::spawn</code>，那么还需要将它复制到堆上。无论是内存分配还是复制上的开销，对于一个高性能存储服务都是不可接受的。并且随着 <code class="language-plaintext highlighter-rouge">async fn</code> 的调用层数增加，<code class="language-plaintext highlighter-rouge">Future</code> 大小还会呈现指数增长，这一点我后面会分析。</p>

<h1 id="grpcunary-的-memory-layout-是怎样的">Grpc::unary 的 memory layout 是怎样的？</h1>

<p>那么，为何 <code class="language-plaintext highlighter-rouge">Grpc::unary</code> 返回的 <code class="language-plaintext highlighter-rouge">Future</code> 需要消耗 1K+ 的内存空间呢？</p>

<p>在 tonic/src/client/grpc.rs 中，<code class="language-plaintext highlighter-rouge">unary</code> 最终被委托给 <code class="language-plaintext highlighter-rouge">Grpc::streaming</code>，后者调用 <code class="language-plaintext highlighter-rouge">Channel::call</code> 并返回 <code class="language-plaintext highlighter-rouge">ResponseFuture</code>。</p>

<pre><code class="language-Rust">/// Send a single unary gRPC request.
pub async fn unary&lt;M1, M2, C&gt;(
    &amp;mut self,
    request: Request&lt;M1&gt;,
    path: PathAndQuery,
    codec: C,
) -&gt; Result&lt;Response&lt;M2&gt;, Status&gt;
where
    T: GrpcService&lt;BoxBody&gt;,
    T::ResponseBody: Body + Send + 'static,
    &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;,
    C: Codec&lt;Encode = M1, Decode = M2&gt;,
    M1: Send + Sync + 'static,
    M2: Send + Sync + 'static,
{
    let request = request.map(|m| stream::once(future::ready(m)));
    self.client_streaming(request, path, codec).await
}

/// Send a client side streaming gRPC request.
pub async fn client_streaming&lt;S, M1, M2, C&gt;(
    &amp;mut self,
    request: Request&lt;S&gt;,
    path: PathAndQuery,
    codec: C,
) -&gt; Result&lt;Response&lt;M2&gt;, Status&gt;
where
    T: GrpcService&lt;BoxBody&gt;,
    T::ResponseBody: Body + Send + 'static,
    &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;,
    S: Stream&lt;Item = M1&gt; + Send + 'static,
    C: Codec&lt;Encode = M1, Decode = M2&gt;,
    M1: Send + Sync + 'static,
    M2: Send + Sync + 'static,
{
    let (mut parts, body, extensions) =
        self.streaming(request, path, codec).await?.into_parts();

    futures_util::pin_mut!(body);

    let message = body
        .try_next()
        .await
        .map_err(|mut status| {
            status.metadata_mut().merge(parts.clone());
            status
        })?
        .ok_or_else(|| Status::new(Code::Internal, "Missing response message."))?;

    if let Some(trailers) = body.trailers().await? {
        parts.merge(trailers);
    }

    Ok(Response::from_parts(parts, message, extensions))
}

/// Send a bi-directional streaming gRPC request.
pub async fn streaming&lt;S, M1, M2, C&gt;(
    &amp;mut self,
    request: Request&lt;S&gt;,
    path: PathAndQuery,
    mut codec: C,
) -&gt; Result&lt;Response&lt;Streaming&lt;M2&gt;&gt;, Status&gt;
where
    T: GrpcService&lt;BoxBody&gt;,
    T::ResponseBody: Body + Send + 'static,
    &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;,
    S: Stream&lt;Item = M1&gt; + Send + 'static,
    C: Codec&lt;Encode = M1, Decode = M2&gt;,
    M1: Send + Sync + 'static,
    M2: Send + Sync + 'static,
{
    let mut parts = Parts::default();
    parts.path_and_query = Some(path);

    let uri = Uri::from_parts(parts).expect("path_and_query only is valid Uri");

    let request = request
        .map(|s| {
            encode_client(
                codec.encoder(),
                s,
                #[cfg(feature = "compression")]
                self.send_compression_encodings,
            )
        })
        .map(BoxBody::new);

    let mut request = request.into_http(
        uri,
        http::Method::POST,
        http::Version::HTTP_2,
        SanitizeHeaders::Yes,
    );

    // Add the gRPC related HTTP headers
    request
        .headers_mut()
        .insert(TE, HeaderValue::from_static("trailers"));

    // Set the content type
    request
        .headers_mut()
        .insert(CONTENT_TYPE, HeaderValue::from_static("application/grpc"));

    #[cfg(feature = "compression")]
    {
        if let Some(encoding) = self.send_compression_encodings {
            request.headers_mut().insert(
                crate::codec::compression::ENCODING_HEADER,
                encoding.into_header_value(),
            );
        }

        if let Some(header_value) = self
            .accept_compression_encodings
            .into_accept_encoding_header_value()
        {
            request.headers_mut().insert(
                crate::codec::compression::ACCEPT_ENCODING_HEADER,
                header_value,
            );
        }
    }

    let response = self
        .inner
        .call(request)
        .await
        .map_err(|err| Status::from_error(err.into()))?;

    #[cfg(feature = "compression")]
    let encoding = CompressionEncoding::from_encoding_header(
        response.headers(),
        self.accept_compression_encodings,
    )?;

    let status_code = response.status();
    let trailers_only_status = Status::from_header_map(response.headers());

    // We do not need to check for trailers if the `grpc-status` header is present
    // with a valid code.
    let expect_additional_trailers = if let Some(status) = trailers_only_status {
        if status.code() != Code::Ok {
            return Err(status);
        }

        false
    } else {
        true
    };

    let response = response.map(|body| {
        if expect_additional_trailers {
            Streaming::new_response(
                codec.decoder(),
                body,
                status_code,
                #[cfg(feature = "compression")]
                encoding,
            )
        } else {
            Streaming::new_empty(codec.decoder(), body)
        }
    });

    Ok(Response::from_http(response))
}
</code></pre>

<p>以前面的 <code class="language-plaintext highlighter-rouge">root_heartbeat</code> 为例，最终实例化的 <code class="language-plaintext highlighter-rouge">streaming</code> 的签名为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tonic::client::Grpc&lt;tonic::transport::Channel&gt;::streaming&lt;
    futures::stream::Once&lt;
        futures::future::Ready&lt;
            engula_api::server::v1::HeartbeatRequest&gt;&gt;,
    engula_api::server::v1::HeartbeatRequest,
    engula_api::server::v1::HeartbeatResponse,
    tonic::codec::ProstCodec&lt;
        engula_api::server::v1::HeartbeatRequest,
        engula_api::server::v1::HeartbeatResponse&gt;&gt;
</code></pre></div></div>

<p>而 <code class="language-plaintext highlighter-rouge">async fn streaming()</code> 脱糖后，经过 transform 生成的状态机的内存布局为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>generator layout ([static generator@tonic::client::Grpc&lt;tonic::transport::Channel&gt;::streaming&lt;futures::stream::Once&lt;futures::future::Ready&lt;engula_api::server::v1::HeartbeatRequest&gt;&gt;, engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse, tonic::codec::ProstCodec&lt;engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt;&gt;::{closure#0}]): Layout {
    size: Size(560 bytes),
    align: AbiAndPrefAlign {
        abi: Align(8 bytes),
        pref: Align(8 bytes),
    },
    abi: Aggregate {
        sized: true,
    },
    fields: Arbitrary {
        offsets: [
        Size(0 bytes),
        Size(8 bytes),
        Size(152 bytes),
        Size(0 bytes),
        Size(552 bytes),
        ],
    }
}
</code></pre></div></div>

<p>仔细分析 <code class="language-plaintext highlighter-rouge">streaming</code> 的代码可以发现，跨过 <code class="language-plaintext highlighter-rouge">suspend point</code> 的变量只有本地变量 <code class="language-plaintext highlighter-rouge">request</code>，预留空间 <code class="language-plaintext highlighter-rouge">response</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">request</code>: <code class="language-plaintext highlighter-rouge">http::request::Request&lt;http_body::combinators::box_body::UnsyncBoxBody&lt;prost::bytes::Bytes, tonic::Status&gt;&gt;</code> size = 240 bytes</li>
  <li><code class="language-plaintext highlighter-rouge">response</code>: <code class="language-plaintext highlighter-rouge">tonic::transport::channel::ResponseFuture</code> size = 32 bytes</li>
</ul>

<p>那么 <code class="language-plaintext highlighter-rouge">request</code> + <code class="language-plaintext highlighter-rouge">response</code> + <code class="language-plaintext highlighter-rouge">tag</code> （手写状态机的理论值）应该是远小于 560 bytes。到了 <code class="language-plaintext highlighter-rouge">client_streaming</code> 这里，内存空间就增长到了 1056 bytes。</p>

<h1 id="async-fn-的-layout-是如何计算的">async fn 的 layout 是如何计算的？</h1>

<p>这里进一步分析编译器内部是如何处理 <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code> 和产生状态机的，看看不符合直觉的结果是如何产生的。</p>

<h2 id="实际上-async-fn-是-generator-的语法糖">实际上 async fn 是 generator 的语法糖</h2>

<p><code class="language-plaintext highlighter-rouge">async</code> 和 <code class="language-plaintext highlighter-rouge">await</code> 都是语法糖，rust compiler 在 ast lowering 过程中进行了 desugar，并生成 hir。其中 <code class="language-plaintext highlighter-rouge">async fn</code> 会被替换为 generator (compiler/rustc_ast_lowering/src/item.rs)：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">lower_maybe_async_body</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
    <span class="n">span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span>
    <span class="n">decl</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">FnDecl</span><span class="p">,</span>
    <span class="n">asyncness</span><span class="p">:</span> <span class="n">Async</span><span class="p">,</span>
    <span class="n">body</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">Block</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">hir</span><span class="p">::</span><span class="n">BodyId</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">closure_id</span> <span class="o">=</span> <span class="k">match</span> <span class="n">asyncness</span> <span class="p">{</span>
        <span class="nn">Async</span><span class="p">::</span><span class="n">Yes</span> <span class="p">{</span> <span class="n">closure_id</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="n">closure_id</span><span class="p">,</span>
        <span class="nn">Async</span><span class="p">::</span><span class="n">No</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="k">self</span><span class="nf">.lower_fn_body_block</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">decl</span><span class="p">,</span> <span class="n">body</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="k">self</span><span class="nf">.lower_body</span><span class="p">(|</span><span class="n">this</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">parameters</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">hir</span><span class="p">::</span><span class="n">Param</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">statements</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">hir</span><span class="p">::</span><span class="n">Stmt</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="c1">// Async function parameters are lowered into the closure body so that they are</span>
        <span class="c1">// captured and so that the drop order matches the equivalent non-async functions.</span>
        <span class="c1">//</span>
        <span class="c1">// from:</span>
        <span class="c1">//</span>
        <span class="c1">//     async fn foo(&lt;pattern&gt;: &lt;ty&gt;, &lt;pattern&gt;: &lt;ty&gt;, &lt;pattern&gt;: &lt;ty&gt;) {</span>
        <span class="c1">//         &lt;body&gt;</span>
        <span class="c1">//     }</span>
        <span class="c1">//</span>
        <span class="c1">// into:</span>
        <span class="c1">//</span>
        <span class="c1">//     fn foo(__arg0: &lt;ty&gt;, __arg1: &lt;ty&gt;, __arg2: &lt;ty&gt;) {</span>
        <span class="c1">//       async move {</span>
        <span class="c1">//         let __arg2 = __arg2;</span>
        <span class="c1">//         let &lt;pattern&gt; = __arg2;</span>
        <span class="c1">//         let __arg1 = __arg1;</span>
        <span class="c1">//         let &lt;pattern&gt; = __arg1;</span>
        <span class="c1">//         let __arg0 = __arg0;</span>
        <span class="c1">//         let &lt;pattern&gt; = __arg0;</span>
        <span class="c1">//         drop-temps { &lt;body&gt; } // see comments later in fn for details</span>
        <span class="c1">//       }</span>
        <span class="c1">//     }</span>
        <span class="c1">//</span>
        <span class="c1">// If `&lt;pattern&gt;` is a simple ident, then it is lowered to a single</span>
        <span class="c1">// `let &lt;pattern&gt; = &lt;pattern&gt;;` statement as an optimization.</span>
        <span class="c1">//</span>
        <span class="c1">// Note that the body is embedded in `drop-temps`; an</span>
        <span class="c1">// equivalent desugaring would be `return { &lt;body&gt;</span>
        <span class="c1">// };`. The key point is that we wish to drop all the</span>
        <span class="c1">// let-bound variables and temporaries created in the body</span>
        <span class="c1">// (and its tail expression!) before we drop the</span>
        <span class="c1">// parameters (c.f. rust-lang/rust#64512).</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">parameter</span><span class="p">)</span> <span class="k">in</span> <span class="n">decl</span><span class="py">.inputs</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">parameter</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.lower_param</span><span class="p">(</span><span class="n">parameter</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">span</span> <span class="o">=</span> <span class="n">parameter</span><span class="py">.pat.span</span><span class="p">;</span>

            <span class="c1">// Check if this is a binding pattern, if so, we can optimize and avoid adding a</span>
            <span class="c1">// `let &lt;pat&gt; = __argN;` statement. In this case, we do not rename the parameter.</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="n">is_simple_parameter</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">parameter</span><span class="py">.pat.kind</span> <span class="p">{</span>
                <span class="nn">hir</span><span class="p">::</span><span class="nn">PatKind</span><span class="p">::</span><span class="nf">Binding</span><span class="p">(</span>
                    <span class="nn">hir</span><span class="p">::</span><span class="nn">BindingAnnotation</span><span class="p">::</span><span class="n">Unannotated</span> <span class="p">|</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">BindingAnnotation</span><span class="p">::</span><span class="n">Mutable</span><span class="p">,</span>
                    <span class="n">_</span><span class="p">,</span>
                    <span class="n">ident</span><span class="p">,</span>
                    <span class="n">_</span><span class="p">,</span>
                <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="k">true</span><span class="p">),</span>
                <span class="c1">// For `ref mut` or wildcard arguments, we can't reuse the binding, but</span>
                <span class="c1">// we can keep the same name for the parameter.</span>
                <span class="c1">// This lets rustdoc render it correctly in documentation.</span>
                <span class="nn">hir</span><span class="p">::</span><span class="nn">PatKind</span><span class="p">::</span><span class="nf">Binding</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="k">false</span><span class="p">),</span>
                <span class="nn">hir</span><span class="p">::</span><span class="nn">PatKind</span><span class="p">::</span><span class="n">Wild</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="p">(</span><span class="nn">Ident</span><span class="p">::</span><span class="nf">with_dummy_span</span><span class="p">(</span><span class="nn">rustc_span</span><span class="p">::</span><span class="nn">symbol</span><span class="p">::</span><span class="nn">kw</span><span class="p">::</span><span class="n">Underscore</span><span class="p">),</span> <span class="k">false</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// Replace the ident for bindings that aren't simple.</span>
                    <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"__arg{}"</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
                    <span class="k">let</span> <span class="n">ident</span> <span class="o">=</span> <span class="nn">Ident</span><span class="p">::</span><span class="nf">from_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>

                    <span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">};</span>

            <span class="k">let</span> <span class="n">desugared_span</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.mark_span_with_reason</span><span class="p">(</span><span class="nn">DesugaringKind</span><span class="p">::</span><span class="n">Async</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>

            <span class="c1">// Construct a parameter representing `__argN: &lt;ty&gt;` to replace the parameter of the</span>
            <span class="c1">// async function.</span>
            <span class="c1">//</span>
            <span class="c1">// If this is the simple case, this parameter will end up being the same as the</span>
            <span class="c1">// original parameter, but with a different pattern id.</span>
            <span class="k">let</span> <span class="n">stmt_attrs</span> <span class="o">=</span> <span class="n">this</span><span class="py">.attrs</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parameter</span><span class="py">.hir_id.local_id</span><span class="p">)</span><span class="nf">.copied</span><span class="p">();</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">new_parameter_pat</span><span class="p">,</span> <span class="n">new_parameter_id</span><span class="p">)</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.pat_ident</span><span class="p">(</span><span class="n">desugared_span</span><span class="p">,</span> <span class="n">ident</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">new_parameter</span> <span class="o">=</span> <span class="nn">hir</span><span class="p">::</span><span class="n">Param</span> <span class="p">{</span>
                <span class="n">hir_id</span><span class="p">:</span> <span class="n">parameter</span><span class="py">.hir_id</span><span class="p">,</span>
                <span class="n">pat</span><span class="p">:</span> <span class="n">new_parameter_pat</span><span class="p">,</span>
                <span class="n">ty_span</span><span class="p">:</span> <span class="n">this</span><span class="nf">.lower_span</span><span class="p">(</span><span class="n">parameter</span><span class="py">.ty_span</span><span class="p">),</span>
                <span class="n">span</span><span class="p">:</span> <span class="n">this</span><span class="nf">.lower_span</span><span class="p">(</span><span class="n">parameter</span><span class="py">.span</span><span class="p">),</span>
            <span class="p">};</span>

            <span class="k">if</span> <span class="n">is_simple_parameter</span> <span class="p">{</span>
                <span class="c1">// If this is the simple case, then we only insert one statement that is</span>
                <span class="c1">// `let &lt;pat&gt; = &lt;pat&gt;;`. We re-use the original argument's pattern so that</span>
                <span class="c1">// `HirId`s are densely assigned.</span>
                <span class="k">let</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.expr_ident</span><span class="p">(</span><span class="n">desugared_span</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">new_parameter_id</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.stmt_let_pat</span><span class="p">(</span>
                    <span class="n">stmt_attrs</span><span class="p">,</span>
                    <span class="n">desugared_span</span><span class="p">,</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span>
                    <span class="n">parameter</span><span class="py">.pat</span><span class="p">,</span>
                    <span class="nn">hir</span><span class="p">::</span><span class="nn">LocalSource</span><span class="p">::</span><span class="n">AsyncFn</span><span class="p">,</span>
                <span class="p">);</span>
                <span class="n">statements</span><span class="nf">.push</span><span class="p">(</span><span class="n">stmt</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// If this is not the simple case, then we construct two statements:</span>
                <span class="c1">//</span>
                <span class="c1">// ```</span>
                <span class="c1">// let __argN = __argN;</span>
                <span class="c1">// let &lt;pat&gt; = __argN;</span>
                <span class="c1">// ```</span>
                <span class="c1">//</span>
                <span class="c1">// The first statement moves the parameter into the closure and thus ensures</span>
                <span class="c1">// that the drop order is correct.</span>
                <span class="c1">//</span>
                <span class="c1">// The second statement creates the bindings that the user wrote.</span>

                <span class="c1">// Construct the `let mut __argN = __argN;` statement. It must be a mut binding</span>
                <span class="c1">// because the user may have specified a `ref mut` binding in the next</span>
                <span class="c1">// statement.</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">move_pat</span><span class="p">,</span> <span class="n">move_id</span><span class="p">)</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.pat_ident_binding_mode</span><span class="p">(</span>
                    <span class="n">desugared_span</span><span class="p">,</span>
                    <span class="n">ident</span><span class="p">,</span>
                    <span class="nn">hir</span><span class="p">::</span><span class="nn">BindingAnnotation</span><span class="p">::</span><span class="n">Mutable</span><span class="p">,</span>
                <span class="p">);</span>
                <span class="k">let</span> <span class="n">move_expr</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.expr_ident</span><span class="p">(</span><span class="n">desugared_span</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">new_parameter_id</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">move_stmt</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.stmt_let_pat</span><span class="p">(</span>
                    <span class="nb">None</span><span class="p">,</span>
                    <span class="n">desugared_span</span><span class="p">,</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">move_expr</span><span class="p">),</span>
                    <span class="n">move_pat</span><span class="p">,</span>
                    <span class="nn">hir</span><span class="p">::</span><span class="nn">LocalSource</span><span class="p">::</span><span class="n">AsyncFn</span><span class="p">,</span>
                <span class="p">);</span>

                <span class="c1">// Construct the `let &lt;pat&gt; = __argN;` statement. We re-use the original</span>
                <span class="c1">// parameter's pattern so that `HirId`s are densely assigned.</span>
                <span class="k">let</span> <span class="n">pattern_expr</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.expr_ident</span><span class="p">(</span><span class="n">desugared_span</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">move_id</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">pattern_stmt</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.stmt_let_pat</span><span class="p">(</span>
                    <span class="n">stmt_attrs</span><span class="p">,</span>
                    <span class="n">desugared_span</span><span class="p">,</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">pattern_expr</span><span class="p">),</span>
                    <span class="n">parameter</span><span class="py">.pat</span><span class="p">,</span>
                    <span class="nn">hir</span><span class="p">::</span><span class="nn">LocalSource</span><span class="p">::</span><span class="n">AsyncFn</span><span class="p">,</span>
                <span class="p">);</span>

                <span class="n">statements</span><span class="nf">.push</span><span class="p">(</span><span class="n">move_stmt</span><span class="p">);</span>
                <span class="n">statements</span><span class="nf">.push</span><span class="p">(</span><span class="n">pattern_stmt</span><span class="p">);</span>
            <span class="p">};</span>

            <span class="n">parameters</span><span class="nf">.push</span><span class="p">(</span><span class="n">new_parameter</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">body_span</span> <span class="o">=</span> <span class="n">body</span><span class="nf">.map_or</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="p">|</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span><span class="py">.span</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">async_expr</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.make_async_expr</span><span class="p">(</span>
            <span class="nn">CaptureBy</span><span class="p">::</span><span class="n">Value</span><span class="p">,</span>
            <span class="n">closure_id</span><span class="p">,</span>
            <span class="nb">None</span><span class="p">,</span>
            <span class="n">body_span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">AsyncGeneratorKind</span><span class="p">::</span><span class="nb">Fn</span><span class="p">,</span>
            <span class="p">|</span><span class="n">this</span><span class="p">|</span> <span class="p">{</span>
                <span class="c1">// Create a block from the user's function body:</span>
                <span class="k">let</span> <span class="n">user_body</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.lower_block_expr_opt</span><span class="p">(</span><span class="n">body_span</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>

                <span class="c1">// Transform into `drop-temps { &lt;user-body&gt; }`, an expression:</span>
                <span class="k">let</span> <span class="n">desugared_span</span> <span class="o">=</span>
                    <span class="n">this</span><span class="nf">.mark_span_with_reason</span><span class="p">(</span><span class="nn">DesugaringKind</span><span class="p">::</span><span class="n">Async</span><span class="p">,</span> <span class="n">user_body</span><span class="py">.span</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">user_body</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.expr_drop_temps</span><span class="p">(</span>
                    <span class="n">desugared_span</span><span class="p">,</span>
                    <span class="n">this</span><span class="py">.arena</span><span class="nf">.alloc</span><span class="p">(</span><span class="n">user_body</span><span class="p">),</span>
                    <span class="nn">AttrVec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
                <span class="p">);</span>

                <span class="c1">// As noted above, create the final block like</span>
                <span class="c1">//</span>
                <span class="c1">// ```</span>
                <span class="c1">// {</span>
                <span class="c1">//   let $param_pattern = $raw_param;</span>
                <span class="c1">//   ...</span>
                <span class="c1">//   drop-temps { &lt;user-body&gt; }</span>
                <span class="c1">// }</span>
                <span class="c1">// ```</span>
                <span class="k">let</span> <span class="n">body</span> <span class="o">=</span> <span class="n">this</span><span class="nf">.block_all</span><span class="p">(</span>
                    <span class="n">desugared_span</span><span class="p">,</span>
                    <span class="n">this</span><span class="py">.arena</span><span class="nf">.alloc_from_iter</span><span class="p">(</span><span class="n">statements</span><span class="p">),</span>
                    <span class="nf">Some</span><span class="p">(</span><span class="n">user_body</span><span class="p">),</span>
                <span class="p">);</span>

                <span class="n">this</span><span class="nf">.expr_block</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="nn">AttrVec</span><span class="p">::</span><span class="nf">new</span><span class="p">())</span>
            <span class="p">},</span>
        <span class="p">);</span>

        <span class="p">(</span>
            <span class="n">this</span><span class="py">.arena</span><span class="nf">.alloc_from_iter</span><span class="p">(</span><span class="n">parameters</span><span class="p">),</span>
            <span class="n">this</span><span class="nf">.expr</span><span class="p">(</span><span class="n">body_span</span><span class="p">,</span> <span class="n">async_expr</span><span class="p">,</span> <span class="nn">AttrVec</span><span class="p">::</span><span class="nf">new</span><span class="p">()),</span>
        <span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">async fn</code> 被替换为 generator 后，它的参数作为 captured variable 保存在 closure 中，后续称它为 upvars，在计算 <code class="language-plaintext highlighter-rouge">Layout</code> 是会使用到。</p>

<p><code class="language-plaintext highlighter-rouge">await</code> 则会被替换为 <code class="language-plaintext highlighter-rouge">poll()</code>(compiler/rustc_ast_lowering/src/expr.rs):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Desugar `&lt;expr&gt;.await` into:</span>
<span class="cd">/// ```ignore (pseudo-rust)</span>
<span class="cd">/// match ::std::future::IntoFuture::into_future(&lt;expr&gt;) {</span>
<span class="cd">///     mut __awaitee =&gt; loop {</span>
<span class="cd">///         match unsafe { ::std::future::Future::poll(</span>
<span class="cd">///             &lt;::std::pin::Pin&gt;::new_unchecked(&amp;mut __awaitee),</span>
<span class="cd">///             ::std::future::get_context(task_context),</span>
<span class="cd">///         ) } {</span>
<span class="cd">///             ::std::task::Poll::Ready(result) =&gt; break result,</span>
<span class="cd">///             ::std::task::Poll::Pending =&gt; {}</span>
<span class="cd">///         }</span>
<span class="cd">///         task_context = yield ();</span>
<span class="cd">///     }</span>
<span class="cd">/// }</span>
<span class="cd">/// ```</span>
<span class="k">fn</span> <span class="nf">lower_expr_await</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">dot_await_span</span><span class="p">:</span> <span class="n">Span</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Expr</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">hir</span><span class="p">::</span><span class="n">ExprKind</span><span class="o">&lt;</span><span class="nv">'hir</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">full_span</span> <span class="o">=</span> <span class="n">expr</span><span class="py">.span</span><span class="nf">.to</span><span class="p">(</span><span class="n">dot_await_span</span><span class="p">);</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.generator_kind</span> <span class="p">{</span>
        <span class="nf">Some</span><span class="p">(</span><span class="nn">hir</span><span class="p">::</span><span class="nn">GeneratorKind</span><span class="p">::</span><span class="nf">Async</span><span class="p">(</span><span class="n">_</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">{}</span>
        <span class="nf">Some</span><span class="p">(</span><span class="nn">hir</span><span class="p">::</span><span class="nn">GeneratorKind</span><span class="p">::</span><span class="n">Gen</span><span class="p">)</span> <span class="p">|</span> <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tcx.sess</span><span class="nf">.emit_err</span><span class="p">(</span><span class="n">AwaitOnlyInAsyncFnAndBlocks</span> <span class="p">{</span>
                <span class="n">dot_await_span</span><span class="p">,</span>
                <span class="n">item_span</span><span class="p">:</span> <span class="k">self</span><span class="py">.current_item</span><span class="p">,</span>
            <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">span</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.mark_span_with_reason</span><span class="p">(</span><span class="nn">DesugaringKind</span><span class="p">::</span><span class="n">Await</span><span class="p">,</span> <span class="n">dot_await_span</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">gen_future_span</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.mark_span_with_reason</span><span class="p">(</span>
        <span class="nn">DesugaringKind</span><span class="p">::</span><span class="n">Await</span><span class="p">,</span>
        <span class="n">full_span</span><span class="p">,</span>
        <span class="k">self</span><span class="py">.allow_gen_future</span><span class="nf">.clone</span><span class="p">(),</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="n">expr</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.lower_expr_mut</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">expr_hir_id</span> <span class="o">=</span> <span class="n">expr</span><span class="py">.hir_id</span><span class="p">;</span>

    <span class="c1">// Note that the name of this binding must not be changed to something else because</span>
    <span class="c1">// debuggers and debugger extensions expect it to be called `__awaitee`. They use</span>
    <span class="c1">// this name to identify what is being awaited by a suspended async functions.</span>
    <span class="k">let</span> <span class="n">awaitee_ident</span> <span class="o">=</span> <span class="nn">Ident</span><span class="p">::</span><span class="nf">with_dummy_span</span><span class="p">(</span><span class="nn">sym</span><span class="p">::</span><span class="n">__awaitee</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">awaitee_pat</span><span class="p">,</span> <span class="n">awaitee_pat_hid</span><span class="p">)</span> <span class="o">=</span>
        <span class="k">self</span><span class="nf">.pat_ident_binding_mode</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">awaitee_ident</span><span class="p">,</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">BindingAnnotation</span><span class="p">::</span><span class="n">Mutable</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">task_context_ident</span> <span class="o">=</span> <span class="nn">Ident</span><span class="p">::</span><span class="nf">with_dummy_span</span><span class="p">(</span><span class="nn">sym</span><span class="p">::</span><span class="n">_task_context</span><span class="p">);</span>

    <span class="c1">// unsafe {</span>
    <span class="c1">//     ::std::future::Future::poll(</span>
    <span class="c1">//         ::std::pin::Pin::new_unchecked(&amp;mut __awaitee),</span>
    <span class="c1">//         ::std::future::get_context(task_context),</span>
    <span class="c1">//     )</span>
    <span class="c1">// }</span>
    <span class="k">let</span> <span class="n">poll_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">awaitee</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_ident</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">awaitee_ident</span><span class="p">,</span> <span class="n">awaitee_pat_hid</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">ref_mut_awaitee</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_mut_addr_of</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">awaitee</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">task_context</span> <span class="o">=</span> <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task_context_hid</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.task_context</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.expr_ident_mut</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">task_context_ident</span><span class="p">,</span> <span class="n">task_context_hid</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Use of `await` outside of an async context, we cannot use `task_context` here.</span>
            <span class="k">self</span><span class="nf">.expr_err</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="n">new_unchecked</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_call_lang_item_fn_mut</span><span class="p">(</span>
            <span class="n">span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">PinNewUnchecked</span><span class="p">,</span>
            <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">ref_mut_awaitee</span><span class="p">],</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="k">let</span> <span class="n">get_context</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_call_lang_item_fn_mut</span><span class="p">(</span>
            <span class="n">gen_future_span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">GetContext</span><span class="p">,</span>
            <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">task_context</span><span class="p">],</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="k">let</span> <span class="n">call</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_call_lang_item_fn</span><span class="p">(</span>
            <span class="n">span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">FuturePoll</span><span class="p">,</span>
            <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">new_unchecked</span><span class="p">,</span> <span class="n">get_context</span><span class="p">],</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="k">self</span><span class="py">.arena</span><span class="nf">.alloc</span><span class="p">(</span><span class="k">self</span><span class="nf">.expr_unsafe</span><span class="p">(</span><span class="n">call</span><span class="p">))</span>
    <span class="p">};</span>

    <span class="c1">// `::std::task::Poll::Ready(result) =&gt; break result`</span>
    <span class="k">let</span> <span class="n">loop_node_id</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.next_node_id</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">loop_hir_id</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.lower_node_id</span><span class="p">(</span><span class="n">loop_node_id</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">ready_arm</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x_ident</span> <span class="o">=</span> <span class="nn">Ident</span><span class="p">::</span><span class="nf">with_dummy_span</span><span class="p">(</span><span class="nn">sym</span><span class="p">::</span><span class="n">result</span><span class="p">);</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">x_pat</span><span class="p">,</span> <span class="n">x_pat_hid</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.pat_ident</span><span class="p">(</span><span class="n">gen_future_span</span><span class="p">,</span> <span class="n">x_ident</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">x_expr</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_ident</span><span class="p">(</span><span class="n">gen_future_span</span><span class="p">,</span> <span class="n">x_ident</span><span class="p">,</span> <span class="n">x_pat_hid</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">ready_field</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.single_pat_field</span><span class="p">(</span><span class="n">gen_future_span</span><span class="p">,</span> <span class="n">x_pat</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">ready_pat</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.pat_lang_item_variant</span><span class="p">(</span>
            <span class="n">span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">PollReady</span><span class="p">,</span>
            <span class="n">ready_field</span><span class="p">,</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="k">let</span> <span class="n">break_x</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.with_loop_scope</span><span class="p">(</span><span class="n">loop_node_id</span><span class="p">,</span> <span class="k">move</span> <span class="p">|</span><span class="n">this</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">expr_break</span> <span class="o">=</span>
                <span class="nn">hir</span><span class="p">::</span><span class="nn">ExprKind</span><span class="p">::</span><span class="nf">Break</span><span class="p">(</span><span class="n">this</span><span class="nf">.lower_loop_destination</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x_expr</span><span class="p">));</span>
            <span class="n">this</span><span class="py">.arena</span><span class="nf">.alloc</span><span class="p">(</span><span class="n">this</span><span class="nf">.expr</span><span class="p">(</span><span class="n">gen_future_span</span><span class="p">,</span> <span class="n">expr_break</span><span class="p">,</span> <span class="nn">AttrVec</span><span class="p">::</span><span class="nf">new</span><span class="p">()))</span>
        <span class="p">});</span>
        <span class="k">self</span><span class="nf">.arm</span><span class="p">(</span><span class="n">ready_pat</span><span class="p">,</span> <span class="n">break_x</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="c1">// `::std::task::Poll::Pending =&gt; {}`</span>
    <span class="k">let</span> <span class="n">pending_arm</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pending_pat</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.pat_lang_item_variant</span><span class="p">(</span>
            <span class="n">span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">PollPending</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="p">[],</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">),</span>
        <span class="p">);</span>
        <span class="k">let</span> <span class="n">empty_block</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_block_empty</span><span class="p">(</span><span class="n">span</span><span class="p">);</span>
        <span class="k">self</span><span class="nf">.arm</span><span class="p">(</span><span class="n">pending_pat</span><span class="p">,</span> <span class="n">empty_block</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">inner_match_stmt</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">match_expr</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_match</span><span class="p">(</span>
            <span class="n">span</span><span class="p">,</span>
            <span class="n">poll_expr</span><span class="p">,</span>
            <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">ready_arm</span><span class="p">,</span> <span class="n">pending_arm</span><span class="p">],</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">MatchSource</span><span class="p">::</span><span class="n">AwaitDesugar</span><span class="p">,</span>
        <span class="p">);</span>
        <span class="k">self</span><span class="nf">.stmt_expr</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">match_expr</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="c1">// task_context = yield ();</span>
    <span class="k">let</span> <span class="n">yield_stmt</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">unit</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_unit</span><span class="p">(</span><span class="n">span</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">yield_expr</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr</span><span class="p">(</span>
            <span class="n">span</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">ExprKind</span><span class="p">::</span><span class="nf">Yield</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">YieldSource</span><span class="p">::</span><span class="n">Await</span> <span class="p">{</span> <span class="n">expr</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">)</span> <span class="p">}),</span>
            <span class="nn">AttrVec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
        <span class="p">);</span>
        <span class="k">let</span> <span class="n">yield_expr</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arena</span><span class="nf">.alloc</span><span class="p">(</span><span class="n">yield_expr</span><span class="p">);</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">task_context_hid</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.task_context</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_ident</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">task_context_ident</span><span class="p">,</span> <span class="n">task_context_hid</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">assign</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr</span><span class="p">(</span>
                <span class="n">span</span><span class="p">,</span>
                <span class="nn">hir</span><span class="p">::</span><span class="nn">ExprKind</span><span class="p">::</span><span class="nf">Assign</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">yield_expr</span><span class="p">,</span> <span class="k">self</span><span class="nf">.lower_span</span><span class="p">(</span><span class="n">span</span><span class="p">)),</span>
                <span class="nn">AttrVec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="p">);</span>
            <span class="k">self</span><span class="nf">.stmt_expr</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Use of `await` outside of an async context. Return `yield_expr` so that we can</span>
            <span class="c1">// proceed with type checking.</span>
            <span class="k">self</span><span class="nf">.stmt</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">StmtKind</span><span class="p">::</span><span class="nf">Semi</span><span class="p">(</span><span class="n">yield_expr</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">loop_block</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.block_all</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">inner_match_stmt</span><span class="p">,</span> <span class="n">yield_stmt</span><span class="p">],</span> <span class="nb">None</span><span class="p">);</span>

    <span class="c1">// loop { .. }</span>
    <span class="k">let</span> <span class="n">loop_expr</span> <span class="o">=</span> <span class="k">self</span><span class="py">.arena</span><span class="nf">.alloc</span><span class="p">(</span><span class="nn">hir</span><span class="p">::</span><span class="n">Expr</span> <span class="p">{</span>
        <span class="n">hir_id</span><span class="p">:</span> <span class="n">loop_hir_id</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">ExprKind</span><span class="p">::</span><span class="nf">Loop</span><span class="p">(</span>
            <span class="n">loop_block</span><span class="p">,</span>
            <span class="nb">None</span><span class="p">,</span>
            <span class="nn">hir</span><span class="p">::</span><span class="nn">LoopSource</span><span class="p">::</span><span class="n">Loop</span><span class="p">,</span>
            <span class="k">self</span><span class="nf">.lower_span</span><span class="p">(</span><span class="n">span</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="n">span</span><span class="p">:</span> <span class="k">self</span><span class="nf">.lower_span</span><span class="p">(</span><span class="n">span</span><span class="p">),</span>
    <span class="p">});</span>

    <span class="c1">// mut __awaitee =&gt; loop { ... }</span>
    <span class="k">let</span> <span class="n">awaitee_arm</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.arm</span><span class="p">(</span><span class="n">awaitee_pat</span><span class="p">,</span> <span class="n">loop_expr</span><span class="p">);</span>

    <span class="c1">// `match ::std::future::IntoFuture::into_future(&lt;expr&gt;) { ... }`</span>
    <span class="k">let</span> <span class="n">into_future_span</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.mark_span_with_reason</span><span class="p">(</span>
        <span class="nn">DesugaringKind</span><span class="p">::</span><span class="n">Await</span><span class="p">,</span>
        <span class="n">dot_await_span</span><span class="p">,</span>
        <span class="k">self</span><span class="py">.allow_into_future</span><span class="nf">.clone</span><span class="p">(),</span>
    <span class="p">);</span>
    <span class="k">let</span> <span class="n">into_future_expr</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.expr_call_lang_item_fn</span><span class="p">(</span>
        <span class="n">into_future_span</span><span class="p">,</span>
        <span class="nn">hir</span><span class="p">::</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">IntoFutureIntoFuture</span><span class="p">,</span>
        <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">expr</span><span class="p">],</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">expr_hir_id</span><span class="p">),</span>
    <span class="p">);</span>

    <span class="c1">// match &lt;into_future_expr&gt; {</span>
    <span class="c1">//     mut __awaitee =&gt; loop { .. }</span>
    <span class="c1">// }</span>
    <span class="nn">hir</span><span class="p">::</span><span class="nn">ExprKind</span><span class="p">::</span><span class="nf">Match</span><span class="p">(</span>
        <span class="n">into_future_expr</span><span class="p">,</span>
        <span class="nd">arena_vec!</span><span class="p">[</span><span class="k">self</span><span class="p">;</span> <span class="n">awaitee_arm</span><span class="p">],</span>
        <span class="nn">hir</span><span class="p">::</span><span class="nn">MatchSource</span><span class="p">::</span><span class="n">AwaitDesugar</span><span class="p">,</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="generator-会被替换为-generatorstate">generator 会被替换为 GeneratorState</h2>

<p>此后 hir 会转换为 mir，generator 在 mir_transform 中被替换为 <code class="language-plaintext highlighter-rouge">GeneratorState</code>(compiler/rustc_mir_transform/src/generator.rs):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span> <span class="n">MirPass</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">StateTransform</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">run_pass</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">tcx</span><span class="p">:</span> <span class="n">TyCtxt</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Body</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">yield_ty</span><span class="p">)</span> <span class="o">=</span> <span class="n">body</span><span class="nf">.yield_ty</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// This only applies to generators</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="nd">assert!</span><span class="p">(</span><span class="n">body</span><span class="nf">.generator_drop</span><span class="p">()</span><span class="nf">.is_none</span><span class="p">());</span>
        <span class="nf">dump_mir</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="nb">None</span><span class="p">,</span> <span class="s">"generator_before"</span><span class="p">,</span> <span class="o">&amp;</span><span class="mi">0</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="p">|</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">|</span> <span class="nf">Ok</span><span class="p">(()));</span>

        <span class="c1">// The first argument is the generator type passed by value</span>
        <span class="k">let</span> <span class="n">gen_ty</span> <span class="o">=</span> <span class="n">body</span><span class="py">.local_decls.raw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="py">.ty</span><span class="p">;</span>

        <span class="c1">// Get the interior types and substs which typeck computed</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">upvars</span><span class="p">,</span> <span class="n">interior</span><span class="p">,</span> <span class="n">discr_ty</span><span class="p">,</span> <span class="n">movable</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="o">*</span><span class="n">gen_ty</span><span class="nf">.kind</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">ty</span><span class="p">::</span><span class="nf">Generator</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">substs</span><span class="p">,</span> <span class="n">movability</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">substs</span> <span class="o">=</span> <span class="n">substs</span><span class="nf">.as_generator</span><span class="p">();</span>
                <span class="p">(</span>
                    <span class="n">substs</span><span class="nf">.upvar_tys</span><span class="p">()</span><span class="nf">.collect</span><span class="p">(),</span>
                    <span class="n">substs</span><span class="nf">.witness</span><span class="p">(),</span>
                    <span class="n">substs</span><span class="nf">.discr_ty</span><span class="p">(</span><span class="n">tcx</span><span class="p">),</span>
                    <span class="n">movability</span> <span class="o">==</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">Movability</span><span class="p">::</span><span class="n">Movable</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">tcx</span><span class="py">.sess</span>
                    <span class="nf">.delay_span_bug</span><span class="p">(</span><span class="n">body</span><span class="py">.span</span><span class="p">,</span> <span class="o">&amp;</span><span class="nd">format!</span><span class="p">(</span><span class="s">"unexpected generator type {}"</span><span class="p">,</span> <span class="n">gen_ty</span><span class="p">));</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="c1">// Compute GeneratorState&lt;yield_ty, return_ty&gt;</span>
        <span class="k">let</span> <span class="n">state_did</span> <span class="o">=</span> <span class="n">tcx</span><span class="nf">.require_lang_item</span><span class="p">(</span><span class="nn">LangItem</span><span class="p">::</span><span class="n">GeneratorState</span><span class="p">,</span> <span class="nb">None</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">state_adt_ref</span> <span class="o">=</span> <span class="n">tcx</span><span class="nf">.adt_def</span><span class="p">(</span><span class="n">state_did</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">state_substs</span> <span class="o">=</span> <span class="n">tcx</span><span class="nf">.intern_substs</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="n">yield_ty</span><span class="nf">.into</span><span class="p">(),</span> <span class="n">body</span><span class="nf">.return_ty</span><span class="p">()</span><span class="nf">.into</span><span class="p">()]);</span>
        <span class="k">let</span> <span class="n">ret_ty</span> <span class="o">=</span> <span class="n">tcx</span><span class="nf">.mk_adt</span><span class="p">(</span><span class="n">state_adt_ref</span><span class="p">,</span> <span class="n">state_substs</span><span class="p">);</span>

        <span class="c1">// We rename RETURN_PLACE which has type mir.return_ty to new_ret_local</span>
        <span class="c1">// RETURN_PLACE then is a fresh unused local with type ret_ty.</span>
        <span class="k">let</span> <span class="n">new_ret_local</span> <span class="o">=</span> <span class="nf">replace_local</span><span class="p">(</span><span class="n">RETURN_PLACE</span><span class="p">,</span> <span class="n">ret_ty</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">tcx</span><span class="p">);</span>

        <span class="c1">// We also replace the resume argument and insert an `Assign`.</span>
        <span class="c1">// This is needed because the resume argument `_2` might be live across a `yield`, in which</span>
        <span class="c1">// case there is no `Assign` to it that the transform can turn into a store to the generator</span>
        <span class="c1">// state. After the yield the slot in the generator state would then be uninitialized.</span>
        <span class="k">let</span> <span class="n">resume_local</span> <span class="o">=</span> <span class="nn">Local</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">new_resume_local</span> <span class="o">=</span>
            <span class="nf">replace_local</span><span class="p">(</span><span class="n">resume_local</span><span class="p">,</span> <span class="n">body</span><span class="py">.local_decls</span><span class="p">[</span><span class="n">resume_local</span><span class="p">]</span><span class="py">.ty</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">tcx</span><span class="p">);</span>

        <span class="c1">// When first entering the generator, move the resume argument into its new local.</span>
        <span class="k">let</span> <span class="n">source_info</span> <span class="o">=</span> <span class="nn">SourceInfo</span><span class="p">::</span><span class="nf">outermost</span><span class="p">(</span><span class="n">body</span><span class="py">.span</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">stmts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">body</span><span class="nf">.basic_blocks_mut</span><span class="p">()[</span><span class="nn">BasicBlock</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span><span class="py">.statements</span><span class="p">;</span>
        <span class="n">stmts</span><span class="nf">.insert</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">Statement</span> <span class="p">{</span>
                <span class="n">source_info</span><span class="p">,</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">StatementKind</span><span class="p">::</span><span class="nf">Assign</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">((</span>
                    <span class="n">new_resume_local</span><span class="nf">.into</span><span class="p">(),</span>
                    <span class="nn">Rvalue</span><span class="p">::</span><span class="nf">Use</span><span class="p">(</span><span class="nn">Operand</span><span class="p">::</span><span class="nf">Move</span><span class="p">(</span><span class="n">resume_local</span><span class="nf">.into</span><span class="p">())),</span>
                <span class="p">))),</span>
            <span class="p">},</span>
        <span class="p">);</span>

        <span class="k">let</span> <span class="n">always_live_locals</span> <span class="o">=</span> <span class="nf">always_storage_live_locals</span><span class="p">(</span><span class="o">&amp;</span><span class="n">body</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">liveness_info</span> <span class="o">=</span>
            <span class="nf">locals_live_across_suspend_points</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">always_live_locals</span><span class="p">,</span> <span class="n">movable</span><span class="p">);</span>

        <span class="nf">sanitize_witness</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">interior</span><span class="p">,</span> <span class="n">upvars</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">liveness_info</span><span class="py">.saved_locals</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">tcx</span><span class="py">.sess.opts.unstable_opts.validate_mir</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">vis</span> <span class="o">=</span> <span class="n">EnsureGeneratorFieldAssignmentsNeverAlias</span> <span class="p">{</span>
                <span class="n">assigned_local</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
                <span class="n">saved_locals</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">liveness_info</span><span class="py">.saved_locals</span><span class="p">,</span>
                <span class="n">storage_conflicts</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">liveness_info</span><span class="py">.storage_conflicts</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="n">vis</span><span class="nf">.visit_body</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Extract locals which are live across suspension point into `layout`</span>
        <span class="c1">// `remap` gives a mapping from local indices onto generator struct indices</span>
        <span class="c1">// `storage_liveness` tells us which locals have live storage at suspension points</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">remap</span><span class="p">,</span> <span class="n">layout</span><span class="p">,</span> <span class="n">storage_liveness</span><span class="p">)</span> <span class="o">=</span> <span class="nf">compute_layout</span><span class="p">(</span><span class="n">liveness_info</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">can_return</span> <span class="o">=</span> <span class="nf">can_return</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">tcx</span><span class="nf">.param_env</span><span class="p">(</span><span class="n">body</span><span class="py">.source</span><span class="nf">.def_id</span><span class="p">()));</span>

        <span class="c1">// Run the transformation which converts Places from Local to generator struct</span>
        <span class="c1">// accesses for locals in `remap`.</span>
        <span class="c1">// It also rewrites `return x` and `yield y` as writing a new generator state and returning</span>
        <span class="c1">// GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively.</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">TransformVisitor</span> <span class="p">{</span>
            <span class="n">tcx</span><span class="p">,</span>
            <span class="n">state_adt_ref</span><span class="p">,</span>
            <span class="n">state_substs</span><span class="p">,</span>
            <span class="n">remap</span><span class="p">,</span>
            <span class="n">storage_liveness</span><span class="p">,</span>
            <span class="n">always_live_locals</span><span class="p">,</span>
            <span class="n">suspension_points</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="n">new_ret_local</span><span class="p">,</span>
            <span class="n">discr_ty</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="n">transform</span><span class="nf">.visit_body</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>

        <span class="c1">// Update our MIR struct to reflect the changes we've made</span>
        <span class="n">body</span><span class="py">.arg_count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// self, resume arg</span>
        <span class="n">body</span><span class="py">.spread_arg</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

        <span class="n">body</span><span class="py">.generator</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.yield_ty</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
        <span class="n">body</span><span class="py">.generator</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.generator_layout</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>

        <span class="c1">// Insert `drop(generator_struct)` which is used to drop upvars for generators in</span>
        <span class="c1">// the unresumed state.</span>
        <span class="c1">// This is expanded to a drop ladder in `elaborate_generator_drops`.</span>
        <span class="k">let</span> <span class="n">drop_clean</span> <span class="o">=</span> <span class="nf">insert_clean_drop</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>

        <span class="nf">dump_mir</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="nb">None</span><span class="p">,</span> <span class="s">"generator_pre-elab"</span><span class="p">,</span> <span class="o">&amp;</span><span class="mi">0</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="p">|</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">|</span> <span class="nf">Ok</span><span class="p">(()));</span>

        <span class="c1">// Expand `drop(generator_struct)` to a drop ladder which destroys upvars.</span>
        <span class="c1">// If any upvars are moved out of, drop elaboration will handle upvar destruction.</span>
        <span class="c1">// However we need to also elaborate the code generated by `insert_clean_drop`.</span>
        <span class="nf">elaborate_generator_drops</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>

        <span class="nf">dump_mir</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="nb">None</span><span class="p">,</span> <span class="s">"generator_post-transform"</span><span class="p">,</span> <span class="o">&amp;</span><span class="mi">0</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="p">|</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">|</span> <span class="nf">Ok</span><span class="p">(()));</span>

        <span class="c1">// Create a copy of our MIR and use it to create the drop shim for the generator</span>
        <span class="k">let</span> <span class="n">drop_shim</span> <span class="o">=</span> <span class="nf">create_generator_drop_shim</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transform</span><span class="p">,</span> <span class="n">gen_ty</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">drop_clean</span><span class="p">);</span>

        <span class="n">body</span><span class="py">.generator</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="py">.generator_drop</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">drop_shim</span><span class="p">);</span>

        <span class="c1">// Create the Generator::resume function</span>
        <span class="nf">create_generator_resume_function</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">can_return</span><span class="p">);</span>

        <span class="c1">// Run derefer to fix Derefs that are not in the first place</span>
        <span class="nf">deref_finder</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>第 85 行 <code class="language-plaintext highlighter-rouge">compute_layout</code> 计算出 <code class="language-plaintext highlighter-rouge">GeneratorLayout</code>，并在 111 行保存到 <code class="language-plaintext highlighter-rouge">body.generator</code> 中。这里的 <code class="language-plaintext highlighter-rouge">GeneratorLayout</code> 就是 <code class="language-plaintext highlighter-rouge">GeneratorState</code> 的内存空间，它分成两部分：<code class="language-plaintext highlighter-rouge">prefix</code> + <code class="language-plaintext highlighter-rouge">variants</code>。<code class="language-plaintext highlighter-rouge">prefix</code> 保存了会跨越 <code class="language-plaintext highlighter-rouge">suspend point</code> 的变量，<code class="language-plaintext highlighter-rouge">variants</code> 是不同的 state，其中保存了只会在当前 state 使用到的变量。</p>

<h2 id="generatorstate-的内存布局是如何计算的">GeneratorState 的内存布局是如何计算的？</h2>

<p>编译器在代码生成阶段会根据前面计算得到的 <code class="language-plaintext highlighter-rouge">GeneratorLayout</code> 算出最终的内存布局 <code class="language-plaintext highlighter-rouge">Layout</code>(compiler/rustc_middle/src/ty/layout.rs):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Compute the full generator layout.</span>
<span class="k">fn</span> <span class="nf">generator_layout</span><span class="p">(</span>
    <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
    <span class="n">ty</span><span class="p">:</span> <span class="n">Ty</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">def_id</span><span class="p">:</span> <span class="nn">hir</span><span class="p">::</span><span class="nn">def_id</span><span class="p">::</span><span class="n">DefId</span><span class="p">,</span>
    <span class="n">substs</span><span class="p">:</span> <span class="n">SubstsRef</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Layout</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">LayoutError</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">SavedLocalEligibility</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">tcx</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tcx</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">subst_field</span> <span class="o">=</span> <span class="p">|</span><span class="n">ty</span><span class="p">:</span> <span class="n">Ty</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">|</span> <span class="nf">EarlyBinder</span><span class="p">(</span><span class="n">ty</span><span class="p">)</span><span class="nf">.subst</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="n">substs</span><span class="p">);</span>

    <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">=</span> <span class="n">tcx</span><span class="nf">.generator_layout</span><span class="p">(</span><span class="n">def_id</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">LayoutError</span><span class="p">::</span><span class="nf">Unknown</span><span class="p">(</span><span class="n">ty</span><span class="p">));</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">ineligible_locals</span><span class="p">,</span> <span class="n">assignments</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.generator_saved_local_eligibility</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

    <span class="c1">// Build a prefix layout, including "promoting" all ineligible</span>
    <span class="c1">// locals as part of the prefix. We compute the layout of all of</span>
    <span class="c1">// these fields at once to get optimal packing.</span>
    <span class="k">let</span> <span class="n">tag_index</span> <span class="o">=</span> <span class="n">substs</span><span class="nf">.as_generator</span><span class="p">()</span><span class="nf">.prefix_tys</span><span class="p">()</span><span class="nf">.count</span><span class="p">();</span>

    <span class="c1">// `info.variant_fields` already accounts for the reserved variants, so no need to add them.</span>
    <span class="k">let</span> <span class="n">max_discr</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="py">.variant_fields</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u128</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">discr_int</span> <span class="o">=</span> <span class="nn">Integer</span><span class="p">::</span><span class="nf">fit_unsigned</span><span class="p">(</span><span class="n">max_discr</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">discr_int_ty</span> <span class="o">=</span> <span class="n">discr_int</span><span class="nf">.to_ty</span><span class="p">(</span><span class="n">tcx</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">tag</span> <span class="o">=</span> <span class="nn">Scalar</span><span class="p">::</span><span class="n">Initialized</span> <span class="p">{</span>
        <span class="n">value</span><span class="p">:</span> <span class="nn">Primitive</span><span class="p">::</span><span class="nf">Int</span><span class="p">(</span><span class="n">discr_int</span><span class="p">,</span> <span class="k">false</span><span class="p">),</span>
        <span class="n">valid_range</span><span class="p">:</span> <span class="n">WrappingRange</span> <span class="p">{</span> <span class="n">start</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">max_discr</span> <span class="p">},</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">tag_layout</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tcx</span><span class="nf">.intern_layout</span><span class="p">(</span><span class="nn">LayoutS</span><span class="p">::</span><span class="nf">scalar</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">tag_layout</span> <span class="o">=</span> <span class="n">TyAndLayout</span> <span class="p">{</span> <span class="n">ty</span><span class="p">:</span> <span class="n">discr_int_ty</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="n">tag_layout</span> <span class="p">};</span>

    <span class="k">let</span> <span class="n">promoted_layouts</span> <span class="o">=</span> <span class="n">ineligible_locals</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">local</span><span class="p">|</span> <span class="nf">subst_field</span><span class="p">(</span><span class="n">info</span><span class="py">.field_tys</span><span class="p">[</span><span class="n">local</span><span class="p">]))</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="n">tcx</span><span class="nf">.mk_maybe_uninit</span><span class="p">(</span><span class="n">ty</span><span class="p">))</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="k">self</span><span class="nf">.layout_of</span><span class="p">(</span><span class="n">ty</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">prefix_layouts</span> <span class="o">=</span> <span class="n">substs</span>
        <span class="nf">.as_generator</span><span class="p">()</span>
        <span class="nf">.prefix_tys</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="k">self</span><span class="nf">.layout_of</span><span class="p">(</span><span class="n">ty</span><span class="p">))</span>
        <span class="nf">.chain</span><span class="p">(</span><span class="nn">iter</span><span class="p">::</span><span class="nf">once</span><span class="p">(</span><span class="nf">Ok</span><span class="p">(</span><span class="n">tag_layout</span><span class="p">)))</span>
        <span class="nf">.chain</span><span class="p">(</span><span class="n">promoted_layouts</span><span class="p">)</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">prefix</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.univariant_uninterned</span><span class="p">(</span>
        <span class="n">ty</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">prefix_layouts</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="nn">ReprOptions</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
        <span class="nn">StructKind</span><span class="p">::</span><span class="n">AlwaysSized</span><span class="p">,</span>
    <span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">prefix_size</span><span class="p">,</span> <span class="n">prefix_align</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">prefix</span><span class="py">.size</span><span class="p">,</span> <span class="n">prefix</span><span class="py">.align</span><span class="p">);</span>

    <span class="c1">// Split the prefix layout into the "outer" fields (upvars and</span>
    <span class="c1">// discriminant) and the "promoted" fields. Promoted fields will</span>
    <span class="c1">// get included in each variant that requested them in</span>
    <span class="c1">// GeneratorLayout.</span>
    <span class="nd">debug!</span><span class="p">(</span><span class="s">"prefix = {:#?}"</span><span class="p">,</span> <span class="n">prefix</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">outer_fields</span><span class="p">,</span> <span class="n">promoted_offsets</span><span class="p">,</span> <span class="n">promoted_memory_index</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">prefix</span><span class="py">.fields</span> <span class="p">{</span>
        <span class="nn">FieldsShape</span><span class="p">::</span><span class="n">Arbitrary</span> <span class="p">{</span> <span class="k">mut</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">memory_index</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">inverse_memory_index</span> <span class="o">=</span> <span class="nf">invert_mapping</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memory_index</span><span class="p">);</span>

            <span class="c1">// "a" (`0..b_start`) and "b" (`b_start..`) correspond to</span>
            <span class="c1">// "outer" and "promoted" fields respectively.</span>
            <span class="k">let</span> <span class="n">b_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">tag_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">offsets_b</span> <span class="o">=</span> <span class="n">offsets</span><span class="nf">.split_off</span><span class="p">(</span><span class="n">b_start</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">offsets_a</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">;</span>

            <span class="c1">// Disentangle the "a" and "b" components of `inverse_memory_index`</span>
            <span class="c1">// by preserving the order but keeping only one disjoint "half" each.</span>
            <span class="c1">// FIXME(eddyb) build a better abstraction for permutations, if possible.</span>
            <span class="k">let</span> <span class="n">inverse_memory_index_b</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span>
                <span class="n">inverse_memory_index</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.filter_map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span><span class="nf">.checked_sub</span><span class="p">(</span><span class="n">b_start</span><span class="p">))</span><span class="nf">.collect</span><span class="p">();</span>
            <span class="n">inverse_memory_index</span><span class="nf">.retain</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b_start</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">inverse_memory_index_a</span> <span class="o">=</span> <span class="n">inverse_memory_index</span><span class="p">;</span>

            <span class="c1">// Since `inverse_memory_index_{a,b}` each only refer to their</span>
            <span class="c1">// respective fields, they can be safely inverted</span>
            <span class="k">let</span> <span class="n">memory_index_a</span> <span class="o">=</span> <span class="nf">invert_mapping</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inverse_memory_index_a</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">memory_index_b</span> <span class="o">=</span> <span class="nf">invert_mapping</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inverse_memory_index_b</span><span class="p">);</span>

            <span class="k">let</span> <span class="n">outer_fields</span> <span class="o">=</span>
                <span class="nn">FieldsShape</span><span class="p">::</span><span class="n">Arbitrary</span> <span class="p">{</span> <span class="n">offsets</span><span class="p">:</span> <span class="n">offsets_a</span><span class="p">,</span> <span class="n">memory_index</span><span class="p">:</span> <span class="n">memory_index_a</span> <span class="p">};</span>
            <span class="p">(</span><span class="n">outer_fields</span><span class="p">,</span> <span class="n">offsets_b</span><span class="p">,</span> <span class="n">memory_index_b</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">bug!</span><span class="p">(),</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">size</span> <span class="o">=</span> <span class="n">prefix</span><span class="py">.size</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">align</span> <span class="o">=</span> <span class="n">prefix</span><span class="py">.align</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">variants</span> <span class="o">=</span> <span class="n">info</span>
        <span class="py">.variant_fields</span>
        <span class="nf">.iter_enumerated</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">index</span><span class="p">,</span> <span class="n">variant_fields</span><span class="p">)|</span> <span class="p">{</span>
            <span class="c1">// Only include overlap-eligible fields when we compute our variant layout.</span>
            <span class="k">let</span> <span class="n">variant_only_tys</span> <span class="o">=</span> <span class="n">variant_fields</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="n">local</span><span class="p">|</span> <span class="k">match</span> <span class="n">assignments</span><span class="p">[</span><span class="o">**</span><span class="n">local</span><span class="p">]</span> <span class="p">{</span>
                    <span class="n">Unassigned</span> <span class="k">=&gt;</span> <span class="nd">bug!</span><span class="p">(),</span>
                    <span class="nf">Assigned</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">index</span> <span class="k">=&gt;</span> <span class="k">true</span><span class="p">,</span>
                    <span class="nf">Assigned</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">bug!</span><span class="p">(</span><span class="s">"assignment does not match variant"</span><span class="p">),</span>
                    <span class="nf">Ineligible</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">false</span><span class="p">,</span>
                <span class="p">})</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">local</span><span class="p">|</span> <span class="nf">subst_field</span><span class="p">(</span><span class="n">info</span><span class="py">.field_tys</span><span class="p">[</span><span class="o">*</span><span class="n">local</span><span class="p">]));</span>

            <span class="k">let</span> <span class="k">mut</span> <span class="n">variant</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.univariant_uninterned</span><span class="p">(</span>
                <span class="n">ty</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">variant_only_tys</span>
                    <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="k">self</span><span class="nf">.layout_of</span><span class="p">(</span><span class="n">ty</span><span class="p">))</span>
                    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="nn">ReprOptions</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
                <span class="nn">StructKind</span><span class="p">::</span><span class="nf">Prefixed</span><span class="p">(</span><span class="n">prefix_size</span><span class="p">,</span> <span class="n">prefix_align</span><span class="py">.abi</span><span class="p">),</span>
            <span class="p">)</span><span class="o">?</span><span class="p">;</span>
            <span class="n">variant</span><span class="py">.variants</span> <span class="o">=</span> <span class="nn">Variants</span><span class="p">::</span><span class="n">Single</span> <span class="p">{</span> <span class="n">index</span> <span class="p">};</span>

            <span class="k">let</span> <span class="nn">FieldsShape</span><span class="p">::</span><span class="n">Arbitrary</span> <span class="p">{</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">memory_index</span> <span class="p">}</span> <span class="o">=</span> <span class="n">variant</span><span class="py">.fields</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">bug!</span><span class="p">();</span>
            <span class="p">};</span>

            <span class="c1">// Now, stitch the promoted and variant-only fields back together in</span>
            <span class="c1">// the order they are mentioned by our GeneratorLayout.</span>
            <span class="c1">// Because we only use some subset (that can differ between variants)</span>
            <span class="c1">// of the promoted fields, we can't just pick those elements of the</span>
            <span class="c1">// `promoted_memory_index` (as we'd end up with gaps).</span>
            <span class="c1">// So instead, we build an "inverse memory_index", as if all of the</span>
            <span class="c1">// promoted fields were being used, but leave the elements not in the</span>
            <span class="c1">// subset as `INVALID_FIELD_IDX`, which we can filter out later to</span>
            <span class="c1">// obtain a valid (bijective) mapping.</span>
            <span class="k">const</span> <span class="n">INVALID_FIELD_IDX</span><span class="p">:</span> <span class="nb">u32</span> <span class="o">=</span> <span class="o">!</span><span class="mi">0</span><span class="p">;</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">combined_inverse_memory_index</span> <span class="o">=</span>
                <span class="nd">vec!</span><span class="p">[</span><span class="n">INVALID_FIELD_IDX</span><span class="p">;</span> <span class="n">promoted_memory_index</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="n">memory_index</span><span class="nf">.len</span><span class="p">()];</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">offsets_and_memory_index</span> <span class="o">=</span> <span class="nn">iter</span><span class="p">::</span><span class="nf">zip</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">memory_index</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">combined_offsets</span> <span class="o">=</span> <span class="n">variant_fields</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.enumerate</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">i</span><span class="p">,</span> <span class="n">local</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">memory_index</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">assignments</span><span class="p">[</span><span class="o">*</span><span class="n">local</span><span class="p">]</span> <span class="p">{</span>
                        <span class="n">Unassigned</span> <span class="k">=&gt;</span> <span class="nd">bug!</span><span class="p">(),</span>
                        <span class="nf">Assigned</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">memory_index</span><span class="p">)</span> <span class="o">=</span>
                                <span class="n">offsets_and_memory_index</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                            <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">promoted_memory_index</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">u32</span> <span class="o">+</span> <span class="n">memory_index</span><span class="p">)</span>
                        <span class="p">}</span>
                        <span class="nf">Ineligible</span><span class="p">(</span><span class="n">field_idx</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                            <span class="k">let</span> <span class="n">field_idx</span> <span class="o">=</span> <span class="n">field_idx</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
                            <span class="p">(</span><span class="n">promoted_offsets</span><span class="p">[</span><span class="n">field_idx</span><span class="p">],</span> <span class="n">promoted_memory_index</span><span class="p">[</span><span class="n">field_idx</span><span class="p">])</span>
                        <span class="p">}</span>
                    <span class="p">};</span>
                    <span class="n">combined_inverse_memory_index</span><span class="p">[</span><span class="n">memory_index</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">u32</span><span class="p">;</span>
                    <span class="n">offset</span>
                <span class="p">})</span>
                <span class="nf">.collect</span><span class="p">();</span>

            <span class="c1">// Remove the unused slots and invert the mapping to obtain the</span>
            <span class="c1">// combined `memory_index` (also see previous comment).</span>
            <span class="n">combined_inverse_memory_index</span><span class="nf">.retain</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">INVALID_FIELD_IDX</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">combined_memory_index</span> <span class="o">=</span> <span class="nf">invert_mapping</span><span class="p">(</span><span class="o">&amp;</span><span class="n">combined_inverse_memory_index</span><span class="p">);</span>

            <span class="n">variant</span><span class="py">.fields</span> <span class="o">=</span> <span class="nn">FieldsShape</span><span class="p">::</span><span class="n">Arbitrary</span> <span class="p">{</span>
                <span class="n">offsets</span><span class="p">:</span> <span class="n">combined_offsets</span><span class="p">,</span>
                <span class="n">memory_index</span><span class="p">:</span> <span class="n">combined_memory_index</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="nf">.max</span><span class="p">(</span><span class="n">variant</span><span class="py">.size</span><span class="p">);</span>
            <span class="n">align</span> <span class="o">=</span> <span class="n">align</span><span class="nf">.max</span><span class="p">(</span><span class="n">variant</span><span class="py">.align</span><span class="p">);</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="n">tcx</span><span class="nf">.intern_layout</span><span class="p">(</span><span class="n">variant</span><span class="p">))</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">IndexVec</span><span class="o">&lt;</span><span class="n">VariantIdx</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="nf">.align_to</span><span class="p">(</span><span class="n">align</span><span class="py">.abi</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">abi</span> <span class="o">=</span>
        <span class="k">if</span> <span class="n">prefix</span><span class="py">.abi</span><span class="nf">.is_uninhabited</span><span class="p">()</span> <span class="p">||</span> <span class="n">variants</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">v</span><span class="nf">.abi</span><span class="p">()</span><span class="nf">.is_uninhabited</span><span class="p">())</span> <span class="p">{</span>
            <span class="nn">Abi</span><span class="p">::</span><span class="n">Uninhabited</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nn">Abi</span><span class="p">::</span><span class="n">Aggregate</span> <span class="p">{</span> <span class="n">sized</span><span class="p">:</span> <span class="k">true</span> <span class="p">}</span>
        <span class="p">};</span>

    <span class="k">let</span> <span class="n">layout</span> <span class="o">=</span> <span class="n">tcx</span><span class="nf">.intern_layout</span><span class="p">(</span><span class="n">LayoutS</span> <span class="p">{</span>
        <span class="n">variants</span><span class="p">:</span> <span class="nn">Variants</span><span class="p">::</span><span class="n">Multiple</span> <span class="p">{</span>
            <span class="n">tag</span><span class="p">,</span>
            <span class="n">tag_encoding</span><span class="p">:</span> <span class="nn">TagEncoding</span><span class="p">::</span><span class="n">Direct</span><span class="p">,</span>
            <span class="n">tag_field</span><span class="p">:</span> <span class="n">tag_index</span><span class="p">,</span>
            <span class="n">variants</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">outer_fields</span><span class="p">,</span>
        <span class="n">abi</span><span class="p">,</span>
        <span class="n">largest_niche</span><span class="p">:</span> <span class="n">prefix</span><span class="py">.largest_niche</span><span class="p">,</span>
        <span class="n">size</span><span class="p">,</span>
        <span class="n">align</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="nd">debug!</span><span class="p">(</span><span class="s">"generator layout ({:?}): {:#?}"</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">layout</span><span class="p">);</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">LayoutS</code> 的定义为：</p>

<pre><code class="language-Rust">#[derive(PartialEq, Eq, Hash, HashStable_Generic)]
pub struct LayoutS&lt;'a&gt; {
    /// Says where the fields are located within the layout.
    pub fields: FieldsShape,

    /// Encodes information about multi-variant layouts.
    /// Even with `Multiple` variants, a layout still has its own fields! Those are then
    /// shared between all variants. One of them will be the discriminant,
    /// but e.g. generators can have more.
    ///
    /// To access all fields of this layout, both `fields` and the fields of the active variant
    /// must be taken into account.
    pub variants: Variants&lt;'a&gt;,

    /// The `abi` defines how this data is passed between functions, and it defines
    /// value restrictions via `valid_range`.
    ///
    /// Note that this is entirely orthogonal to the recursive structure defined by
    /// `variants` and `fields`; for example, `ManuallyDrop&lt;Result&lt;isize, isize&gt;&gt;` has
    /// `Abi::ScalarPair`! So, even with non-`Aggregate` `abi`, `fields` and `variants`
    /// have to be taken into account to find all fields of this layout.
    pub abi: Abi,

    /// The leaf scalar with the largest number of invalid values
    /// (i.e. outside of its `valid_range`), if it exists.
    pub largest_niche: Option&lt;Niche&gt;,

    pub align: AbiAndPrefAlign,
    pub size: Size,
}
</code></pre>

<p>根据定义，<code class="language-plaintext highlighter-rouge">fields</code> + <code class="language-plaintext highlighter-rouge">variants</code> 组成了 <code class="language-plaintext highlighter-rouge">GeneratorState</code> 的内存布局：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>To access all fields of this layout, both `fields` and the fields of the active variant must be taken into account.
</code></pre></div></div>

<p>在 <code class="language-plaintext highlighter-rouge">generator_layout</code> 函数中，<code class="language-plaintext highlighter-rouge">fields</code> 是 <code class="language-plaintext highlighter-rouge">outer_fields</code>，variants 是 <code class="language-plaintext highlighter-rouge">Variant::Multiple</code> 的实例，其中保存了 <code class="language-plaintext highlighter-rouge">variants</code> 和一个 <code class="language-plaintext highlighter-rouge">tag_field</code>。<code class="language-plaintext highlighter-rouge">outer_fields</code> 和 <code class="language-plaintext highlighter-rouge">variants</code> 均由 <code class="language-plaintext highlighter-rouge">prefix</code> 计算得到：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Split the prefix layout into the "outer" fields (upvars and</span>
<span class="c1">// discriminant) and the "promoted" fields. Promoted fields will</span>
<span class="c1">// get included in each variant that requested them in</span>
<span class="c1">// GeneratorLayout</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">prefix</code> 的计算方式为：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">tag_layout</span> <span class="o">=</span> <span class="k">self</span><span class="py">.tcx</span><span class="nf">.intern_layout</span><span class="p">(</span><span class="nn">LayoutS</span><span class="p">::</span><span class="nf">scalar</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">));</span>
<span class="k">let</span> <span class="n">tag_layout</span> <span class="o">=</span> <span class="n">TyAndLayout</span> <span class="p">{</span> <span class="n">ty</span><span class="p">:</span> <span class="n">discr_int_ty</span><span class="p">,</span> <span class="n">layout</span><span class="p">:</span> <span class="n">tag_layout</span> <span class="p">};</span>

<span class="k">let</span> <span class="n">promoted_layouts</span> <span class="o">=</span> <span class="n">ineligible_locals</span>
    <span class="nf">.iter</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|</span><span class="n">local</span><span class="p">|</span> <span class="nf">subst_field</span><span class="p">(</span><span class="n">info</span><span class="py">.field_tys</span><span class="p">[</span><span class="n">local</span><span class="p">]))</span>
    <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="n">tcx</span><span class="nf">.mk_maybe_uninit</span><span class="p">(</span><span class="n">ty</span><span class="p">))</span>
    <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="k">self</span><span class="nf">.layout_of</span><span class="p">(</span><span class="n">ty</span><span class="p">));</span>
<span class="k">let</span> <span class="n">prefix_layouts</span> <span class="o">=</span> <span class="n">substs</span>
    <span class="nf">.as_generator</span><span class="p">()</span>
    <span class="nf">.prefix_tys</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|</span><span class="n">ty</span><span class="p">|</span> <span class="k">self</span><span class="nf">.layout_of</span><span class="p">(</span><span class="n">ty</span><span class="p">))</span>
    <span class="nf">.chain</span><span class="p">(</span><span class="nn">iter</span><span class="p">::</span><span class="nf">once</span><span class="p">(</span><span class="nf">Ok</span><span class="p">(</span><span class="n">tag_layout</span><span class="p">)))</span>
    <span class="nf">.chain</span><span class="p">(</span><span class="n">promoted_layouts</span><span class="p">)</span>
    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="k">let</span> <span class="n">prefix</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.univariant_uninterned</span><span class="p">(</span>
    <span class="n">ty</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">prefix_layouts</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="nn">ReprOptions</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
    <span class="nn">StructKind</span><span class="p">::</span><span class="n">AlwaysSized</span><span class="p">,</span>
<span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div></div>

<p>其中 <code class="language-plaintext highlighter-rouge">prefix_tys()</code> 返回的就是前面提到的 <code class="language-plaintext highlighter-rouge">upvars</code>：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// This is the types of the fields of a generator which are not stored in a</span>
<span class="cd">/// variant.</span>
<span class="nd">#[inline]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">prefix_tys</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">Ty</span><span class="o">&lt;</span><span class="nv">'tcx</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.upvar_tys</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因此，一个 <code class="language-plaintext highlighter-rouge">GeneratorState</code> 的 <code class="language-plaintext highlighter-rouge">Layout</code> 中会包含一个 <code class="language-plaintext highlighter-rouge">tag</code>，<code class="language-plaintext highlighter-rouge">upvars</code>，以及由不同 state 组成的 <code class="language-plaintext highlighter-rouge">variants</code>。回到 <code class="language-plaintext highlighter-rouge">root_heartbeat</code> 的例子，<code class="language-plaintext highlighter-rouge">streaming()</code> 中，除了 <code class="language-plaintext highlighter-rouge">request</code> 和 <code class="language-plaintext highlighter-rouge">response</code> 外，还会保存下参数中的 <code class="language-plaintext highlighter-rouge">request: Request&lt;S&gt;</code>，<code class="language-plaintext highlighter-rouge">path</code> 和 <code class="language-plaintext highlighter-rouge">codec</code>。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">codec</code>: <code class="language-plaintext highlighter-rouge">tonic::codec::ProstCodec&lt;engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt;</code> size 0 bytes</li>
  <li><code class="language-plaintext highlighter-rouge">request</code>: <code class="language-plaintext highlighter-rouge">tonic::Request&lt;futures::stream::Once&lt;futures::future::Ready&lt;engula_api::server::v1::HeartbeatRequest&gt;&gt;&gt;</code> size 144 bytes</li>
  <li><code class="language-plaintext highlighter-rouge">path</code>: <code class="language-plaintext highlighter-rouge">http::uri::path::PathAndQuery</code> size 40 bytes</li>
  <li>tag: u8</li>
</ul>

<p>最终的大小为：self(8 bytes) + request(144 bytes) + path(40 bytes) + uri(88 bytes) + request(240 bytes, http request) + response(32 bytes) + tag(1 byte, aligned to 8) = 560</p>

<blockquote>
  <p>此处 <code class="language-plaintext highlighter-rouge">uri</code> 是前面计算漏掉的变量。</p>
</blockquote>

<p>由于 <code class="language-plaintext highlighter-rouge">async fn</code> 的参数作为 captured variable，会放置在 <code class="language-plaintext highlighter-rouge">outer_fields</code> 中。如果一个非常大的参数层层传递到内部的某个 <code class="language-plaintext highlighter-rouge">async fn</code>，会被一层层放大，最终导致 <code class="language-plaintext highlighter-rouge">Future</code> 大小呈现指数增长。 19 年有一个 issue 已经指出了这个问题<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>。</p>

<h1 id="解决方案">解决方案？</h1>

<p>对于普通开发者，临时的解决办法有两点：</p>

<ol>
  <li>避免 pass by value，可以使用 <code class="language-plaintext highlighter-rouge">Arc</code> 或者 reference</li>
  <li>减少使用 <code class="language-plaintext highlighter-rouge">async fn</code>。对于 tail calling，可以直接使用 <code class="language-plaintext highlighter-rouge">impl Future</code>，避免无意义的 <code class="language-plaintext highlighter-rouge">await</code>。对于状态不复杂的 <code class="language-plaintext highlighter-rouge">async fn</code>，也可以考虑手写 <code class="language-plaintext highlighter-rouge">Future::poll()</code>。</li>
</ol>

<blockquote>
  <p>cpp 提供了右值引用，这类层层传递的变量可以被自然地优化；而 rust 依靠编译器优化，就得依靠生成的代码能满足优化的前置条件。</p>
</blockquote>

<p>当然，community 也有人提供了改进方案<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>。该方案可以简述如下：即将 upvars 保存到 <code class="language-plaintext highlighter-rouge">GeneratorState</code> 的 <code class="language-plaintext highlighter-rouge">unresumed</code> state 中 （每个 <code class="language-plaintext highlighter-rouge">GenerateState</code> 至少有三种 state: <code class="language-plaintext highlighter-rouge">unresumed</code>, <code class="language-plaintext highlighter-rouge">finished</code>, <code class="language-plaintext highlighter-rouge">paniced</code>, 以及用户定义的 <code class="language-plaintext highlighter-rouge">suspent_x</code>)。</p>

<p>不过因为 rust 编译器架构改成了 demand-deriven compilation，该方案碰到了 query 循环依赖的问题，
需要等待其他人先将修复 dest prop <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>。</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>https://github.com/rust-lang/rust/issues/62958 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>https://github.com/rust-lang/rust/pull/89213 <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>https://github.com/rust-lang/rust/pull/96451 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><summary type="html"><![CDATA[背景 最近开始对 engula 进行性能测试，发现 async fn 的性能损耗非常大，这不符合 zero overhead abstraction，因此开始对 async fn 的性能做一些研究。 通过增加参数 -Z print-type-size，可以输出每种类型的大小。发现很多 generator 内存大小非常大，其中最不符合直觉的是下面这几个： print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:39:69: 44:6]&gt;`: 1248 bytes, alignment: 8 bytes print-type-size field `.0`: 1248 bytes print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:79:52: 83:6]&gt;`: 1408 bytes, alignment: 8 bytes print-type-size field `.0`: 1408 bytes print-type-size type: `std::future::from_generator::GenFuture&lt;[static generator@src/client/src/node_client.rs:88:51: 92:6]&gt;`: 1408 bytes, alignment: 8 bytes print-type-size field `.0`: 1408 bytes node_client.rs 是 tonic grpc client 的简单封装: use tonic::transport::Channel; #[derive(Debug, Clone)] pub struct Client { client: node_client::NodeClient&lt;Channel&gt;, } pub async fn root_heartbeat( &amp;self, req: HeartbeatRequest, ) -&gt; Result&lt;HeartbeatResponse, tonic::Status&gt; { let mut client = self.client.clone(); let res = client.root_heartbeat(req).await?; Ok(res.into_inner()) } node_client::NodeClient 是 tonic_build 生成的代码： impl&lt;T&gt; NodeClient&lt;T&gt; where T: tonic::client::GrpcService&lt;tonic::body::BoxBody&gt;, T::Error: Into&lt;StdError&gt;, T::ResponseBody: Body&lt;Data = Bytes&gt; + Send + 'static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;StdError&gt; + Send, { pub fn new(inner: T) -&gt; Self { let inner = tonic::client::Grpc::new(inner); Self { inner } } } pub async fn root_heartbeat( &amp;mut self, request: impl tonic::IntoRequest&lt;super::HeartbeatRequest&gt;, ) -&gt; Result&lt;tonic::Response&lt;super::HeartbeatResponse&gt;, tonic::Status&gt; { self.inner .ready() .await .map_err(|e| { tonic::Status::new( tonic::Code::Unknown, format!("Service was not ready: {}", e.into()), ) })?; let codec = tonic::codec::ProstCodec::default(); let path = http::uri::PathAndQuery::from_static( "/engula.server.v1.Node/RootHeartbeat", ); self.inner.unary(request.into_request(), path, codec).await } 也就是说，每次调用 Grpc::unary 需要在栈上开辟 1K+ 的空间。如果最后使用了 tokio::spawn，那么还需要将它复制到堆上。无论是内存分配还是复制上的开销，对于一个高性能存储服务都是不可接受的。并且随着 async fn 的调用层数增加，Future 大小还会呈现指数增长，这一点我后面会分析。 Grpc::unary 的 memory layout 是怎样的？ 那么，为何 Grpc::unary 返回的 Future 需要消耗 1K+ 的内存空间呢？ 在 tonic/src/client/grpc.rs 中，unary 最终被委托给 Grpc::streaming，后者调用 Channel::call 并返回 ResponseFuture。 /// Send a single unary gRPC request. pub async fn unary&lt;M1, M2, C&gt;( &amp;mut self, request: Request&lt;M1&gt;, path: PathAndQuery, codec: C, ) -&gt; Result&lt;Response&lt;M2&gt;, Status&gt; where T: GrpcService&lt;BoxBody&gt;, T::ResponseBody: Body + Send + 'static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;, C: Codec&lt;Encode = M1, Decode = M2&gt;, M1: Send + Sync + 'static, M2: Send + Sync + 'static, { let request = request.map(|m| stream::once(future::ready(m))); self.client_streaming(request, path, codec).await } /// Send a client side streaming gRPC request. pub async fn client_streaming&lt;S, M1, M2, C&gt;( &amp;mut self, request: Request&lt;S&gt;, path: PathAndQuery, codec: C, ) -&gt; Result&lt;Response&lt;M2&gt;, Status&gt; where T: GrpcService&lt;BoxBody&gt;, T::ResponseBody: Body + Send + 'static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;, S: Stream&lt;Item = M1&gt; + Send + 'static, C: Codec&lt;Encode = M1, Decode = M2&gt;, M1: Send + Sync + 'static, M2: Send + Sync + 'static, { let (mut parts, body, extensions) = self.streaming(request, path, codec).await?.into_parts(); futures_util::pin_mut!(body); let message = body .try_next() .await .map_err(|mut status| { status.metadata_mut().merge(parts.clone()); status })? .ok_or_else(|| Status::new(Code::Internal, "Missing response message."))?; if let Some(trailers) = body.trailers().await? { parts.merge(trailers); } Ok(Response::from_parts(parts, message, extensions)) } /// Send a bi-directional streaming gRPC request. pub async fn streaming&lt;S, M1, M2, C&gt;( &amp;mut self, request: Request&lt;S&gt;, path: PathAndQuery, mut codec: C, ) -&gt; Result&lt;Response&lt;Streaming&lt;M2&gt;&gt;, Status&gt; where T: GrpcService&lt;BoxBody&gt;, T::ResponseBody: Body + Send + 'static, &lt;T::ResponseBody as Body&gt;::Error: Into&lt;crate::Error&gt;, S: Stream&lt;Item = M1&gt; + Send + 'static, C: Codec&lt;Encode = M1, Decode = M2&gt;, M1: Send + Sync + 'static, M2: Send + Sync + 'static, { let mut parts = Parts::default(); parts.path_and_query = Some(path); let uri = Uri::from_parts(parts).expect("path_and_query only is valid Uri"); let request = request .map(|s| { encode_client( codec.encoder(), s, #[cfg(feature = "compression")] self.send_compression_encodings, ) }) .map(BoxBody::new); let mut request = request.into_http( uri, http::Method::POST, http::Version::HTTP_2, SanitizeHeaders::Yes, ); // Add the gRPC related HTTP headers request .headers_mut() .insert(TE, HeaderValue::from_static("trailers")); // Set the content type request .headers_mut() .insert(CONTENT_TYPE, HeaderValue::from_static("application/grpc")); #[cfg(feature = "compression")] { if let Some(encoding) = self.send_compression_encodings { request.headers_mut().insert( crate::codec::compression::ENCODING_HEADER, encoding.into_header_value(), ); } if let Some(header_value) = self .accept_compression_encodings .into_accept_encoding_header_value() { request.headers_mut().insert( crate::codec::compression::ACCEPT_ENCODING_HEADER, header_value, ); } } let response = self .inner .call(request) .await .map_err(|err| Status::from_error(err.into()))?; #[cfg(feature = "compression")] let encoding = CompressionEncoding::from_encoding_header( response.headers(), self.accept_compression_encodings, )?; let status_code = response.status(); let trailers_only_status = Status::from_header_map(response.headers()); // We do not need to check for trailers if the `grpc-status` header is present // with a valid code. let expect_additional_trailers = if let Some(status) = trailers_only_status { if status.code() != Code::Ok { return Err(status); } false } else { true }; let response = response.map(|body| { if expect_additional_trailers { Streaming::new_response( codec.decoder(), body, status_code, #[cfg(feature = "compression")] encoding, ) } else { Streaming::new_empty(codec.decoder(), body) } }); Ok(Response::from_http(response)) } 以前面的 root_heartbeat 为例，最终实例化的 streaming 的签名为： tonic::client::Grpc&lt;tonic::transport::Channel&gt;::streaming&lt; futures::stream::Once&lt; futures::future::Ready&lt; engula_api::server::v1::HeartbeatRequest&gt;&gt;, engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse, tonic::codec::ProstCodec&lt; engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt;&gt; 而 async fn streaming() 脱糖后，经过 transform 生成的状态机的内存布局为： generator layout ([static generator@tonic::client::Grpc&lt;tonic::transport::Channel&gt;::streaming&lt;futures::stream::Once&lt;futures::future::Ready&lt;engula_api::server::v1::HeartbeatRequest&gt;&gt;, engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse, tonic::codec::ProstCodec&lt;engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt;&gt;::{closure#0}]): Layout { size: Size(560 bytes), align: AbiAndPrefAlign { abi: Align(8 bytes), pref: Align(8 bytes), }, abi: Aggregate { sized: true, }, fields: Arbitrary { offsets: [ Size(0 bytes), Size(8 bytes), Size(152 bytes), Size(0 bytes), Size(552 bytes), ], } } 仔细分析 streaming 的代码可以发现，跨过 suspend point 的变量只有本地变量 request，预留空间 response: request: http::request::Request&lt;http_body::combinators::box_body::UnsyncBoxBody&lt;prost::bytes::Bytes, tonic::Status&gt;&gt; size = 240 bytes response: tonic::transport::channel::ResponseFuture size = 32 bytes 那么 request + response + tag （手写状态机的理论值）应该是远小于 560 bytes。到了 client_streaming 这里，内存空间就增长到了 1056 bytes。 async fn 的 layout 是如何计算的？ 这里进一步分析编译器内部是如何处理 async, await 和产生状态机的，看看不符合直觉的结果是如何产生的。 实际上 async fn 是 generator 的语法糖 async 和 await 都是语法糖，rust compiler 在 ast lowering 过程中进行了 desugar，并生成 hir。其中 async fn 会被替换为 generator (compiler/rustc_ast_lowering/src/item.rs)： fn lower_maybe_async_body( &amp;mut self, span: Span, decl: &amp;FnDecl, asyncness: Async, body: Option&lt;&amp;Block&gt;, ) -&gt; hir::BodyId { let closure_id = match asyncness { Async::Yes { closure_id, .. } =&gt; closure_id, Async::No =&gt; return self.lower_fn_body_block(span, decl, body), }; self.lower_body(|this| { let mut parameters: Vec&lt;hir::Param&lt;'_&gt;&gt; = Vec::new(); let mut statements: Vec&lt;hir::Stmt&lt;'_&gt;&gt; = Vec::new(); // Async function parameters are lowered into the closure body so that they are // captured and so that the drop order matches the equivalent non-async functions. // // from: // // async fn foo(&lt;pattern&gt;: &lt;ty&gt;, &lt;pattern&gt;: &lt;ty&gt;, &lt;pattern&gt;: &lt;ty&gt;) { // &lt;body&gt; // } // // into: // // fn foo(__arg0: &lt;ty&gt;, __arg1: &lt;ty&gt;, __arg2: &lt;ty&gt;) { // async move { // let __arg2 = __arg2; // let &lt;pattern&gt; = __arg2; // let __arg1 = __arg1; // let &lt;pattern&gt; = __arg1; // let __arg0 = __arg0; // let &lt;pattern&gt; = __arg0; // drop-temps { &lt;body&gt; } // see comments later in fn for details // } // } // // If `&lt;pattern&gt;` is a simple ident, then it is lowered to a single // `let &lt;pattern&gt; = &lt;pattern&gt;;` statement as an optimization. // // Note that the body is embedded in `drop-temps`; an // equivalent desugaring would be `return { &lt;body&gt; // };`. The key point is that we wish to drop all the // let-bound variables and temporaries created in the body // (and its tail expression!) before we drop the // parameters (c.f. rust-lang/rust#64512). for (index, parameter) in decl.inputs.iter().enumerate() { let parameter = this.lower_param(parameter); let span = parameter.pat.span; // Check if this is a binding pattern, if so, we can optimize and avoid adding a // `let &lt;pat&gt; = __argN;` statement. In this case, we do not rename the parameter. let (ident, is_simple_parameter) = match parameter.pat.kind { hir::PatKind::Binding( hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable, _, ident, _, ) =&gt; (ident, true), // For `ref mut` or wildcard arguments, we can't reuse the binding, but // we can keep the same name for the parameter. // This lets rustdoc render it correctly in documentation. hir::PatKind::Binding(_, _, ident, _) =&gt; (ident, false), hir::PatKind::Wild =&gt; { (Ident::with_dummy_span(rustc_span::symbol::kw::Underscore), false) } _ =&gt; { // Replace the ident for bindings that aren't simple. let name = format!("__arg{}", index); let ident = Ident::from_str(&amp;name); (ident, false) } }; let desugared_span = this.mark_span_with_reason(DesugaringKind::Async, span, None); // Construct a parameter representing `__argN: &lt;ty&gt;` to replace the parameter of the // async function. // // If this is the simple case, this parameter will end up being the same as the // original parameter, but with a different pattern id. let stmt_attrs = this.attrs.get(&amp;parameter.hir_id.local_id).copied(); let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident); let new_parameter = hir::Param { hir_id: parameter.hir_id, pat: new_parameter_pat, ty_span: this.lower_span(parameter.ty_span), span: this.lower_span(parameter.span), }; if is_simple_parameter { // If this is the simple case, then we only insert one statement that is // `let &lt;pat&gt; = &lt;pat&gt;;`. We re-use the original argument's pattern so that // `HirId`s are densely assigned. let expr = this.expr_ident(desugared_span, ident, new_parameter_id); let stmt = this.stmt_let_pat( stmt_attrs, desugared_span, Some(expr), parameter.pat, hir::LocalSource::AsyncFn, ); statements.push(stmt); } else { // If this is not the simple case, then we construct two statements: // // ``` // let __argN = __argN; // let &lt;pat&gt; = __argN; // ``` // // The first statement moves the parameter into the closure and thus ensures // that the drop order is correct. // // The second statement creates the bindings that the user wrote. // Construct the `let mut __argN = __argN;` statement. It must be a mut binding // because the user may have specified a `ref mut` binding in the next // statement. let (move_pat, move_id) = this.pat_ident_binding_mode( desugared_span, ident, hir::BindingAnnotation::Mutable, ); let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id); let move_stmt = this.stmt_let_pat( None, desugared_span, Some(move_expr), move_pat, hir::LocalSource::AsyncFn, ); // Construct the `let &lt;pat&gt; = __argN;` statement. We re-use the original // parameter's pattern so that `HirId`s are densely assigned. let pattern_expr = this.expr_ident(desugared_span, ident, move_id); let pattern_stmt = this.stmt_let_pat( stmt_attrs, desugared_span, Some(pattern_expr), parameter.pat, hir::LocalSource::AsyncFn, ); statements.push(move_stmt); statements.push(pattern_stmt); }; parameters.push(new_parameter); } let body_span = body.map_or(span, |b| b.span); let async_expr = this.make_async_expr( CaptureBy::Value, closure_id, None, body_span, hir::AsyncGeneratorKind::Fn, |this| { // Create a block from the user's function body: let user_body = this.lower_block_expr_opt(body_span, body); // Transform into `drop-temps { &lt;user-body&gt; }`, an expression: let desugared_span = this.mark_span_with_reason(DesugaringKind::Async, user_body.span, None); let user_body = this.expr_drop_temps( desugared_span, this.arena.alloc(user_body), AttrVec::new(), ); // As noted above, create the final block like // // ``` // { // let $param_pattern = $raw_param; // ... // drop-temps { &lt;user-body&gt; } // } // ``` let body = this.block_all( desugared_span, this.arena.alloc_from_iter(statements), Some(user_body), ); this.expr_block(body, AttrVec::new()) }, ); ( this.arena.alloc_from_iter(parameters), this.expr(body_span, async_expr, AttrVec::new()), ) }) } async fn 被替换为 generator 后，它的参数作为 captured variable 保存在 closure 中，后续称它为 upvars，在计算 Layout 是会使用到。 await 则会被替换为 poll()(compiler/rustc_ast_lowering/src/expr.rs): /// Desugar `&lt;expr&gt;.await` into: /// ```ignore (pseudo-rust) /// match ::std::future::IntoFuture::into_future(&lt;expr&gt;) { /// mut __awaitee =&gt; loop { /// match unsafe { ::std::future::Future::poll( /// &lt;::std::pin::Pin&gt;::new_unchecked(&amp;mut __awaitee), /// ::std::future::get_context(task_context), /// ) } { /// ::std::task::Poll::Ready(result) =&gt; break result, /// ::std::task::Poll::Pending =&gt; {} /// } /// task_context = yield (); /// } /// } /// ``` fn lower_expr_await(&amp;mut self, dot_await_span: Span, expr: &amp;Expr) -&gt; hir::ExprKind&lt;'hir&gt; { let full_span = expr.span.to(dot_await_span); match self.generator_kind { Some(hir::GeneratorKind::Async(_)) =&gt; {} Some(hir::GeneratorKind::Gen) | None =&gt; { self.tcx.sess.emit_err(AwaitOnlyInAsyncFnAndBlocks { dot_await_span, item_span: self.current_item, }); } } let span = self.mark_span_with_reason(DesugaringKind::Await, dot_await_span, None); let gen_future_span = self.mark_span_with_reason( DesugaringKind::Await, full_span, self.allow_gen_future.clone(), ); let expr = self.lower_expr_mut(expr); let expr_hir_id = expr.hir_id; // Note that the name of this binding must not be changed to something else because // debuggers and debugger extensions expect it to be called `__awaitee`. They use // this name to identify what is being awaited by a suspended async functions. let awaitee_ident = Ident::with_dummy_span(sym::__awaitee); let (awaitee_pat, awaitee_pat_hid) = self.pat_ident_binding_mode(span, awaitee_ident, hir::BindingAnnotation::Mutable); let task_context_ident = Ident::with_dummy_span(sym::_task_context); // unsafe { // ::std::future::Future::poll( // ::std::pin::Pin::new_unchecked(&amp;mut __awaitee), // ::std::future::get_context(task_context), // ) // } let poll_expr = { let awaitee = self.expr_ident(span, awaitee_ident, awaitee_pat_hid); let ref_mut_awaitee = self.expr_mut_addr_of(span, awaitee); let task_context = if let Some(task_context_hid) = self.task_context { self.expr_ident_mut(span, task_context_ident, task_context_hid) } else { // Use of `await` outside of an async context, we cannot use `task_context` here. self.expr_err(span) }; let new_unchecked = self.expr_call_lang_item_fn_mut( span, hir::LangItem::PinNewUnchecked, arena_vec![self; ref_mut_awaitee], Some(expr_hir_id), ); let get_context = self.expr_call_lang_item_fn_mut( gen_future_span, hir::LangItem::GetContext, arena_vec![self; task_context], Some(expr_hir_id), ); let call = self.expr_call_lang_item_fn( span, hir::LangItem::FuturePoll, arena_vec![self; new_unchecked, get_context], Some(expr_hir_id), ); self.arena.alloc(self.expr_unsafe(call)) }; // `::std::task::Poll::Ready(result) =&gt; break result` let loop_node_id = self.next_node_id(); let loop_hir_id = self.lower_node_id(loop_node_id); let ready_arm = { let x_ident = Ident::with_dummy_span(sym::result); let (x_pat, x_pat_hid) = self.pat_ident(gen_future_span, x_ident); let x_expr = self.expr_ident(gen_future_span, x_ident, x_pat_hid); let ready_field = self.single_pat_field(gen_future_span, x_pat); let ready_pat = self.pat_lang_item_variant( span, hir::LangItem::PollReady, ready_field, Some(expr_hir_id), ); let break_x = self.with_loop_scope(loop_node_id, move |this| { let expr_break = hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr)); this.arena.alloc(this.expr(gen_future_span, expr_break, AttrVec::new())) }); self.arm(ready_pat, break_x) }; // `::std::task::Poll::Pending =&gt; {}` let pending_arm = { let pending_pat = self.pat_lang_item_variant( span, hir::LangItem::PollPending, &amp;[], Some(expr_hir_id), ); let empty_block = self.expr_block_empty(span); self.arm(pending_pat, empty_block) }; let inner_match_stmt = { let match_expr = self.expr_match( span, poll_expr, arena_vec![self; ready_arm, pending_arm], hir::MatchSource::AwaitDesugar, ); self.stmt_expr(span, match_expr) }; // task_context = yield (); let yield_stmt = { let unit = self.expr_unit(span); let yield_expr = self.expr( span, hir::ExprKind::Yield(unit, hir::YieldSource::Await { expr: Some(expr_hir_id) }), AttrVec::new(), ); let yield_expr = self.arena.alloc(yield_expr); if let Some(task_context_hid) = self.task_context { let lhs = self.expr_ident(span, task_context_ident, task_context_hid); let assign = self.expr( span, hir::ExprKind::Assign(lhs, yield_expr, self.lower_span(span)), AttrVec::new(), ); self.stmt_expr(span, assign) } else { // Use of `await` outside of an async context. Return `yield_expr` so that we can // proceed with type checking. self.stmt(span, hir::StmtKind::Semi(yield_expr)) } }; let loop_block = self.block_all(span, arena_vec![self; inner_match_stmt, yield_stmt], None); // loop { .. } let loop_expr = self.arena.alloc(hir::Expr { hir_id: loop_hir_id, kind: hir::ExprKind::Loop( loop_block, None, hir::LoopSource::Loop, self.lower_span(span), ), span: self.lower_span(span), }); // mut __awaitee =&gt; loop { ... } let awaitee_arm = self.arm(awaitee_pat, loop_expr); // `match ::std::future::IntoFuture::into_future(&lt;expr&gt;) { ... }` let into_future_span = self.mark_span_with_reason( DesugaringKind::Await, dot_await_span, self.allow_into_future.clone(), ); let into_future_expr = self.expr_call_lang_item_fn( into_future_span, hir::LangItem::IntoFutureIntoFuture, arena_vec![self; expr], Some(expr_hir_id), ); // match &lt;into_future_expr&gt; { // mut __awaitee =&gt; loop { .. } // } hir::ExprKind::Match( into_future_expr, arena_vec![self; awaitee_arm], hir::MatchSource::AwaitDesugar, ) } generator 会被替换为 GeneratorState 此后 hir 会转换为 mir，generator 在 mir_transform 中被替换为 GeneratorState(compiler/rustc_mir_transform/src/generator.rs): impl&lt;'tcx&gt; MirPass&lt;'tcx&gt; for StateTransform { fn run_pass(&amp;self, tcx: TyCtxt&lt;'tcx&gt;, body: &amp;mut Body&lt;'tcx&gt;) { let Some(yield_ty) = body.yield_ty() else { // This only applies to generators return; }; assert!(body.generator_drop().is_none()); dump_mir(tcx, None, "generator_before", &amp;0, body, |_, _| Ok(())); // The first argument is the generator type passed by value let gen_ty = body.local_decls.raw[1].ty; // Get the interior types and substs which typeck computed let (upvars, interior, discr_ty, movable) = match *gen_ty.kind() { ty::Generator(_, substs, movability) =&gt; { let substs = substs.as_generator(); ( substs.upvar_tys().collect(), substs.witness(), substs.discr_ty(tcx), movability == hir::Movability::Movable, ) } _ =&gt; { tcx.sess .delay_span_bug(body.span, &amp;format!("unexpected generator type {}", gen_ty)); return; } }; // Compute GeneratorState&lt;yield_ty, return_ty&gt; let state_did = tcx.require_lang_item(LangItem::GeneratorState, None); let state_adt_ref = tcx.adt_def(state_did); let state_substs = tcx.intern_substs(&amp;[yield_ty.into(), body.return_ty().into()]); let ret_ty = tcx.mk_adt(state_adt_ref, state_substs); // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local // RETURN_PLACE then is a fresh unused local with type ret_ty. let new_ret_local = replace_local(RETURN_PLACE, ret_ty, body, tcx); // We also replace the resume argument and insert an `Assign`. // This is needed because the resume argument `_2` might be live across a `yield`, in which // case there is no `Assign` to it that the transform can turn into a store to the generator // state. After the yield the slot in the generator state would then be uninitialized. let resume_local = Local::new(2); let new_resume_local = replace_local(resume_local, body.local_decls[resume_local].ty, body, tcx); // When first entering the generator, move the resume argument into its new local. let source_info = SourceInfo::outermost(body.span); let stmts = &amp;mut body.basic_blocks_mut()[BasicBlock::new(0)].statements; stmts.insert( 0, Statement { source_info, kind: StatementKind::Assign(Box::new(( new_resume_local.into(), Rvalue::Use(Operand::Move(resume_local.into())), ))), }, ); let always_live_locals = always_storage_live_locals(&amp;body); let liveness_info = locals_live_across_suspend_points(tcx, body, &amp;always_live_locals, movable); sanitize_witness(tcx, body, interior, upvars, &amp;liveness_info.saved_locals); if tcx.sess.opts.unstable_opts.validate_mir { let mut vis = EnsureGeneratorFieldAssignmentsNeverAlias { assigned_local: None, saved_locals: &amp;liveness_info.saved_locals, storage_conflicts: &amp;liveness_info.storage_conflicts, }; vis.visit_body(body); } // Extract locals which are live across suspension point into `layout` // `remap` gives a mapping from local indices onto generator struct indices // `storage_liveness` tells us which locals have live storage at suspension points let (remap, layout, storage_liveness) = compute_layout(liveness_info, body); let can_return = can_return(tcx, body, tcx.param_env(body.source.def_id())); // Run the transformation which converts Places from Local to generator struct // accesses for locals in `remap`. // It also rewrites `return x` and `yield y` as writing a new generator state and returning // GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively. let mut transform = TransformVisitor { tcx, state_adt_ref, state_substs, remap, storage_liveness, always_live_locals, suspension_points: Vec::new(), new_ret_local, discr_ty, }; transform.visit_body(body); // Update our MIR struct to reflect the changes we've made body.arg_count = 2; // self, resume arg body.spread_arg = None; body.generator.as_mut().unwrap().yield_ty = None; body.generator.as_mut().unwrap().generator_layout = Some(layout); // Insert `drop(generator_struct)` which is used to drop upvars for generators in // the unresumed state. // This is expanded to a drop ladder in `elaborate_generator_drops`. let drop_clean = insert_clean_drop(body); dump_mir(tcx, None, "generator_pre-elab", &amp;0, body, |_, _| Ok(())); // Expand `drop(generator_struct)` to a drop ladder which destroys upvars. // If any upvars are moved out of, drop elaboration will handle upvar destruction. // However we need to also elaborate the code generated by `insert_clean_drop`. elaborate_generator_drops(tcx, body); dump_mir(tcx, None, "generator_post-transform", &amp;0, body, |_, _| Ok(())); // Create a copy of our MIR and use it to create the drop shim for the generator let drop_shim = create_generator_drop_shim(tcx, &amp;transform, gen_ty, body, drop_clean); body.generator.as_mut().unwrap().generator_drop = Some(drop_shim); // Create the Generator::resume function create_generator_resume_function(tcx, transform, body, can_return); // Run derefer to fix Derefs that are not in the first place deref_finder(tcx, body); } } 第 85 行 compute_layout 计算出 GeneratorLayout，并在 111 行保存到 body.generator 中。这里的 GeneratorLayout 就是 GeneratorState 的内存空间，它分成两部分：prefix + variants。prefix 保存了会跨越 suspend point 的变量，variants 是不同的 state，其中保存了只会在当前 state 使用到的变量。 GeneratorState 的内存布局是如何计算的？ 编译器在代码生成阶段会根据前面计算得到的 GeneratorLayout 算出最终的内存布局 Layout(compiler/rustc_middle/src/ty/layout.rs): /// Compute the full generator layout. fn generator_layout( &amp;self, ty: Ty&lt;'tcx&gt;, def_id: hir::def_id::DefId, substs: SubstsRef&lt;'tcx&gt;, ) -&gt; Result&lt;Layout&lt;'tcx&gt;, LayoutError&lt;'tcx&gt;&gt; { use SavedLocalEligibility::*; let tcx = self.tcx; let subst_field = |ty: Ty&lt;'tcx&gt;| EarlyBinder(ty).subst(tcx, substs); let Some(info) = tcx.generator_layout(def_id) else { return Err(LayoutError::Unknown(ty)); }; let (ineligible_locals, assignments) = self.generator_saved_local_eligibility(&amp;info); // Build a prefix layout, including "promoting" all ineligible // locals as part of the prefix. We compute the layout of all of // these fields at once to get optimal packing. let tag_index = substs.as_generator().prefix_tys().count(); // `info.variant_fields` already accounts for the reserved variants, so no need to add them. let max_discr = (info.variant_fields.len() - 1) as u128; let discr_int = Integer::fit_unsigned(max_discr); let discr_int_ty = discr_int.to_ty(tcx, false); let tag = Scalar::Initialized { value: Primitive::Int(discr_int, false), valid_range: WrappingRange { start: 0, end: max_discr }, }; let tag_layout = self.tcx.intern_layout(LayoutS::scalar(self, tag)); let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout }; let promoted_layouts = ineligible_locals .iter() .map(|local| subst_field(info.field_tys[local])) .map(|ty| tcx.mk_maybe_uninit(ty)) .map(|ty| self.layout_of(ty)); let prefix_layouts = substs .as_generator() .prefix_tys() .map(|ty| self.layout_of(ty)) .chain(iter::once(Ok(tag_layout))) .chain(promoted_layouts) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?; let prefix = self.univariant_uninterned( ty, &amp;prefix_layouts, &amp;ReprOptions::default(), StructKind::AlwaysSized, )?; let (prefix_size, prefix_align) = (prefix.size, prefix.align); // Split the prefix layout into the "outer" fields (upvars and // discriminant) and the "promoted" fields. Promoted fields will // get included in each variant that requested them in // GeneratorLayout. debug!("prefix = {:#?}", prefix); let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields { FieldsShape::Arbitrary { mut offsets, memory_index } =&gt; { let mut inverse_memory_index = invert_mapping(&amp;memory_index); // "a" (`0..b_start`) and "b" (`b_start..`) correspond to // "outer" and "promoted" fields respectively. let b_start = (tag_index + 1) as u32; let offsets_b = offsets.split_off(b_start as usize); let offsets_a = offsets; // Disentangle the "a" and "b" components of `inverse_memory_index` // by preserving the order but keeping only one disjoint "half" each. // FIXME(eddyb) build a better abstraction for permutations, if possible. let inverse_memory_index_b: Vec&lt;_&gt; = inverse_memory_index.iter().filter_map(|&amp;i| i.checked_sub(b_start)).collect(); inverse_memory_index.retain(|&amp;i| i &lt; b_start); let inverse_memory_index_a = inverse_memory_index; // Since `inverse_memory_index_{a,b}` each only refer to their // respective fields, they can be safely inverted let memory_index_a = invert_mapping(&amp;inverse_memory_index_a); let memory_index_b = invert_mapping(&amp;inverse_memory_index_b); let outer_fields = FieldsShape::Arbitrary { offsets: offsets_a, memory_index: memory_index_a }; (outer_fields, offsets_b, memory_index_b) } _ =&gt; bug!(), }; let mut size = prefix.size; let mut align = prefix.align; let variants = info .variant_fields .iter_enumerated() .map(|(index, variant_fields)| { // Only include overlap-eligible fields when we compute our variant layout. let variant_only_tys = variant_fields .iter() .filter(|local| match assignments[**local] { Unassigned =&gt; bug!(), Assigned(v) if v == index =&gt; true, Assigned(_) =&gt; bug!("assignment does not match variant"), Ineligible(_) =&gt; false, }) .map(|local| subst_field(info.field_tys[*local])); let mut variant = self.univariant_uninterned( ty, &amp;variant_only_tys .map(|ty| self.layout_of(ty)) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?, &amp;ReprOptions::default(), StructKind::Prefixed(prefix_size, prefix_align.abi), )?; variant.variants = Variants::Single { index }; let FieldsShape::Arbitrary { offsets, memory_index } = variant.fields else { bug!(); }; // Now, stitch the promoted and variant-only fields back together in // the order they are mentioned by our GeneratorLayout. // Because we only use some subset (that can differ between variants) // of the promoted fields, we can't just pick those elements of the // `promoted_memory_index` (as we'd end up with gaps). // So instead, we build an "inverse memory_index", as if all of the // promoted fields were being used, but leave the elements not in the // subset as `INVALID_FIELD_IDX`, which we can filter out later to // obtain a valid (bijective) mapping. const INVALID_FIELD_IDX: u32 = !0; let mut combined_inverse_memory_index = vec![INVALID_FIELD_IDX; promoted_memory_index.len() + memory_index.len()]; let mut offsets_and_memory_index = iter::zip(offsets, memory_index); let combined_offsets = variant_fields .iter() .enumerate() .map(|(i, local)| { let (offset, memory_index) = match assignments[*local] { Unassigned =&gt; bug!(), Assigned(_) =&gt; { let (offset, memory_index) = offsets_and_memory_index.next().unwrap(); (offset, promoted_memory_index.len() as u32 + memory_index) } Ineligible(field_idx) =&gt; { let field_idx = field_idx.unwrap() as usize; (promoted_offsets[field_idx], promoted_memory_index[field_idx]) } }; combined_inverse_memory_index[memory_index as usize] = i as u32; offset }) .collect(); // Remove the unused slots and invert the mapping to obtain the // combined `memory_index` (also see previous comment). combined_inverse_memory_index.retain(|&amp;i| i != INVALID_FIELD_IDX); let combined_memory_index = invert_mapping(&amp;combined_inverse_memory_index); variant.fields = FieldsShape::Arbitrary { offsets: combined_offsets, memory_index: combined_memory_index, }; size = size.max(variant.size); align = align.max(variant.align); Ok(tcx.intern_layout(variant)) }) .collect::&lt;Result&lt;IndexVec&lt;VariantIdx, _&gt;, _&gt;&gt;()?; size = size.align_to(align.abi); let abi = if prefix.abi.is_uninhabited() || variants.iter().all(|v| v.abi().is_uninhabited()) { Abi::Uninhabited } else { Abi::Aggregate { sized: true } }; let layout = tcx.intern_layout(LayoutS { variants: Variants::Multiple { tag, tag_encoding: TagEncoding::Direct, tag_field: tag_index, variants, }, fields: outer_fields, abi, largest_niche: prefix.largest_niche, size, align, }); debug!("generator layout ({:?}): {:#?}", ty, layout); Ok(layout) } LayoutS 的定义为： #[derive(PartialEq, Eq, Hash, HashStable_Generic)] pub struct LayoutS&lt;'a&gt; { /// Says where the fields are located within the layout. pub fields: FieldsShape, /// Encodes information about multi-variant layouts. /// Even with `Multiple` variants, a layout still has its own fields! Those are then /// shared between all variants. One of them will be the discriminant, /// but e.g. generators can have more. /// /// To access all fields of this layout, both `fields` and the fields of the active variant /// must be taken into account. pub variants: Variants&lt;'a&gt;, /// The `abi` defines how this data is passed between functions, and it defines /// value restrictions via `valid_range`. /// /// Note that this is entirely orthogonal to the recursive structure defined by /// `variants` and `fields`; for example, `ManuallyDrop&lt;Result&lt;isize, isize&gt;&gt;` has /// `Abi::ScalarPair`! So, even with non-`Aggregate` `abi`, `fields` and `variants` /// have to be taken into account to find all fields of this layout. pub abi: Abi, /// The leaf scalar with the largest number of invalid values /// (i.e. outside of its `valid_range`), if it exists. pub largest_niche: Option&lt;Niche&gt;, pub align: AbiAndPrefAlign, pub size: Size, } 根据定义，fields + variants 组成了 GeneratorState 的内存布局： To access all fields of this layout, both `fields` and the fields of the active variant must be taken into account. 在 generator_layout 函数中，fields 是 outer_fields，variants 是 Variant::Multiple 的实例，其中保存了 variants 和一个 tag_field。outer_fields 和 variants 均由 prefix 计算得到： // Split the prefix layout into the "outer" fields (upvars and // discriminant) and the "promoted" fields. Promoted fields will // get included in each variant that requested them in // GeneratorLayout prefix 的计算方式为： let tag_layout = self.tcx.intern_layout(LayoutS::scalar(self, tag)); let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout }; let promoted_layouts = ineligible_locals .iter() .map(|local| subst_field(info.field_tys[local])) .map(|ty| tcx.mk_maybe_uninit(ty)) .map(|ty| self.layout_of(ty)); let prefix_layouts = substs .as_generator() .prefix_tys() .map(|ty| self.layout_of(ty)) .chain(iter::once(Ok(tag_layout))) .chain(promoted_layouts) .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?; let prefix = self.univariant_uninterned( ty, &amp;prefix_layouts, &amp;ReprOptions::default(), StructKind::AlwaysSized, )?; 其中 prefix_tys() 返回的就是前面提到的 upvars： /// This is the types of the fields of a generator which are not stored in a /// variant. #[inline] pub fn prefix_tys(self) -&gt; impl Iterator&lt;Item = Ty&lt;'tcx&gt;&gt; { self.upvar_tys() } 因此，一个 GeneratorState 的 Layout 中会包含一个 tag，upvars，以及由不同 state 组成的 variants。回到 root_heartbeat 的例子，streaming() 中，除了 request 和 response 外，还会保存下参数中的 request: Request&lt;S&gt;，path 和 codec。 codec: tonic::codec::ProstCodec&lt;engula_api::server::v1::HeartbeatRequest, engula_api::server::v1::HeartbeatResponse&gt; size 0 bytes request: tonic::Request&lt;futures::stream::Once&lt;futures::future::Ready&lt;engula_api::server::v1::HeartbeatRequest&gt;&gt;&gt; size 144 bytes path: http::uri::path::PathAndQuery size 40 bytes tag: u8 最终的大小为：self(8 bytes) + request(144 bytes) + path(40 bytes) + uri(88 bytes) + request(240 bytes, http request) + response(32 bytes) + tag(1 byte, aligned to 8) = 560 此处 uri 是前面计算漏掉的变量。 由于 async fn 的参数作为 captured variable，会放置在 outer_fields 中。如果一个非常大的参数层层传递到内部的某个 async fn，会被一层层放大，最终导致 Future 大小呈现指数增长。 19 年有一个 issue 已经指出了这个问题1。 解决方案？ 对于普通开发者，临时的解决办法有两点： 避免 pass by value，可以使用 Arc 或者 reference 减少使用 async fn。对于 tail calling，可以直接使用 impl Future，避免无意义的 await。对于状态不复杂的 async fn，也可以考虑手写 Future::poll()。 cpp 提供了右值引用，这类层层传递的变量可以被自然地优化；而 rust 依靠编译器优化，就得依靠生成的代码能满足优化的前置条件。 当然，community 也有人提供了改进方案2。该方案可以简述如下：即将 upvars 保存到 GeneratorState 的 unresumed state 中 （每个 GenerateState 至少有三种 state: unresumed, finished, paniced, 以及用户定义的 suspent_x)。 不过因为 rust 编译器架构改成了 demand-deriven compilation，该方案碰到了 query 循环依赖的问题， 需要等待其他人先将修复 dest prop 3。 https://github.com/rust-lang/rust/issues/62958 &#8617; https://github.com/rust-lang/rust/pull/89213 &#8617; https://github.com/rust-lang/rust/pull/96451 &#8617;]]></summary></entry><entry><title type="html">CockroachDB KV Source Code Reading Notes</title><link href="/2022/05/24/CockroachDB-Source-Code.html" rel="alternate" type="text/html" title="CockroachDB KV Source Code Reading Notes" /><published>2022-05-24T00:00:00+08:00</published><updated>2022-05-24T00:00:00+08:00</updated><id>/2022/05/24/CockroachDB-Source-Code</id><content type="html" xml:base="/2022/05/24/CockroachDB-Source-Code.html"><![CDATA[<h1 id="cockroachdb-kv">CockroachDB KV</h1>

<h2 id="entrance">Entrance</h2>

<p>In <code class="language-plaintext highlighter-rouge">pkg/cmd/cockroach.go</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cli</span><span class="o">.</span><span class="n">Main</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">pkg/cli/cli.go</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cockroachCmd</span><span class="o">.</span><span class="n">AddCommand</span><span class="p">(</span>
    <span class="n">startCmd</span><span class="p">,</span>
    <span class="n">initCmd</span><span class="p">,</span>
<span class="p">)</span>
</code></pre></div></div>

<p>According <a href="http://doc.cockroachchina.baidu.com/#deploy/manual-deployment/on-premises/#step-3">cockroach db manual</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cockroach start --join xxx
cockroach init --host &lt;address of any node&gt;
</code></pre></div></div>

<p>So the setup logic lie in <code class="language-plaintext highlighter-rouge">startCmd</code>, and cluster bootstrap login lie in <code class="language-plaintext highlighter-rouge">initCmd</code>.</p>

<p>In <code class="language-plaintext highlighter-rouge">pkg/cli/start.go</code>, command <code class="language-plaintext highlighter-rouge">startCmd</code> will invoke <code class="language-plaintext highlighter-rouge">runStartJoin</code> -&gt; <code class="language-plaintext highlighter-rouge">runStart</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func runStart() {
    var s *server.Server
    s, err = server.NewServer()
    s.PreStart()
    s.InitialStart()
    s.AcceptClients()
}
</code></pre></div></div>

<h2 id="start-node">Start Node</h2>

<p>In <code class="language-plaintext highlighter-rouge">Server::NewServer</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clock</span> <span class="o">=</span> <span class="n">hlc</span><span class="o">.</span><span class="n">NewClock</span><span class="p">()</span>
<span class="n">engines</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">CreateEngines</span><span class="p">()</span>
    <span class="n">eng</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">NewPebble</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">pebbleConfig</span><span class="p">)</span>
<span class="n">rpcContext</span> <span class="o">=</span> <span class="n">rpc</span><span class="o">.</span><span class="n">NewContext</span><span class="p">()</span>
<span class="n">grpcServer</span> <span class="o">=</span> <span class="n">newGRPCServer</span><span class="p">(</span><span class="n">rpcContext</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">gossip</span><span class="o">.</span><span class="n">New</span><span class="p">()</span>
<span class="n">distSender</span> <span class="o">=</span> <span class="n">kvcoord</span><span class="o">.</span><span class="n">NewDistSender</span><span class="p">()</span>  <span class="c">// `pkg/kv/kvclient/kvcoord/dist_sender.go`</span>
<span class="n">tcsFactory</span> <span class="o">=</span> <span class="n">kvcoord</span><span class="o">.</span><span class="n">NewTxnCoordSenderFactory</span><span class="p">(</span><span class="n">txnCoordSenderFactoryCfg</span><span class="p">,</span> <span class="n">distSender</span><span class="p">)</span>  <span class="c">// `pkg/kv/kvclient/kvcoord/txn_coord_sender_factory.go`</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">kv</span><span class="o">.</span><span class="n">NewDBWithContext</span><span class="p">(</span><span class="n">clock</span><span class="p">,</span> <span class="n">dbCtx</span><span class="p">)</span>
<span class="n">raftTransport</span> <span class="o">=</span> <span class="n">kvserver</span><span class="o">.</span><span class="n">NewRaftTransport</span><span class="p">()</span>
<span class="n">stores</span> <span class="o">=</span> <span class="n">kvserver</span><span class="o">.</span><span class="n">NewStores</span><span class="p">()</span>
<span class="n">tsDB</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">NewDB</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">tcsFactory</span><span class="p">)</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">NewNode</span><span class="p">()</span>
<span class="n">roachpb</span><span class="o">.</span><span class="n">RegisterInternalServer</span><span class="p">(</span><span class="n">grpcServer</span><span class="o">.</span><span class="n">Server</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
<span class="n">kvserver</span><span class="o">.</span><span class="n">RegisterPerReplicaServer</span><span class="p">(</span><span class="n">grpcServer</span><span class="o">.</span><span class="n">Server</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">perReplicaServer</span><span class="p">)</span>
<span class="n">kvserver</span><span class="o">.</span><span class="n">RegisterPerStoreServer</span><span class="p">(</span><span class="n">grpcServer</span><span class="o">.</span><span class="n">Server</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">perReplicaServer</span><span class="p">)</span>
<span class="n">ctpb</span><span class="o">.</span><span class="n">RegisterSideTransportServer</span><span class="p">(</span><span class="n">grpcServer</span><span class="o">.</span><span class="n">Server</span><span class="p">,</span> <span class="n">ctReceiver</span><span class="p">)</span>
<span class="n">sqlServer</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">newSQLServer</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">sqlServerArgs</span><span class="p">)</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">Server::PreStart</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span><span class="o">.</span><span class="n">rpcContext</span><span class="o">.</span><span class="n">SetLocalInternalServer</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">http</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">externalStorageBuilder</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">inspectEngineState</span> <span class="o">=</span> <span class="n">inspectEngines</span><span class="p">()</span>   <span class="c">// go through engines and constructs an initState. In `pkg/server/init.go`</span>
    <span class="n">storeIdent</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">kvserver</span><span class="o">.</span><span class="n">ReadStoreIdent</span><span class="p">()</span>
<span class="n">serverpb</span><span class="o">.</span><span class="n">RegisterInitServer</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">grpc</span><span class="o">.</span><span class="n">Server</span><span class="p">,</span> <span class="n">initServer</span><span class="p">)</span>  <span class="c">// support `service Init` in `pkg/server/serverpb/init.proto`.</span>
<span class="n">startListenRPCAndSQL</span><span class="p">()</span> <span class="c">// only start rpc server, but initialize sql server.</span>
<span class="n">configureGRPCGateway</span><span class="p">()</span>
<span class="n">startRPCServer</span><span class="p">()</span>
<span class="n">onInitServerReady</span><span class="p">()</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">initServer</span><span class="o">.</span><span class="n">ServeAndWait</span><span class="p">()</span>
    <span class="c">// bootstrapAddresses := cfg.FilterGossipBootstrapAddress() in `newInitServerConfig`. from func (cfg *Config) parseGossipBootstrapAddresses</span>
    <span class="n">s</span><span class="o">.</span><span class="n">startJoinLoop</span><span class="p">()</span> <span class="c">// continuously retries connecting to nodes specified in the join list, in order to determine what the cluster ID, node ID is.</span>
        <span class="n">s</span><span class="o">.</span><span class="n">attemptJoinIn</span><span class="p">()</span>
            <span class="n">send</span> <span class="n">JoinNodeRequest</span>
        <span class="n">s</span><span class="o">.</span><span class="n">initializeFirstStoreAfterJoin</span><span class="p">()</span>
            <span class="n">kvserver</span><span class="o">.</span><span class="n">InitEngines</span><span class="p">()</span>
    <span class="n">state</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="n">s</span><span class="o">.</span><span class="n">joinCh</span>
<span class="n">s</span><span class="o">.</span><span class="n">rpcContext</span><span class="o">.</span><span class="n">NodeID</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">NodeID</span><span class="p">)</span>
<span class="n">runAsyncTask</span><span class="p">(</span><span class="s">"connect-gossip"</span><span class="p">)</span>  <span class="c">// only log</span>
<span class="n">s</span><span class="o">.</span><span class="n">gossip</span><span class="o">.</span><span class="n">Start</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">setAddresses</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">manage</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>  <span class="c">// In `pkg/server/node.go`</span>
<span class="n">s</span><span class="o">.</span><span class="n">replicationReporter</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">sqlServer</span><span class="o">.</span><span class="n">preStart</span><span class="p">()</span>
</code></pre></div></div>

<p>There are some comments in <code class="language-plaintext highlighter-rouge">PreStart</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// "bootstrapping problem": nodes need to connect to Gossip fairly</span>
<span class="c">// early, but what drives Gossip connectivity are the first range</span>
<span class="c">// replicas in the kv store. This in turn suggests opening the Gossip</span>
<span class="c">// server early. However, naively doing so also serves most other</span>
<span class="c">// services prematurely, which exposes a large surface of potentially</span>
<span class="c">// underinitialized services. This is avoided with some additional</span>
<span class="c">// complexity that can be summarized as follows:</span>
<span class="c">//</span>
<span class="c">// - before blocking trying to connect to the Gossip network, we already open</span>
<span class="c">//   the admin UI (so that its diagnostics are available)</span>
<span class="c">// - we also allow our Gossip and our connection health Ping service</span>
<span class="c">// - everything else returns Unavailable errors (which are retryable)</span>
<span class="c">// - once the node has started, unlock all RPCs.</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">Node::start</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span><span class="o">.</span><span class="n">storeCfg</span><span class="o">.</span><span class="n">Gossip</span><span class="o">.</span><span class="n">NodeID</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">nodeDescriptor</span><span class="o">.</span><span class="n">NodeID</span><span class="p">)</span>
<span class="n">n</span><span class="o">.</span><span class="n">storeCfg</span><span class="o">.</span><span class="n">Gossip</span><span class="o">.</span><span class="n">SetNodeDescriptor</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">nodeDescriptor</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">state</span><span class="o">.</span><span class="n">initializedEngines</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="n">kvserver</span><span class="o">.</span><span class="n">NewStore</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>  <span class="c">// In `pkg/kv/kvserver/store.go`</span>
    <span class="n">s</span><span class="o">.</span><span class="n">Start</span><span class="p">()</span>
        <span class="c">// Iterate over all range descriptor, ignoring uncommitted version.</span>
        <span class="n">IterateRangeDescriptorFromDisk</span><span class="p">()</span>
            <span class="n">replica</span> <span class="o">=</span> <span class="n">newReplica</span><span class="p">()</span>  <span class="c">// In `pkg/kv/kvserver/replica_init.go`</span>
                <span class="n">newUnloadReplica</span><span class="p">()</span>
                <span class="n">loadRaftMuLockedReplicaMuLocked</span><span class="p">()</span>
                    <span class="n">lastIndex</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">stateLoader</span><span class="o">.</span><span class="n">LoadLastIndex</span><span class="p">()</span>
            <span class="n">s</span><span class="o">.</span><span class="n">addReplicaInternal</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">Transport</span><span class="o">.</span><span class="n">Listen</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">StoreID</span><span class="p">(),</span> <span class="n">s</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">processRaft</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">storeRebalancer</span><span class="o">.</span><span class="n">Start</span><span class="p">()</span> <span class="c">// rebalance is finished in store?</span>
        <span class="n">s</span><span class="o">.</span><span class="n">startGossip</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">startLeaseRenewer</span><span class="p">()</span>

    <span class="n">n</span><span class="o">.</span><span class="n">addStore</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">n</span><span class="o">.</span><span class="n">storeCfg</span><span class="o">.</span><span class="n">Gossip</span><span class="o">.</span><span class="n">SetStorage</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">stores</span><span class="p">)</span>
<span class="n">n</span><span class="o">.</span><span class="n">startGossiping</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">stopper</span><span class="p">)</span>  <span class="c">// loops on a periodic ticker to gossip node-related information.</span>
    <span class="n">s</span><span class="o">.</span><span class="n">GossipStore</span><span class="p">()</span> <span class="c">// GossipStore broadcasts the store on the gossip network.</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">Server::AcceptClients</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span><span class="o">.</span><span class="n">sqlServer</span><span class="o">.</span><span class="n">startServerSQL</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="start-store">Start Store</h3>

<p>In <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/store.go</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Store::Start
    ReadStoreIdent
    idalloc.NewAllocator
    intentResolver.New
    makeRaftLogTruncator
    txnrecovery.NewManager
    // Iterate over all range descriptor, ignoring uncommitted version.
    IterateRangeDescriptorFromDisk()
        replica = newReplica()  // In `pkg/kv/kvserver/replica_init.go`
            newUnloadReplica()
            loadRaftMuLockedReplicaMuLocked()
                lastIndex = r.stateLoader.LoadLastIndex()
        s.addReplicaInternal(replica)
    s.cfg.Transport.Listen(s.StoreID(), s)
	s.cfg.NodeLiveness.RegisterCallback(s.nodeIsLiveCallback)
    s.processRaft()
    s.storeRebalancer.Start() // rebalance is finished in store?
    s.startGossip()
    s.startLeaseRenewer()
    s.startRangefeedUpdator()
    NewStoreRebalancer()
</code></pre></div></div>

<h4 id="id-allocator">ID Allocator</h4>

<p>In <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/store.go</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Create ID allocators.</span>
<span class="n">idAlloc</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">idalloc</span><span class="o">.</span><span class="n">NewAllocator</span><span class="p">(</span><span class="n">idalloc</span><span class="o">.</span><span class="n">Options</span><span class="p">{</span>
    <span class="n">AmbientCtx</span><span class="o">:</span>  <span class="n">s</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">AmbientCtx</span><span class="p">,</span>
    <span class="n">Key</span><span class="o">:</span>         <span class="n">keys</span><span class="o">.</span><span class="n">RangeIDGenerator</span><span class="p">,</span>
    <span class="n">Incrementer</span><span class="o">:</span> <span class="n">idalloc</span><span class="o">.</span><span class="n">DBIncrementer</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">db</span><span class="p">),</span>
    <span class="n">BlockSize</span><span class="o">:</span>   <span class="n">rangeIDAllocCount</span><span class="p">,</span>
    <span class="n">Stopper</span><span class="o">:</span>     <span class="n">s</span><span class="o">.</span><span class="n">stopper</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Allocator</code> will allocate <code class="language-plaintext highlighter-rouge">rangeIDAllocCount</code> count from <code class="language-plaintext highlighter-rouge">DB</code> with key <code class="language-plaintext highlighter-rouge">keys.RangeIDGenerator</code>.</p>

<h2 id="bootstrap">Bootstrap</h2>

<p>In <code class="language-plaintext highlighter-rouge">pkg/cli/init.go</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">runInit</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">NewInitClient</span><span class="p">()</span>
    <span class="n">c</span><span class="o">.</span><span class="n">Bootstrap</span><span class="p">(</span><span class="n">BootstrapRequest</span> <span class="p">{})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">pkg/server/init.go</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">initServer</span><span class="p">)</span> <span class="n">Bootstrap</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">state</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">tryBootstrap</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">initServer</span><span class="p">)</span> <span class="n">tryBootstrap</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">bootstrapCluster</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">pkg/server/node.go</code>, function <code class="language-plaintext highlighter-rouge">bootstrapCluster</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kvserver</span><span class="o">.</span><span class="n">InitEngine</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">storeIdent</span><span class="p">)</span>
<span class="n">kvserver</span><span class="o">.</span><span class="n">WriteInitialClusterData</span><span class="p">()</span> <span class="c">// writes initialization data to an engine. It creates system ranges (filling in meta1 and meta2) and the default zone config.</span>
</code></pre></div></div>

<p>Question:</p>
<ul>
  <li>When the first range was creatiation?
In <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/store_init.go</code>:
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              <span class="n">desc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">roachpb</span><span class="o">.</span><span class="n">RangeDescriptor</span><span class="p">{</span>
                      <span class="n">RangeID</span><span class="o">:</span>       <span class="n">rangeID</span><span class="p">,</span>
                      <span class="n">StartKey</span><span class="o">:</span>      <span class="n">startKey</span><span class="p">,</span>
                      <span class="n">EndKey</span><span class="o">:</span>        <span class="n">endKey</span><span class="p">,</span>
                      <span class="n">NextReplicaID</span><span class="o">:</span> <span class="m">2</span><span class="p">,</span>
              <span class="p">}</span>
              <span class="k">const</span> <span class="n">firstReplicaID</span> <span class="o">=</span> <span class="m">1</span>
              <span class="n">replicas</span> <span class="o">:=</span> <span class="p">[]</span><span class="n">roachpb</span><span class="o">.</span><span class="n">ReplicaDescriptor</span><span class="p">{</span>
                      <span class="p">{</span>
                              <span class="n">NodeID</span><span class="o">:</span>    <span class="n">FirstNodeID</span><span class="p">,</span>
                              <span class="n">StoreID</span><span class="o">:</span>   <span class="n">FirstStoreID</span><span class="p">,</span>
                              <span class="n">ReplicaID</span><span class="o">:</span> <span class="n">firstReplicaID</span><span class="p">,</span>
                      <span class="p">},</span>
              <span class="p">}</span>
              <span class="n">desc</span><span class="o">.</span><span class="n">SetReplicas</span><span class="p">(</span><span class="n">roachpb</span><span class="o">.</span><span class="n">MakeReplicaSet</span><span class="p">(</span><span class="n">replicas</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
  <li>How to determine whether a cluster has been bootstrapped when restarting?
    <ol>
      <li>In <code class="language-plaintext highlighter-rouge">Server::PreStart</code>, <code class="language-plaintext highlighter-rouge">inspectEngineState := InspectEngines()</code></li>
      <li>In <code class="language-plaintext highlighter-rouge">InitServer::ServeAndWait</code>, <code class="language-plaintext highlighter-rouge">s.inspectEngineState.bootstrapt()</code></li>
    </ol>
  </li>
  <li>When to start serving ranges?
See <code class="language-plaintext highlighter-rouge">Node::start</code> for details.</li>
  <li>What happen if no any join list was specified?
Report errors</li>
</ul>

<h2 id="join-node">Join Node</h2>

<p>In <code class="language-plaintext highlighter-rouge">pkg/server/node.go</code>, function <code class="language-plaintext highlighter-rouge">Join()</code>:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">compareBinaryVersion</span><span class="p">()</span>
<span class="n">nodeID</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">allocateNodeID</span><span class="p">()</span>
    <span class="n">val</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">kv</span><span class="o">.</span><span class="n">IncrementValRetryable</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">keys</span><span class="o">.</span><span class="n">NodeIDGenerator</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
        <span class="n">db</span><span class="o">.</span><span class="n">Inc</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span> <span class="c">// pkg/kv/db.go   var db *DB</span>
<span class="n">storeID</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">allocateStoreIDs</span><span class="p">()</span>
    <span class="n">val</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">kv</span><span class="o">.</span><span class="n">IncrementValRetryable</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">keys</span><span class="o">.</span><span class="n">StoreIDGenerator</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
<span class="c">// create liveness record, so what is the purpose of liveness record?</span>
<span class="n">n</span><span class="o">.</span><span class="n">storeCfg</span><span class="o">.</span><span class="n">NodeLiveness</span><span class="o">.</span><span class="n">CreateLivenessRecord</span><span class="p">()</span>
</code></pre></div></div>

<p>Questions:</p>
<ul>
  <li>What happen if receives <code class="language-plaintext highlighter-rouge">Join</code> requests?
Only check version and allocate NodeID. If a node has already bootstrapted, it won’t allocate new node id again (See PreStart() for details).</li>
  <li>What should to do for adding new table?
TODO</li>
  <li>Where is the master role for cockroachdb?
TODO</li>
</ul>

<h2 id="add-replica-on-store">Add Replica on Store</h2>

<p>In <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/store_create_replica.go</code>, function <code class="language-plaintext highlighter-rouge">getOrCreateReplica</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getOrCreateReplica -&gt; tryGetOrCreateReplica
    // 1. current replica is removed, go back around
    // 2. drop messages from replica we known to be too old
    // 3. the current replica need to be removed, remove it and go back around
    // 4. drop staled msg silently
    // 5. check tombstone
    newUnloadedReplica
    Store::addReplicaToRangeMapLocked
    StateLoader::SetRangeReplicaID
    Replica::loadRaftMuLockedReplicaMuLocked
</code></pre></div></div>

<p>Questions:</p>
<ul>
  <li>When the new replica are created?
See above.</li>
</ul>

<h2 id="raft">Raft</h2>

<ol>
  <li>Initialize
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Node::start
 Store::processRaft
     raftScheduler::Start
         async raftScheduler::worker
     async raftScheduler::Wait
     async raftTickLoop
     async coalescedHeartbeatsLoop
</code></pre></div>    </div>
  </li>
  <li>run worker, in <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/store_raft.go</code> and <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/replica_raft.go</code>.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>raftScheduler::worker
 raftScheduler::processTick
     Replica::tick(IsLiveMap)  // `pkg/kv/kvserver/replica_raft.go`
         RawNode::ReportUnreachable(Replica.unreachablesMu.remotes)
         Replica::maybeQuiesceRaftMuLockedReplicaMuLocked
         Replica::maybeTransferRaftLeadershipToLeaseholderLocked
         RawNode::Tick
 raftScheduler::processReady
     // See below apply parts.
 raftScheduler::processRequestQueue
     Store::withReplicaForRequest
         Store::getOrCreateReplica
         Store::processRaftRequestWithReplica
             Replica::stepRaftGroup
                 Replica::withRaftGroup
                     // if internal raft group is null, try create it
                     RawNode::Step
</code></pre></div>    </div>
  </li>
  <li>propose
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Node::Batch -&gt; Node::batchInternal
 Stores::Send(BatchRequest) -&gt; Stores::GetStore -&gt; Store::Send   // `pkg/kv/kvserver/store_send.go`
     Clock::Update  // Advances the local node's clock  to a high water mark from all nodes with which it has interacted.
     Store::GetReplica -&gt; Replica::Send -&gt; Replica::sendWithoutRangeID   // `pkg/kv/kvserver/replica_send.go`
         Replica::maybeInitializeRaftGroup      // If the internal Raft group is not initialized, create it and wake the leader.
             Replica::withRaftGroupLocked
                 Replica::maybeCampaignOnWakeLocked -&gt; Replica::campaignLocked
                     Store::enqueueRaftUpdateCheck -&gt; raftScheduler::EnqueueRaftReady
         Replica::executeBatchWithConcurrencyRetries
             Replica::executeReadOnlyBatch
             Replica::executeReadWriteBatch     // `pkg/kv/kvserver/replica_write.go`
                 Replica::applyTimestampCache
                 Replica::evalAndPropose        // `pkg/kv/kvserver/replica_raft.go`
                     Replica::requestToProposal // `pkg/kv/kvserver/replica_proposal.go`
                         Replica::evaluateProposal -&gt; Replica::evaluateWriteBatch
                             Replica::evaluate1PC
                             Replica::evaluateWriteBatchWithServersideRefreshes -&gt; Replica::evaluateWriteBatchWrapper -&gt; evaluateBatch  // `pkg/kv/kvserver/replica_evaluate.go`
                                 optimizePuts
                                 evaluateCommand
                                     batcheval.LookupCommand
                                     Command::EvalRO
                                     Command::EvalRW
                                         Put     // `pkg/kv/kvserver/batcheval/cmd_put.go`
                                             storage.MVCCPut
                                             storage.MVCCConditionalPut  // `pkg/storage/mvcc.go`
                     Replica::propose -&gt; propBuf::Insert
         Replica::executeAdminBatch   // No interaction with the spanlatch manager or the timestamp cache.
         Replica::maybeAddRangeInfoToResponse
     // if ranges are mismatched, try to suggest a more suitable range from this store.
</code></pre></div>    </div>
  </li>
  <li>apply
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Store::processReady -&gt; Replica::HandleRaftReady -&gt; Replica::HandleRaftReadyRaftMuLocked -&gt; Replica::withRaftGroupLocked
 propBuf::FlushLockedWithRaftGroup   // Question: will `propBuf::Insert` signal ready queue?
 RawNode::Ready
 Replica::applySnapshot
 Task::AckCommittedEntriesBeforeApplication  // `pkg/kv/kvserver/apply/task.go`
 Replica::sendRaftMessagesRaftMuLocked       // `pkg/kv/kvserver/replica_raft.go`
 Replica::append                             // `pkg/kv/kvserver/replica_raftstorage.go`
     storage.Writer::MVCCPut                 // Writer is `Store::Engine().NewUnindexedBatch`
     Batch::Commit
 Replica::sendRaftMessagesRaftMuLocked       // `pkg/kv/kvserver/replica_raft.go`
 Task::ApplyCommittedEntries -&gt; Task::ApplyOneBatch
     Batch::Stage(Command) -&gt; replicaAppBatch::Stage   // `pkg/kv/kvserver/replica_application_state_machine.go`
         Replica::ShouldApplyCommand
     Batch::ApplyToStateMachine              // StateMachine::NewBatch
     AppliedCommand::AckOutcomeAndFinish
 Replica::withRaftGroupLocked
     RawNode::Advance(Ready)
     Replica::campaignLocked     // if shouldCampaignAfterConfChange: if raft leader got moved, campaign the first remaning voter.
     Store::enqueueRaftUpdateCheck  // if RawNode::HasReady
</code></pre></div>    </div>
  </li>
  <li>transport
API defines in <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/storage_services.proto</code>:
    <div class="language-proto highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">service</span> <span class="n">MultiRaft</span> <span class="p">{</span>
 <span class="k">rpc</span> <span class="n">RaftMessageBatch</span> <span class="p">(</span><span class="n">stream</span> <span class="n">cockroach.kv.kvserver.kvserverpb.RaftMessageRequestBatch</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">stream</span> <span class="n">cockroach.kv.kvserver.kvserverpb.RaftMessageResponse</span><span class="p">)</span> <span class="p">{}</span>
 <span class="k">rpc</span> <span class="n">RaftSnapshot</span> <span class="p">(</span><span class="n">stream</span> <span class="n">cockroach.kv.kvserver.kvserverpb.SnapshotRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">stream</span> <span class="n">cockroach.kv.kvserver.kvserverpb.SnapshotResponse</span><span class="p">)</span> <span class="p">{}</span>
 <span class="k">rpc</span> <span class="n">DelegateRaftSnapshot</span><span class="p">(</span><span class="n">stream</span> <span class="n">cockroach.kv.kvserver.kvserverpb.DelegateSnapshotRequest</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">stream</span> <span class="n">cockroach.kv.kvserver.kvserverpb.DelegateSnapshotResponse</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>The implementation lie in <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/raft_transport.go</code>, function is <code class="language-plaintext highlighter-rouge">RaftTransport::RaftMessageBatch</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RaftMessageBatch
    stream.Recv
    RaftTransport::handleRaftRequest
        RaftTransport::getHandler(StoreID)  // read handler of corresponding store ID
        Store::HandleRaftRequest            // `pkg/kv/kvserver/store_raft.go`: dispatches a raft message to the appropriate Replica.
            Store::HandleRaftUncoalescedRequest
                raftReceiveQueues::LoadOrCreate(RangeID)
                raftReceiveQueue::Append
            raftScheduler::EnqueueRaftRequest
    stream.Send(newRaftMessageResponse)
</code></pre></div></div>

<p>Questions:</p>
<ul>
  <li>Where the <code class="language-plaintext highlighter-rouge">conditional_put</code> is executed?
In file <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/batcheval/cmd_conditional_put.go</code>, it is invoked by <code class="language-plaintext highlighter-rouge">executeCommand</code>.</li>
  <li>What is the purpose of <code class="language-plaintext highlighter-rouge">CommandID</code>?
The command ID is equals <code class="language-plaintext highlighter-rouge">makeIDKey() -&gt; rand.Int64()</code>.
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// CmdIDKey is a Raft command id. This will be logged unredacted - keep it random.</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="rebalance">Rebalance</h2>

<p>In <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/store.go</code>, function <code class="language-plaintext highlighter-rouge">Store::Start</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NewStoreRebalancer</span>
<span class="n">StoreRebalancer</span><span class="o">::</span><span class="n">Start</span>
    <span class="c">// rebalanceStore iterates through the top K hottest ranges on this store and</span>
    <span class="c">// for each such range, performs a lease transfer if it determines that that</span>
    <span class="c">// will improve QPS balance across the stores in the cluster. After it runs out</span>
    <span class="c">// of leases to transfer away (i.e. because it couldn't find better</span>
    <span class="c">// replacements), it considers these ranges for replica rebalancing.</span>
    <span class="n">async</span> <span class="n">StoreRebalancer</span><span class="o">::</span><span class="n">rebalanceStore</span>
        <span class="n">StoreRebalancer</span><span class="o">::</span><span class="n">chooseLeaseToTransfer</span>
        <span class="n">replicateQueue</span><span class="o">::</span><span class="n">transferLease</span>
        <span class="n">StoreRebalancer</span><span class="o">::</span><span class="n">chooseRangeToRebalance</span>
        <span class="n">DB</span><span class="o">::</span><span class="n">AdminRelocateRange</span>
</code></pre></div></div>

<h2 id="db">DB</h2>

<p>DB is a database handle to a single cockroach cluster. A DB is safe for concurrent use by multiple goroutines.</p>

<p><code class="language-plaintext highlighter-rouge">kv.DB</code> interfaces:</p>
<ul>
  <li>Get</li>
  <li>GetForUpdate</li>
  <li>GetProto</li>
  <li>GetProtoTs</li>
  <li>Put</li>
  <li>PutInline</li>
  <li>CPut</li>
  <li>Inc</li>
  <li>Scan</li>
  <li>AdminSplit</li>
  <li>AdminMerge</li>
  <li>AdminRelocateRange</li>
  <li>AdminChangeReplicas</li>
  <li>etc …</li>
</ul>

<p>Put code path:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DB::Put -&gt; DB::Run(Batch) -&gt; DB::SendAndFail -&gt; DB::send -&gt; DB::sendUsingSender
    CrossRangeTxnWrapperSender::Send -&gt; DistSender::Send
        DistSender::initAndVerifyBatch
        keys.Range
        DistSender::divideAndSendParallelCommit
            DistSender::divideAndSendBatchToRanges
        DistSender::divideAndSendBatchToRanges
            RangeIterator::Seek
            DistSender::sendPartialBatch
                DistSender::sendToReplicas
                    DistSender::transportFactory
                    Transport::SendNext
</code></pre></div></div>

<h3 id="error-retry">Error Retry</h3>

<p>TODO</p>

<h3 id="range-cache">Range Cache</h3>

<p>TODO</p>

<h3 id="txn">Txn</h3>

<p>TODO</p>]]></content><author><name></name></author><summary type="html"><![CDATA[CockroachDB KV Entrance In pkg/cmd/cockroach.go: func main() { cli.Main() } In pkg/cli/cli.go: cockroachCmd.AddCommand( startCmd, initCmd, ) According cockroach db manual: cockroach start --join xxx cockroach init --host &lt;address of any node&gt; So the setup logic lie in startCmd, and cluster bootstrap login lie in initCmd. In pkg/cli/start.go, command startCmd will invoke runStartJoin -&gt; runStart: func runStart() { var s *server.Server s, err = server.NewServer() s.PreStart() s.InitialStart() s.AcceptClients() } Start Node In Server::NewServer: clock = hlc.NewClock() engines = cfg.CreateEngines() eng, err = storage.NewPebble(ctx, pebbleConfig) rpcContext = rpc.NewContext() grpcServer = newGRPCServer(rpcContext) g = gossip.New() distSender = kvcoord.NewDistSender() // `pkg/kv/kvclient/kvcoord/dist_sender.go` tcsFactory = kvcoord.NewTxnCoordSenderFactory(txnCoordSenderFactoryCfg, distSender) // `pkg/kv/kvclient/kvcoord/txn_coord_sender_factory.go` db = kv.NewDBWithContext(clock, dbCtx) raftTransport = kvserver.NewRaftTransport() stores = kvserver.NewStores() tsDB = ts.NewDB(db, tcsFactory) node = NewNode() roachpb.RegisterInternalServer(grpcServer.Server, node) kvserver.RegisterPerReplicaServer(grpcServer.Server, node.perReplicaServer) kvserver.RegisterPerStoreServer(grpcServer.Server, node.perReplicaServer) ctpb.RegisterSideTransportServer(grpcServer.Server, ctReceiver) sqlServer, err := newSQLServer(ctx, sqlServerArgs) In Server::PreStart: s.rpcContext.SetLocalInternalServer(s.node) s.http.start() s.externalStorageBuilder.init() inspectEngineState = inspectEngines() // go through engines and constructs an initState. In `pkg/server/init.go` storeIdent, err = kvserver.ReadStoreIdent() serverpb.RegisterInitServer(s.grpc.Server, initServer) // support `service Init` in `pkg/server/serverpb/init.proto`. startListenRPCAndSQL() // only start rpc server, but initialize sql server. configureGRPCGateway() startRPCServer() onInitServerReady() state = initServer.ServeAndWait() // bootstrapAddresses := cfg.FilterGossipBootstrapAddress() in `newInitServerConfig`. from func (cfg *Config) parseGossipBootstrapAddresses s.startJoinLoop() // continuously retries connecting to nodes specified in the join list, in order to determine what the cluster ID, node ID is. s.attemptJoinIn() send JoinNodeRequest s.initializeFirstStoreAfterJoin() kvserver.InitEngines() state := &lt;- s.joinCh s.rpcContext.NodeID.set(state.NodeID) runAsyncTask("connect-gossip") // only log s.gossip.Start() g.setAddresses(addresses) g.server.start() g.bootstrap() g.manage() s.node.start() // In `pkg/server/node.go` s.replicationReporter.start() s.sqlServer.preStart() There are some comments in PreStart: // "bootstrapping problem": nodes need to connect to Gossip fairly // early, but what drives Gossip connectivity are the first range // replicas in the kv store. This in turn suggests opening the Gossip // server early. However, naively doing so also serves most other // services prematurely, which exposes a large surface of potentially // underinitialized services. This is avoided with some additional // complexity that can be summarized as follows: // // - before blocking trying to connect to the Gossip network, we already open // the admin UI (so that its diagnostics are available) // - we also allow our Gossip and our connection health Ping service // - everything else returns Unavailable errors (which are retryable) // - once the node has started, unlock all RPCs. In Node::start: n.storeCfg.Gossip.NodeID.set(n.nodeDescriptor.NodeID) n.storeCfg.Gossip.SetNodeDescriptor.set(n.nodeDescriptor) for _, e := state.initializedEngines { s := kvserver.NewStore(e) // In `pkg/kv/kvserver/store.go` s.Start() // Iterate over all range descriptor, ignoring uncommitted version. IterateRangeDescriptorFromDisk() replica = newReplica() // In `pkg/kv/kvserver/replica_init.go` newUnloadReplica() loadRaftMuLockedReplicaMuLocked() lastIndex = r.stateLoader.LoadLastIndex() s.addReplicaInternal(replica) s.cfg.Transport.Listen(s.StoreID(), s) s.processRaft() s.storeRebalancer.Start() // rebalance is finished in store? s.startGossip() s.startLeaseRenewer() n.addStore(s) } n.storeCfg.Gossip.SetStorage(n.stores) n.startGossiping(n.stopper) // loops on a periodic ticker to gossip node-related information. s.GossipStore() // GossipStore broadcasts the store on the gossip network. In Server::AcceptClients: s.sqlServer.startServerSQL() Start Store In pkg/kv/kvserver/store.go: Store::Start ReadStoreIdent idalloc.NewAllocator intentResolver.New makeRaftLogTruncator txnrecovery.NewManager // Iterate over all range descriptor, ignoring uncommitted version. IterateRangeDescriptorFromDisk() replica = newReplica() // In `pkg/kv/kvserver/replica_init.go` newUnloadReplica() loadRaftMuLockedReplicaMuLocked() lastIndex = r.stateLoader.LoadLastIndex() s.addReplicaInternal(replica) s.cfg.Transport.Listen(s.StoreID(), s) s.cfg.NodeLiveness.RegisterCallback(s.nodeIsLiveCallback) s.processRaft() s.storeRebalancer.Start() // rebalance is finished in store? s.startGossip() s.startLeaseRenewer() s.startRangefeedUpdator() NewStoreRebalancer() ID Allocator In pkg/kv/kvserver/store.go: // Create ID allocators. idAlloc, err := idalloc.NewAllocator(idalloc.Options{ AmbientCtx: s.cfg.AmbientCtx, Key: keys.RangeIDGenerator, Incrementer: idalloc.DBIncrementer(s.db), BlockSize: rangeIDAllocCount, Stopper: s.stopper, } The Allocator will allocate rangeIDAllocCount count from DB with key keys.RangeIDGenerator. Bootstrap In pkg/cli/init.go: func runInit() { c, err := NewInitClient() c.Bootstrap(BootstrapRequest {}) } In pkg/server/init.go: func (s *initServer) Bootstrap() { state, err = s.tryBootstrap() } func (s *initServer) tryBootstrap() { return bootstrapCluster() } In pkg/server/node.go, function bootstrapCluster: kvserver.InitEngine(engine, storeIdent) kvserver.WriteInitialClusterData() // writes initialization data to an engine. It creates system ranges (filling in meta1 and meta2) and the default zone config. Question: When the first range was creatiation? In pkg/kv/kvserver/store_init.go: desc := &amp;roachpb.RangeDescriptor{ RangeID: rangeID, StartKey: startKey, EndKey: endKey, NextReplicaID: 2, } const firstReplicaID = 1 replicas := []roachpb.ReplicaDescriptor{ { NodeID: FirstNodeID, StoreID: FirstStoreID, ReplicaID: firstReplicaID, }, } desc.SetReplicas(roachpb.MakeReplicaSet(replicas)) How to determine whether a cluster has been bootstrapped when restarting? In Server::PreStart, inspectEngineState := InspectEngines() In InitServer::ServeAndWait, s.inspectEngineState.bootstrapt() When to start serving ranges? See Node::start for details. What happen if no any join list was specified? Report errors Join Node In pkg/server/node.go, function Join(): compareBinaryVersion() nodeID, err := allocateNodeID() val, err := kv.IncrementValRetryable(ctx, db, keys.NodeIDGenerator, 1) db.Inc(ctx, key, inc) // pkg/kv/db.go var db *DB storeID, err := allocateStoreIDs() val, err := kv.IncrementValRetryable(ctx, db, keys.StoreIDGenerator, count) // create liveness record, so what is the purpose of liveness record? n.storeCfg.NodeLiveness.CreateLivenessRecord() Questions: What happen if receives Join requests? Only check version and allocate NodeID. If a node has already bootstrapted, it won’t allocate new node id again (See PreStart() for details). What should to do for adding new table? TODO Where is the master role for cockroachdb? TODO Add Replica on Store In pkg/kv/kvserver/store_create_replica.go, function getOrCreateReplica: getOrCreateReplica -&gt; tryGetOrCreateReplica // 1. current replica is removed, go back around // 2. drop messages from replica we known to be too old // 3. the current replica need to be removed, remove it and go back around // 4. drop staled msg silently // 5. check tombstone newUnloadedReplica Store::addReplicaToRangeMapLocked StateLoader::SetRangeReplicaID Replica::loadRaftMuLockedReplicaMuLocked Questions: When the new replica are created? See above. Raft Initialize Node::start Store::processRaft raftScheduler::Start async raftScheduler::worker async raftScheduler::Wait async raftTickLoop async coalescedHeartbeatsLoop run worker, in pkg/kv/kvserver/store_raft.go and pkg/kv/kvserver/replica_raft.go. raftScheduler::worker raftScheduler::processTick Replica::tick(IsLiveMap) // `pkg/kv/kvserver/replica_raft.go` RawNode::ReportUnreachable(Replica.unreachablesMu.remotes) Replica::maybeQuiesceRaftMuLockedReplicaMuLocked Replica::maybeTransferRaftLeadershipToLeaseholderLocked RawNode::Tick raftScheduler::processReady // See below apply parts. raftScheduler::processRequestQueue Store::withReplicaForRequest Store::getOrCreateReplica Store::processRaftRequestWithReplica Replica::stepRaftGroup Replica::withRaftGroup // if internal raft group is null, try create it RawNode::Step propose Node::Batch -&gt; Node::batchInternal Stores::Send(BatchRequest) -&gt; Stores::GetStore -&gt; Store::Send // `pkg/kv/kvserver/store_send.go` Clock::Update // Advances the local node's clock to a high water mark from all nodes with which it has interacted. Store::GetReplica -&gt; Replica::Send -&gt; Replica::sendWithoutRangeID // `pkg/kv/kvserver/replica_send.go` Replica::maybeInitializeRaftGroup // If the internal Raft group is not initialized, create it and wake the leader. Replica::withRaftGroupLocked Replica::maybeCampaignOnWakeLocked -&gt; Replica::campaignLocked Store::enqueueRaftUpdateCheck -&gt; raftScheduler::EnqueueRaftReady Replica::executeBatchWithConcurrencyRetries Replica::executeReadOnlyBatch Replica::executeReadWriteBatch // `pkg/kv/kvserver/replica_write.go` Replica::applyTimestampCache Replica::evalAndPropose // `pkg/kv/kvserver/replica_raft.go` Replica::requestToProposal // `pkg/kv/kvserver/replica_proposal.go` Replica::evaluateProposal -&gt; Replica::evaluateWriteBatch Replica::evaluate1PC Replica::evaluateWriteBatchWithServersideRefreshes -&gt; Replica::evaluateWriteBatchWrapper -&gt; evaluateBatch // `pkg/kv/kvserver/replica_evaluate.go` optimizePuts evaluateCommand batcheval.LookupCommand Command::EvalRO Command::EvalRW Put // `pkg/kv/kvserver/batcheval/cmd_put.go` storage.MVCCPut storage.MVCCConditionalPut // `pkg/storage/mvcc.go` Replica::propose -&gt; propBuf::Insert Replica::executeAdminBatch // No interaction with the spanlatch manager or the timestamp cache. Replica::maybeAddRangeInfoToResponse // if ranges are mismatched, try to suggest a more suitable range from this store. apply Store::processReady -&gt; Replica::HandleRaftReady -&gt; Replica::HandleRaftReadyRaftMuLocked -&gt; Replica::withRaftGroupLocked propBuf::FlushLockedWithRaftGroup // Question: will `propBuf::Insert` signal ready queue? RawNode::Ready Replica::applySnapshot Task::AckCommittedEntriesBeforeApplication // `pkg/kv/kvserver/apply/task.go` Replica::sendRaftMessagesRaftMuLocked // `pkg/kv/kvserver/replica_raft.go` Replica::append // `pkg/kv/kvserver/replica_raftstorage.go` storage.Writer::MVCCPut // Writer is `Store::Engine().NewUnindexedBatch` Batch::Commit Replica::sendRaftMessagesRaftMuLocked // `pkg/kv/kvserver/replica_raft.go` Task::ApplyCommittedEntries -&gt; Task::ApplyOneBatch Batch::Stage(Command) -&gt; replicaAppBatch::Stage // `pkg/kv/kvserver/replica_application_state_machine.go` Replica::ShouldApplyCommand Batch::ApplyToStateMachine // StateMachine::NewBatch AppliedCommand::AckOutcomeAndFinish Replica::withRaftGroupLocked RawNode::Advance(Ready) Replica::campaignLocked // if shouldCampaignAfterConfChange: if raft leader got moved, campaign the first remaning voter. Store::enqueueRaftUpdateCheck // if RawNode::HasReady transport API defines in pkg/kv/kvserver/storage_services.proto: service MultiRaft { rpc RaftMessageBatch (stream cockroach.kv.kvserver.kvserverpb.RaftMessageRequestBatch) returns (stream cockroach.kv.kvserver.kvserverpb.RaftMessageResponse) {} rpc RaftSnapshot (stream cockroach.kv.kvserver.kvserverpb.SnapshotRequest) returns (stream cockroach.kv.kvserver.kvserverpb.SnapshotResponse) {} rpc DelegateRaftSnapshot(stream cockroach.kv.kvserver.kvserverpb.DelegateSnapshotRequest) returns (stream cockroach.kv.kvserver.kvserverpb.DelegateSnapshotResponse) {} } The implementation lie in pkg/kv/kvserver/raft_transport.go, function is RaftTransport::RaftMessageBatch: RaftMessageBatch stream.Recv RaftTransport::handleRaftRequest RaftTransport::getHandler(StoreID) // read handler of corresponding store ID Store::HandleRaftRequest // `pkg/kv/kvserver/store_raft.go`: dispatches a raft message to the appropriate Replica. Store::HandleRaftUncoalescedRequest raftReceiveQueues::LoadOrCreate(RangeID) raftReceiveQueue::Append raftScheduler::EnqueueRaftRequest stream.Send(newRaftMessageResponse) Questions: Where the conditional_put is executed? In file pkg/kv/kvserver/batcheval/cmd_conditional_put.go, it is invoked by executeCommand. What is the purpose of CommandID? The command ID is equals makeIDKey() -&gt; rand.Int64(). // CmdIDKey is a Raft command id. This will be logged unredacted - keep it random. Rebalance In pkg/kv/kvserver/store.go, function Store::Start: NewStoreRebalancer StoreRebalancer::Start // rebalanceStore iterates through the top K hottest ranges on this store and // for each such range, performs a lease transfer if it determines that that // will improve QPS balance across the stores in the cluster. After it runs out // of leases to transfer away (i.e. because it couldn't find better // replacements), it considers these ranges for replica rebalancing. async StoreRebalancer::rebalanceStore StoreRebalancer::chooseLeaseToTransfer replicateQueue::transferLease StoreRebalancer::chooseRangeToRebalance DB::AdminRelocateRange DB DB is a database handle to a single cockroach cluster. A DB is safe for concurrent use by multiple goroutines. kv.DB interfaces: Get GetForUpdate GetProto GetProtoTs Put PutInline CPut Inc Scan AdminSplit AdminMerge AdminRelocateRange AdminChangeReplicas etc … Put code path: DB::Put -&gt; DB::Run(Batch) -&gt; DB::SendAndFail -&gt; DB::send -&gt; DB::sendUsingSender CrossRangeTxnWrapperSender::Send -&gt; DistSender::Send DistSender::initAndVerifyBatch keys.Range DistSender::divideAndSendParallelCommit DistSender::divideAndSendBatchToRanges DistSender::divideAndSendBatchToRanges RangeIterator::Seek DistSender::sendPartialBatch DistSender::sendToReplicas DistSender::transportFactory Transport::SendNext Error Retry TODO Range Cache TODO Txn TODO]]></summary></entry></feed>