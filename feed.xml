<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-05-24T16:10:47+08:00</updated><id>/feed.xml</id><title type="html">W41ter’s Bistro</title><subtitle>Focus on distributed storage system, compiler.</subtitle><entry><title type="html">CockroachDB Source Code Reading Notes</title><link href="/2022/05/24/CockroachDB-Source-Code.html" rel="alternate" type="text/html" title="CockroachDB Source Code Reading Notes" /><published>2022-05-24T00:00:00+08:00</published><updated>2022-05-24T00:00:00+08:00</updated><id>/2022/05/24/CockroachDB-Source-Code</id><content type="html" xml:base="/2022/05/24/CockroachDB-Source-Code.html"><![CDATA[<h1 id="cockroachdb">CockroachDB</h1>

<h2 id="entrance">Entrance</h2>

<p>In <code class="language-plaintext highlighter-rouge">pkg/cmd/cockroach.go</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cli</span><span class="o">.</span><span class="n">Main</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">pkg/cli/cli.go</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cockroachCmd</span><span class="o">.</span><span class="n">AddCommand</span><span class="p">(</span>
    <span class="n">startCmd</span><span class="p">,</span>
    <span class="n">initCmd</span><span class="p">,</span>
<span class="p">)</span>
</code></pre></div></div>

<p>According <a href="http://doc.cockroachchina.baidu.com/#deploy/manual-deployment/on-premises/#step-3">cockroach db manual</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cockroach start --join xxx
cockroach init --host &lt;address of any node&gt;
</code></pre></div></div>

<p>So the setup logic lie in <code class="language-plaintext highlighter-rouge">startCmd</code>, and cluster bootstrap login lie in <code class="language-plaintext highlighter-rouge">initCmd</code>.</p>

<p>In <code class="language-plaintext highlighter-rouge">pkg/cli/start.go</code>, command <code class="language-plaintext highlighter-rouge">startCmd</code> will invoke <code class="language-plaintext highlighter-rouge">runStartJoin</code> -&gt; <code class="language-plaintext highlighter-rouge">runStart</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func runStart() {
    var s *server.Server
    s, err = server.NewServer()
    s.PreStart()
    s.InitialStart()
    s.AcceptClients()
}
</code></pre></div></div>

<h3 id="start-node">Start Node</h3>

<p>In <code class="language-plaintext highlighter-rouge">Server::NewServer</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clock</span> <span class="o">=</span> <span class="n">hlc</span><span class="o">.</span><span class="n">NewClock</span><span class="p">()</span>
<span class="n">engines</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">CreateEngines</span><span class="p">()</span>
    <span class="n">eng</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">NewPebble</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">pebbleConfig</span><span class="p">)</span>
<span class="n">rpcContext</span> <span class="o">=</span> <span class="n">rpc</span><span class="o">.</span><span class="n">NewContext</span><span class="p">()</span>
<span class="n">grpcServer</span> <span class="o">=</span> <span class="n">newGRPCServer</span><span class="p">(</span><span class="n">rpcContext</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">gossip</span><span class="o">.</span><span class="n">New</span><span class="p">()</span>
<span class="n">distSender</span> <span class="o">=</span> <span class="n">kvcoord</span><span class="o">.</span><span class="n">NewDistSender</span><span class="p">()</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">kv</span><span class="o">.</span><span class="n">NewDBWithContext</span><span class="p">(</span><span class="n">clock</span><span class="p">,</span> <span class="n">dbCtx</span><span class="p">)</span>
<span class="n">raftTransport</span> <span class="o">=</span> <span class="n">kvserver</span><span class="o">.</span><span class="n">NewRaftTransport</span><span class="p">()</span>
<span class="n">stores</span> <span class="o">=</span> <span class="n">kvserver</span><span class="o">.</span><span class="n">NewStores</span><span class="p">()</span>
<span class="n">tsDB</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">NewDB</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">NewNode</span><span class="p">()</span>
<span class="n">roachpb</span><span class="o">.</span><span class="n">RegisterInternalServer</span><span class="p">(</span><span class="n">grpcServer</span><span class="o">.</span><span class="n">Server</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
<span class="n">kvserver</span><span class="o">.</span><span class="n">RegisterPerReplicaServer</span><span class="p">(</span><span class="n">grpcServer</span><span class="o">.</span><span class="n">Server</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">perReplicaServer</span><span class="p">)</span>
<span class="n">kvserver</span><span class="o">.</span><span class="n">RegisterPerStoreServer</span><span class="p">(</span><span class="n">grpcServer</span><span class="o">.</span><span class="n">Server</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">perReplicaServer</span><span class="p">)</span>
<span class="n">ctpb</span><span class="o">.</span><span class="n">RegisterSideTransportServer</span><span class="p">(</span><span class="n">grpcServer</span><span class="o">.</span><span class="n">Server</span><span class="p">,</span> <span class="n">ctReceiver</span><span class="p">)</span>
<span class="n">sqlServer</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">newSQLServer</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">sqlServerArgs</span><span class="p">)</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">Server::PreStart</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span><span class="o">.</span><span class="n">rpcContext</span><span class="o">.</span><span class="n">SetLocalInternalServer</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">http</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">externalStorageBuilder</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">inspectEngineState</span> <span class="o">=</span> <span class="n">inspectEngines</span><span class="p">()</span>   <span class="c">// go through engines and constructs an initState. In `pkg/server/init.go`</span>
    <span class="n">storeIdent</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">kvserver</span><span class="o">.</span><span class="n">ReadStoreIdent</span><span class="p">()</span>
<span class="n">serverpb</span><span class="o">.</span><span class="n">RegisterInitServer</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">grpc</span><span class="o">.</span><span class="n">Server</span><span class="p">,</span> <span class="n">initServer</span><span class="p">)</span>  <span class="c">// support `service Init` in `pkg/server/serverpb/init.proto`.</span>
<span class="n">startListenRPCAndSQL</span><span class="p">()</span> <span class="c">// only start rpc server, but initialize sql server.</span>
<span class="n">configureGRPCGateway</span><span class="p">()</span>
<span class="n">startRPCServer</span><span class="p">()</span>
<span class="n">onInitServerReady</span><span class="p">()</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">initServer</span><span class="o">.</span><span class="n">ServeAndWait</span><span class="p">()</span>
    <span class="c">// bootstrapAddresses := cfg.FilterGossipBootstrapAddress() in `newInitServerConfig`. from func (cfg *Config) parseGossipBootstrapAddresses</span>
    <span class="n">s</span><span class="o">.</span><span class="n">startJoinLoop</span><span class="p">()</span> <span class="c">// continuously retries connecting to nodes specified in the join list, in order to determine what the cluster ID, node ID is.</span>
        <span class="n">s</span><span class="o">.</span><span class="n">attemptJoinIn</span><span class="p">()</span>
            <span class="n">send</span> <span class="n">JoinNodeRequest</span>
        <span class="n">s</span><span class="o">.</span><span class="n">initializeFirstStoreAfterJoin</span><span class="p">()</span>
            <span class="n">kvserver</span><span class="o">.</span><span class="n">InitEngines</span><span class="p">()</span>
    <span class="n">state</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="n">s</span><span class="o">.</span><span class="n">joinCh</span>
<span class="n">s</span><span class="o">.</span><span class="n">rpcContext</span><span class="o">.</span><span class="n">NodeID</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">NodeID</span><span class="p">)</span>
<span class="n">runAsyncTask</span><span class="p">(</span><span class="s">"connect-gossip"</span><span class="p">)</span>  <span class="c">// only log</span>
<span class="n">s</span><span class="o">.</span><span class="n">gossip</span><span class="o">.</span><span class="n">Start</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">setAddresses</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">server</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">manage</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>  <span class="c">// In `pkg/server/node.go`</span>
<span class="n">s</span><span class="o">.</span><span class="n">replicationReporter</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">sqlServer</span><span class="o">.</span><span class="n">preStart</span><span class="p">()</span>
</code></pre></div></div>

<p>There are some comments in <code class="language-plaintext highlighter-rouge">PreStart</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// "bootstrapping problem": nodes need to connect to Gossip fairly</span>
<span class="c">// early, but what drives Gossip connectivity are the first range</span>
<span class="c">// replicas in the kv store. This in turn suggests opening the Gossip</span>
<span class="c">// server early. However, naively doing so also serves most other</span>
<span class="c">// services prematurely, which exposes a large surface of potentially</span>
<span class="c">// underinitialized services. This is avoided with some additional</span>
<span class="c">// complexity that can be summarized as follows:</span>
<span class="c">//</span>
<span class="c">// - before blocking trying to connect to the Gossip network, we already open</span>
<span class="c">//   the admin UI (so that its diagnostics are available)</span>
<span class="c">// - we also allow our Gossip and our connection health Ping service</span>
<span class="c">// - everything else returns Unavailable errors (which are retryable)</span>
<span class="c">// - once the node has started, unlock all RPCs.</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">Node::start</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span><span class="o">.</span><span class="n">storeCfg</span><span class="o">.</span><span class="n">Gossip</span><span class="o">.</span><span class="n">NodeID</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">nodeDescriptor</span><span class="o">.</span><span class="n">NodeID</span><span class="p">)</span>
<span class="n">n</span><span class="o">.</span><span class="n">storeCfg</span><span class="o">.</span><span class="n">Gossip</span><span class="o">.</span><span class="n">SetNodeDescriptor</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">nodeDescriptor</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">state</span><span class="o">.</span><span class="n">initializedEngines</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">:=</span> <span class="n">kvserver</span><span class="o">.</span><span class="n">NewStore</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>  <span class="c">// In `pkg/kv/kvserver/store.go`</span>
    <span class="n">s</span><span class="o">.</span><span class="n">Start</span><span class="p">()</span>
        <span class="c">// Iterate over all range descriptor, ignoring uncommitted version.</span>
        <span class="n">IterateRangeDescriptorFromDisk</span><span class="p">()</span>
            <span class="n">replica</span> <span class="o">=</span> <span class="n">newReplica</span><span class="p">()</span>  <span class="c">// In `pkg/kv/kvserver/replica_init.go`</span>
                <span class="n">newUnloadReplica</span><span class="p">()</span>
                <span class="n">loadRaftMuLockedReplicaMuLocked</span><span class="p">()</span>
                    <span class="n">lastIndex</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">stateLoader</span><span class="o">.</span><span class="n">LoadLastIndex</span><span class="p">()</span>
            <span class="n">s</span><span class="o">.</span><span class="n">addReplicaInternal</span><span class="p">(</span><span class="n">replica</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">Transport</span><span class="o">.</span><span class="n">Listen</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">StoreID</span><span class="p">(),</span> <span class="n">s</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">processRaft</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">storeRebalancer</span><span class="o">.</span><span class="n">Start</span><span class="p">()</span> <span class="c">// rebalance is finished in store?</span>
        <span class="n">s</span><span class="o">.</span><span class="n">startGossip</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">startLeaseRenewer</span><span class="p">()</span>

    <span class="n">n</span><span class="o">.</span><span class="n">addStore</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">n</span><span class="o">.</span><span class="n">storeCfg</span><span class="o">.</span><span class="n">Gossip</span><span class="o">.</span><span class="n">SetStorage</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">stores</span><span class="p">)</span>
<span class="n">n</span><span class="o">.</span><span class="n">startGossiping</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">stopper</span><span class="p">)</span>  <span class="c">// loops on a periodic ticker to gossip node-related information.</span>
    <span class="n">s</span><span class="o">.</span><span class="n">GossipStore</span><span class="p">()</span> <span class="c">// GossipStore broadcasts the store on the gossip network.</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">Server::AcceptClients</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span><span class="o">.</span><span class="n">sqlServer</span><span class="o">.</span><span class="n">startServerSQL</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="bootstrap">Bootstrap</h2>

<p>In <code class="language-plaintext highlighter-rouge">pkg/cli/init.go</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">runInit</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">NewInitClient</span><span class="p">()</span>
    <span class="n">c</span><span class="o">.</span><span class="n">Bootstrap</span><span class="p">(</span><span class="n">BootstrapRequest</span> <span class="p">{})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">pkg/server/init.go</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">initServer</span><span class="p">)</span> <span class="n">Bootstrap</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">state</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">tryBootstrap</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">initServer</span><span class="p">)</span> <span class="n">tryBootstrap</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">bootstrapCluster</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">pkg/server/node.go</code>, function <code class="language-plaintext highlighter-rouge">bootstrapCluster</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kvserver</span><span class="o">.</span><span class="n">InitEngine</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">storeIdent</span><span class="p">)</span>
<span class="n">kvserver</span><span class="o">.</span><span class="n">WriteInitialClusterData</span><span class="p">()</span> <span class="c">// writes initialization data to an engine. It creates system ranges (filling in meta1 and meta2) and the default zone config.</span>
</code></pre></div></div>

<p>Question:</p>
<ul>
  <li>When the first range was creatiation?
In <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/store_init.go</code>:
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              <span class="n">desc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">roachpb</span><span class="o">.</span><span class="n">RangeDescriptor</span><span class="p">{</span>
                      <span class="n">RangeID</span><span class="o">:</span>       <span class="n">rangeID</span><span class="p">,</span>
                      <span class="n">StartKey</span><span class="o">:</span>      <span class="n">startKey</span><span class="p">,</span>
                      <span class="n">EndKey</span><span class="o">:</span>        <span class="n">endKey</span><span class="p">,</span>
                      <span class="n">NextReplicaID</span><span class="o">:</span> <span class="m">2</span><span class="p">,</span>
              <span class="p">}</span>
              <span class="k">const</span> <span class="n">firstReplicaID</span> <span class="o">=</span> <span class="m">1</span>
              <span class="n">replicas</span> <span class="o">:=</span> <span class="p">[]</span><span class="n">roachpb</span><span class="o">.</span><span class="n">ReplicaDescriptor</span><span class="p">{</span>
                      <span class="p">{</span>
                              <span class="n">NodeID</span><span class="o">:</span>    <span class="n">FirstNodeID</span><span class="p">,</span>
                              <span class="n">StoreID</span><span class="o">:</span>   <span class="n">FirstStoreID</span><span class="p">,</span>
                              <span class="n">ReplicaID</span><span class="o">:</span> <span class="n">firstReplicaID</span><span class="p">,</span>
                      <span class="p">},</span>
              <span class="p">}</span>
              <span class="n">desc</span><span class="o">.</span><span class="n">SetReplicas</span><span class="p">(</span><span class="n">roachpb</span><span class="o">.</span><span class="n">MakeReplicaSet</span><span class="p">(</span><span class="n">replicas</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
  <li>How to determine whether a cluster has been bootstrapped when restarting?
    <ol>
      <li>In <code class="language-plaintext highlighter-rouge">Server::PreStart</code>, <code class="language-plaintext highlighter-rouge">inspectEngineState := InspectEngines()</code></li>
      <li>In <code class="language-plaintext highlighter-rouge">InitServer::ServeAndWait</code>, <code class="language-plaintext highlighter-rouge">s.inspectEngineState.bootstrapt()</code></li>
    </ol>
  </li>
  <li>When to start serving ranges?
See <code class="language-plaintext highlighter-rouge">Node::start</code> for details.</li>
  <li>What happen if no any join list was specified?
Report errors</li>
</ul>

<h3 id="join-node">Join Node</h3>

<p>In <code class="language-plaintext highlighter-rouge">pkg/server/node.go</code>, function <code class="language-plaintext highlighter-rouge">Join()</code>:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">compareBinaryVersion</span><span class="p">()</span>
<span class="n">nodeID</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">allocateNodeID</span><span class="p">()</span>
    <span class="n">val</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">kv</span><span class="o">.</span><span class="n">IncrementValRetryable</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">keys</span><span class="o">.</span><span class="n">NodeIDGenerator</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
        <span class="n">db</span><span class="o">.</span><span class="n">Inc</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span> <span class="c">// pkg/kv/db.go   var db *DB</span>
            <span class="n">db</span><span class="o">.</span><span class="n">Run</span><span class="p">()</span>
                <span class="n">db</span><span class="o">.</span><span class="n">SendAndFill</span><span class="p">()</span>
                    <span class="n">db</span><span class="o">.</span><span class="n">send</span><span class="p">()</span>
<span class="n">storeID</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">allocateStoreIDs</span><span class="p">()</span>
    <span class="n">val</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">kv</span><span class="o">.</span><span class="n">IncrementValRetryable</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">keys</span><span class="o">.</span><span class="n">StoreIDGenerator</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
<span class="c">// create liveness record, so what is the purpose of liveness record?</span>
<span class="n">n</span><span class="o">.</span><span class="n">storeCfg</span><span class="o">.</span><span class="n">NodeLiveness</span><span class="o">.</span><span class="n">CreateLivenessRecord</span><span class="p">()</span>
</code></pre></div></div>

<p>Questions:</p>
<ul>
  <li>What happen if receives <code class="language-plaintext highlighter-rouge">Join</code> requests?
Only check version and allocate NodeID. If a node has already bootstrapted, it won’t allocate new node id again (See PreStart() for details).</li>
  <li>What should to do for adding new table?
TODO</li>
  <li>Where is the master role for cockroachdb?
TODO</li>
</ul>

<h2 id="add-replica-on-store">Add Replica on Store</h2>

<p>In <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/store_create_replica.go</code>, function <code class="language-plaintext highlighter-rouge">getOrCreateReplica</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getOrCreateReplica -&gt; tryGetOrCreateReplica
    // 1. current replica is removed, go back around
    // 2. drop messages from replica we known to be too old
    // 3. the current replica need to be removed, remove it and go back around
    // 4. drop staled msg silently
    // 5. check tombstone
    newUnloadedReplica
    Store::addReplicaToRangeMapLocked
    StateLoader::SetRangeReplicaID
    Replica::loadRaftMuLockedReplicaMuLocked
</code></pre></div></div>

<p>Questions:</p>
<ul>
  <li>When the new replica are created?
See above.</li>
</ul>

<h2 id="raft">Raft</h2>

<ol>
  <li>Initialize
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Node::start
 Store::processRaft
     raftScheduler::Start
         async raftScheduler::worker
     async raftScheduler::Wait
     async raftTickLoop
     async coalescedHeartbeatsLoop
</code></pre></div>    </div>
  </li>
  <li>run worker, in <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/store_raft.go</code> and <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/replica_raft.go</code>.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>raftScheduler::worker
 raftScheduler::processRequestQueue
 raftScheduler::processTick
 raftScheduler::processReady
     Store::withReplicaForRequest
         Store::getOrCreateReplica
         Store::processRaftRequestWithReplica
             Replica::stepRaftGroup
                 Replica::withRaftGroup
                     // if internal raft group is null, try create it
                     RawNode::Step
</code></pre></div>    </div>
  </li>
  <li>propose
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Node::Batch -&gt; Node::batchInternal
 Stores::Send(BatchRequest) -&gt; Stores::GetStore -&gt; Store::Send   // `pkg/kv/kvserver/store_send.go`
     Clock::Update  // Advances the local node's clock  to a high water mark from all nodes with which it has interacted.
     Store::GetReplica -&gt; Replica::Send -&gt; Replica::sendWithoutRangeID   // `pkg/kv/kvserver/replica_send.go`
         Replica::maybeInitializeRaftGroup      // If the internal Raft group is not initialized, create it and wake the leader.
             Replica::withRaftGroupLocked
                 Replica::maybeCampaignOnWakeLocked -&gt; Replica::campaignLocked
                     Store::enqueueRaftUpdateCheck -&gt; raftScheduler::EnqueueRaftReady
         Replica::executeBatchWithConcurrencyRetries
             Replica::executeReadOnlyBatch
             Replica::executeReadWriteBatch     // `pkg/kv/kvserver/replica_write.go`
                 Replica::applyTimestampCache
                 Replica::evalAndPropose        // `pkg/kv/kvserver/replica_raft.go`
                     Replica::requestToProposal // `pkg/kv/kvserver/replica_proposal.go`
                         Replica::evaluateProposal -&gt; Replica::evaluateWriteBatch
                             Replica::evaluate1PC
                             Replica::evaluateWriteBatchWithServersideRefreshes -&gt; Replica::evaluateWriteBatchWrapper -&gt; evaluateBatch  // `pkg/kv/kvserver/replica_evaluate.go`
                                 optimizePuts
                                 evaluateCommand
                                     batcheval.LookupCommand
                                     Command::EvalRO
                                     Command::EvalRW
                                         Put     // `pkg/kv/kvserver/batcheval/cmd_put.go`
                                             storage.MVCCPut
                                             storage.MVCCConditionalPut  // `pkg/storage/mvcc.go`
                     Replica::propose -&gt; propBuf::Insert
         Replica::executeAdminBatch   // No interaction with the spanlatch manager or the timestamp cache.
         Replica::maybeAddRangeInfoToResponse
     // if ranges are mismatched, try to suggest a more suitable range from this store.
</code></pre></div>    </div>
  </li>
  <li>apply
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Store::processReady -&gt; Replica::HandleRaftReady -&gt; Replica::HandleRaftReadyRaftMuLocked -&gt; Replica::withRaftGroupLocked
 propBuf::FlushLockedWithRaftGroup   // Question: will `propBuf::Insert` signal ready queue?
 RawNode::Ready
 Replica::applySnapshot
 Task::AckCommittedEntriesBeforeApplication  // `pkg/kv/kvserver/apply/task.go`
 Replica::sendRaftMessagesRaftMuLocked       // `pkg/kv/kvserver/replica_raft.go`
 Replica::append                             // `pkg/kv/kvserver/replica_raftstorage.go`
     storage.Writer::MVCCPut                 // Writer is `Store::Engine().NewUnindexedBatch`
     Batch::Commit
 Replica::sendRaftMessagesRaftMuLocked       // `pkg/kv/kvserver/replica_raft.go`
 Task::ApplyCommittedEntries -&gt; Task::ApplyOneBatch
     Batch::Stage(Command) -&gt; replicaAppBatch::Stage   // `pkg/kv/kvserver/replica_application_state_machine.go`
         Replica::ShouldApplyCommand
     Batch::ApplyToStateMachine              // StateMachine::NewBatch
     AppliedCommand::AckOutcomeAndFinish
 Replica::withRaftGroupLocked
     RawNode::Advance(Ready)
     Replica::campaignLocked     // if shouldCampaignAfterConfChange: if raft leader got moved, campaign the first remaning voter.
     Store::enqueueRaftUpdateCheck  // if RawNode::HasReady
</code></pre></div>    </div>
  </li>
</ol>

<p>Questions:</p>
<ul>
  <li>Where the <code class="language-plaintext highlighter-rouge">conditional_put</code> is executed?
In file <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/batcheval/cmd_conditional_put.go</code>, it is invoked by <code class="language-plaintext highlighter-rouge">executeCommand</code>.</li>
  <li>What is the purpose of <code class="language-plaintext highlighter-rouge">CommandID</code>?
The command ID is equals <code class="language-plaintext highlighter-rouge">makeIDKey() -&gt; rand.Int64()</code>.
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// CmdIDKey is a Raft command id. This will be logged unredacted - keep it random.</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="rebalance">Rebalance</h2>

<p>In <code class="language-plaintext highlighter-rouge">pkg/kv/kvserver/store.go</code>, function <code class="language-plaintext highlighter-rouge">Store::Start</code>:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">NewStoreRebalancer</span>
<span class="n">StoreRebalancer</span><span class="o">::</span><span class="n">Start</span>
    <span class="c">// rebalanceStore iterates through the top K hottest ranges on this store and</span>
    <span class="c">// for each such range, performs a lease transfer if it determines that that</span>
    <span class="c">// will improve QPS balance across the stores in the cluster. After it runs out</span>
    <span class="c">// of leases to transfer away (i.e. because it couldn't find better</span>
    <span class="c">// replacements), it considers these ranges for replica rebalancing.</span>
    <span class="n">async</span> <span class="n">StoreRebalancer</span><span class="o">::</span><span class="n">rebalanceStore</span>
        <span class="n">StoreRebalancer</span><span class="o">::</span><span class="n">chooseLeaseToTransfer</span>
        <span class="n">replicateQueue</span><span class="o">::</span><span class="n">transferLease</span>
        <span class="n">StoreRebalancer</span><span class="o">::</span><span class="n">chooseRangeToRebalance</span>
        <span class="n">DB</span><span class="o">::</span><span class="n">AdminRelocateRange</span>
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[CockroachDB Entrance In pkg/cmd/cockroach.go: func main() { cli.Main() } In pkg/cli/cli.go: cockroachCmd.AddCommand( startCmd, initCmd, ) According cockroach db manual: cockroach start --join xxx cockroach init --host &lt;address of any node&gt; So the setup logic lie in startCmd, and cluster bootstrap login lie in initCmd. In pkg/cli/start.go, command startCmd will invoke runStartJoin -&gt; runStart: func runStart() { var s *server.Server s, err = server.NewServer() s.PreStart() s.InitialStart() s.AcceptClients() } Start Node In Server::NewServer: clock = hlc.NewClock() engines = cfg.CreateEngines() eng, err = storage.NewPebble(ctx, pebbleConfig) rpcContext = rpc.NewContext() grpcServer = newGRPCServer(rpcContext) g = gossip.New() distSender = kvcoord.NewDistSender() db = kv.NewDBWithContext(clock, dbCtx) raftTransport = kvserver.NewRaftTransport() stores = kvserver.NewStores() tsDB = ts.NewDB(db) node = NewNode() roachpb.RegisterInternalServer(grpcServer.Server, node) kvserver.RegisterPerReplicaServer(grpcServer.Server, node.perReplicaServer) kvserver.RegisterPerStoreServer(grpcServer.Server, node.perReplicaServer) ctpb.RegisterSideTransportServer(grpcServer.Server, ctReceiver) sqlServer, err := newSQLServer(ctx, sqlServerArgs) In Server::PreStart: s.rpcContext.SetLocalInternalServer(s.node) s.http.start() s.externalStorageBuilder.init() inspectEngineState = inspectEngines() // go through engines and constructs an initState. In `pkg/server/init.go` storeIdent, err = kvserver.ReadStoreIdent() serverpb.RegisterInitServer(s.grpc.Server, initServer) // support `service Init` in `pkg/server/serverpb/init.proto`. startListenRPCAndSQL() // only start rpc server, but initialize sql server. configureGRPCGateway() startRPCServer() onInitServerReady() state = initServer.ServeAndWait() // bootstrapAddresses := cfg.FilterGossipBootstrapAddress() in `newInitServerConfig`. from func (cfg *Config) parseGossipBootstrapAddresses s.startJoinLoop() // continuously retries connecting to nodes specified in the join list, in order to determine what the cluster ID, node ID is. s.attemptJoinIn() send JoinNodeRequest s.initializeFirstStoreAfterJoin() kvserver.InitEngines() state := &lt;- s.joinCh s.rpcContext.NodeID.set(state.NodeID) runAsyncTask("connect-gossip") // only log s.gossip.Start() g.setAddresses(addresses) g.server.start() g.bootstrap() g.manage() s.node.start() // In `pkg/server/node.go` s.replicationReporter.start() s.sqlServer.preStart() There are some comments in PreStart: // "bootstrapping problem": nodes need to connect to Gossip fairly // early, but what drives Gossip connectivity are the first range // replicas in the kv store. This in turn suggests opening the Gossip // server early. However, naively doing so also serves most other // services prematurely, which exposes a large surface of potentially // underinitialized services. This is avoided with some additional // complexity that can be summarized as follows: // // - before blocking trying to connect to the Gossip network, we already open // the admin UI (so that its diagnostics are available) // - we also allow our Gossip and our connection health Ping service // - everything else returns Unavailable errors (which are retryable) // - once the node has started, unlock all RPCs. In Node::start: n.storeCfg.Gossip.NodeID.set(n.nodeDescriptor.NodeID) n.storeCfg.Gossip.SetNodeDescriptor.set(n.nodeDescriptor) for _, e := state.initializedEngines { s := kvserver.NewStore(e) // In `pkg/kv/kvserver/store.go` s.Start() // Iterate over all range descriptor, ignoring uncommitted version. IterateRangeDescriptorFromDisk() replica = newReplica() // In `pkg/kv/kvserver/replica_init.go` newUnloadReplica() loadRaftMuLockedReplicaMuLocked() lastIndex = r.stateLoader.LoadLastIndex() s.addReplicaInternal(replica) s.cfg.Transport.Listen(s.StoreID(), s) s.processRaft() s.storeRebalancer.Start() // rebalance is finished in store? s.startGossip() s.startLeaseRenewer() n.addStore(s) } n.storeCfg.Gossip.SetStorage(n.stores) n.startGossiping(n.stopper) // loops on a periodic ticker to gossip node-related information. s.GossipStore() // GossipStore broadcasts the store on the gossip network. In Server::AcceptClients: s.sqlServer.startServerSQL() Bootstrap In pkg/cli/init.go: func runInit() { c, err := NewInitClient() c.Bootstrap(BootstrapRequest {}) } In pkg/server/init.go: func (s *initServer) Bootstrap() { state, err = s.tryBootstrap() } func (s *initServer) tryBootstrap() { return bootstrapCluster() } In pkg/server/node.go, function bootstrapCluster: kvserver.InitEngine(engine, storeIdent) kvserver.WriteInitialClusterData() // writes initialization data to an engine. It creates system ranges (filling in meta1 and meta2) and the default zone config. Question: When the first range was creatiation? In pkg/kv/kvserver/store_init.go: desc := &amp;roachpb.RangeDescriptor{ RangeID: rangeID, StartKey: startKey, EndKey: endKey, NextReplicaID: 2, } const firstReplicaID = 1 replicas := []roachpb.ReplicaDescriptor{ { NodeID: FirstNodeID, StoreID: FirstStoreID, ReplicaID: firstReplicaID, }, } desc.SetReplicas(roachpb.MakeReplicaSet(replicas)) How to determine whether a cluster has been bootstrapped when restarting? In Server::PreStart, inspectEngineState := InspectEngines() In InitServer::ServeAndWait, s.inspectEngineState.bootstrapt() When to start serving ranges? See Node::start for details. What happen if no any join list was specified? Report errors Join Node In pkg/server/node.go, function Join(): compareBinaryVersion() nodeID, err := allocateNodeID() val, err := kv.IncrementValRetryable(ctx, db, keys.NodeIDGenerator, 1) db.Inc(ctx, key, inc) // pkg/kv/db.go var db *DB db.Run() db.SendAndFill() db.send() storeID, err := allocateStoreIDs() val, err := kv.IncrementValRetryable(ctx, db, keys.StoreIDGenerator, count) // create liveness record, so what is the purpose of liveness record? n.storeCfg.NodeLiveness.CreateLivenessRecord() Questions: What happen if receives Join requests? Only check version and allocate NodeID. If a node has already bootstrapted, it won’t allocate new node id again (See PreStart() for details). What should to do for adding new table? TODO Where is the master role for cockroachdb? TODO Add Replica on Store In pkg/kv/kvserver/store_create_replica.go, function getOrCreateReplica: getOrCreateReplica -&gt; tryGetOrCreateReplica // 1. current replica is removed, go back around // 2. drop messages from replica we known to be too old // 3. the current replica need to be removed, remove it and go back around // 4. drop staled msg silently // 5. check tombstone newUnloadedReplica Store::addReplicaToRangeMapLocked StateLoader::SetRangeReplicaID Replica::loadRaftMuLockedReplicaMuLocked Questions: When the new replica are created? See above. Raft Initialize Node::start Store::processRaft raftScheduler::Start async raftScheduler::worker async raftScheduler::Wait async raftTickLoop async coalescedHeartbeatsLoop run worker, in pkg/kv/kvserver/store_raft.go and pkg/kv/kvserver/replica_raft.go. raftScheduler::worker raftScheduler::processRequestQueue raftScheduler::processTick raftScheduler::processReady Store::withReplicaForRequest Store::getOrCreateReplica Store::processRaftRequestWithReplica Replica::stepRaftGroup Replica::withRaftGroup // if internal raft group is null, try create it RawNode::Step propose Node::Batch -&gt; Node::batchInternal Stores::Send(BatchRequest) -&gt; Stores::GetStore -&gt; Store::Send // `pkg/kv/kvserver/store_send.go` Clock::Update // Advances the local node's clock to a high water mark from all nodes with which it has interacted. Store::GetReplica -&gt; Replica::Send -&gt; Replica::sendWithoutRangeID // `pkg/kv/kvserver/replica_send.go` Replica::maybeInitializeRaftGroup // If the internal Raft group is not initialized, create it and wake the leader. Replica::withRaftGroupLocked Replica::maybeCampaignOnWakeLocked -&gt; Replica::campaignLocked Store::enqueueRaftUpdateCheck -&gt; raftScheduler::EnqueueRaftReady Replica::executeBatchWithConcurrencyRetries Replica::executeReadOnlyBatch Replica::executeReadWriteBatch // `pkg/kv/kvserver/replica_write.go` Replica::applyTimestampCache Replica::evalAndPropose // `pkg/kv/kvserver/replica_raft.go` Replica::requestToProposal // `pkg/kv/kvserver/replica_proposal.go` Replica::evaluateProposal -&gt; Replica::evaluateWriteBatch Replica::evaluate1PC Replica::evaluateWriteBatchWithServersideRefreshes -&gt; Replica::evaluateWriteBatchWrapper -&gt; evaluateBatch // `pkg/kv/kvserver/replica_evaluate.go` optimizePuts evaluateCommand batcheval.LookupCommand Command::EvalRO Command::EvalRW Put // `pkg/kv/kvserver/batcheval/cmd_put.go` storage.MVCCPut storage.MVCCConditionalPut // `pkg/storage/mvcc.go` Replica::propose -&gt; propBuf::Insert Replica::executeAdminBatch // No interaction with the spanlatch manager or the timestamp cache. Replica::maybeAddRangeInfoToResponse // if ranges are mismatched, try to suggest a more suitable range from this store. apply Store::processReady -&gt; Replica::HandleRaftReady -&gt; Replica::HandleRaftReadyRaftMuLocked -&gt; Replica::withRaftGroupLocked propBuf::FlushLockedWithRaftGroup // Question: will `propBuf::Insert` signal ready queue? RawNode::Ready Replica::applySnapshot Task::AckCommittedEntriesBeforeApplication // `pkg/kv/kvserver/apply/task.go` Replica::sendRaftMessagesRaftMuLocked // `pkg/kv/kvserver/replica_raft.go` Replica::append // `pkg/kv/kvserver/replica_raftstorage.go` storage.Writer::MVCCPut // Writer is `Store::Engine().NewUnindexedBatch` Batch::Commit Replica::sendRaftMessagesRaftMuLocked // `pkg/kv/kvserver/replica_raft.go` Task::ApplyCommittedEntries -&gt; Task::ApplyOneBatch Batch::Stage(Command) -&gt; replicaAppBatch::Stage // `pkg/kv/kvserver/replica_application_state_machine.go` Replica::ShouldApplyCommand Batch::ApplyToStateMachine // StateMachine::NewBatch AppliedCommand::AckOutcomeAndFinish Replica::withRaftGroupLocked RawNode::Advance(Ready) Replica::campaignLocked // if shouldCampaignAfterConfChange: if raft leader got moved, campaign the first remaning voter. Store::enqueueRaftUpdateCheck // if RawNode::HasReady Questions: Where the conditional_put is executed? In file pkg/kv/kvserver/batcheval/cmd_conditional_put.go, it is invoked by executeCommand. What is the purpose of CommandID? The command ID is equals makeIDKey() -&gt; rand.Int64(). // CmdIDKey is a Raft command id. This will be logged unredacted - keep it random. Rebalance In pkg/kv/kvserver/store.go, function Store::Start: NewStoreRebalancer StoreRebalancer::Start // rebalanceStore iterates through the top K hottest ranges on this store and // for each such range, performs a lease transfer if it determines that that // will improve QPS balance across the stores in the cluster. After it runs out // of leases to transfer away (i.e. because it couldn't find better // replacements), it considers these ranges for replica rebalancing. async StoreRebalancer::rebalanceStore StoreRebalancer::chooseLeaseToTransfer replicateQueue::transferLease StoreRebalancer::chooseRangeToRebalance DB::AdminRelocateRange]]></summary></entry><entry><title type="html">Shrinking Logs by Safely Discarding Commands</title><link href="/2022/03/31/Shrinking-Logs-by-Safely-Discarding-Commands.html" rel="alternate" type="text/html" title="Shrinking Logs by Safely Discarding Commands" /><published>2022-03-31T00:00:00+08:00</published><updated>2022-03-31T00:00:00+08:00</updated><id>/2022/03/31/Shrinking-Logs-by-Safely-Discarding-Commands</id><content type="html" xml:base="/2022/03/31/Shrinking-Logs-by-Safely-Discarding-Commands.html"><![CDATA[<h2 id="log-based-protocols">Log based protocols</h2>

<p><img src="/uploads/images/2022/shrinking-log-by-discarding-records-1.png" alt="Figure 1: log based protocols" /></p>

<p>Log 主要用于保证日志持久化、按照固定顺序复制以获得 consistent state。一个标准的 log-based protocol 需要按照一定顺序将 record 追加到 log 中，完成持久化后才响应 client。恢复时，从快照中拿到一个 index，从这个点开始回放日志，最终保证状态与恢复前一致。</p>

<h2 id="主要设计">主要设计</h2>

<p><img src="/uploads/images/2022/shrinking-log-by-discarding-records-2.png" alt="Figure 2: stable" /></p>

<p>记录到日志中的 record 之间可能存在 overwrite，比如两个相邻的 write 操作，都更新了某个 key，那么实际上只有后一个操作需要持久化。着这个思路下，每次获取一批需要持久化的 records，将他们的更新先记录到一个 hash table 上。如果存在 overwrite 的情况，只记录下最后一个 key-value。</p>

<p>通过这种方式，能够减小写入到持久化设备的 record 大小，从而增加了吞吐。</p>

<p>这篇论文实际参考价值不大，里面涉及到的设计思路实际上在工业环境中效果不大。比如在支持 MVCC 的 key value 数据库中，更新之间基本上不存在 overwrite。一些可以 merge 的操作，也大都在写 log 前完成。不过论文的 Introduction 和 Releated Work 倒是可以当作综述阅读。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Log based protocols Log 主要用于保证日志持久化、按照固定顺序复制以获得 consistent state。一个标准的 log-based protocol 需要按照一定顺序将 record 追加到 log 中，完成持久化后才响应 client。恢复时，从快照中拿到一个 index，从这个点开始回放日志，最终保证状态与恢复前一致。 主要设计 记录到日志中的 record 之间可能存在 overwrite，比如两个相邻的 write 操作，都更新了某个 key，那么实际上只有后一个操作需要持久化。着这个思路下，每次获取一批需要持久化的 records，将他们的更新先记录到一个 hash table 上。如果存在 overwrite 的情况，只记录下最后一个 key-value。 通过这种方式，能够减小写入到持久化设备的 record 大小，从而增加了吞吐。 这篇论文实际参考价值不大，里面涉及到的设计思路实际上在工业环境中效果不大。比如在支持 MVCC 的 key value 数据库中，更新之间基本上不存在 overwrite。一些可以 merge 的操作，也大都在写 log 前完成。不过论文的 Introduction 和 Releated Work 倒是可以当作综述阅读。]]></summary></entry><entry><title type="html">Achieving High Throughput and Elasticity in a Large-than-Memory Store</title><link href="/papers/2022/03/30/Achieving-High-Throughput-and-Elasticity-in-a-Large-than-Memory-Store.html" rel="alternate" type="text/html" title="Achieving High Throughput and Elasticity in a Large-than-Memory Store" /><published>2022-03-30T00:00:00+08:00</published><updated>2022-03-30T00:00:00+08:00</updated><id>/papers/2022/03/30/Achieving-High-Throughput-and-Elasticity-in-a-Large-than-Memory-Store</id><content type="html" xml:base="/papers/2022/03/30/Achieving-High-Throughput-and-Elasticity-in-a-Large-than-Memory-Store.html"><![CDATA[<h2 id="背景">背景</h2>

<p>如果数据都来自同一台机器，那么可以用导入、索引数据达到 100Mops/s 的单机 multi-core key-value stores 处理。而实际上现在有数十亿的数据需要处理，所以数据必须经过网络传输，并通过云的弹性能力创建足够的实例进行服务。为了满足这个需求，Shadowfax 在 FASTER 的基础上，构建了一个具有快速数据迁移能力的高性能分布式 key-value store。</p>

<h2 id="基本设计">基本设计</h2>

<p><img src="/uploads/images/2022/shadowfox-1.png" alt="Figure 1: shadowfox design" /></p>

<h3 id="per-core-per-thread-but-shared-everthing">Per core per thread but Shared Everthing</h3>

<p>Shadowfox 的设计目标是能够充分利用 CPU 资源，提高系统吞吐。减少核间通信、竞争是提高 CPU 资源的关键。</p>

<p>一种可行的方式是 shared nothing，每个 thread 有一个单独的 FASTER 实例，实例间互不影响。这需要路由请求到与之对应的 FASTER 线程上去，仍然不能避免跨线程协调。一个改进的方式是每个 client 和每个 server thread 都建立连接，将路由的工作交给 client 完成。但是这也要求 client 做跨线程协调，同时让连接数量暴涨。</p>

<p>Shadowfox 采用的则是 shared everthing 的方式，每个线程共享一个 FASTER 实例。FASTER 提供了一种延迟通信的机制，使得它在多核下仍能取得非常高的并发。每个 client 和一个指定的 server thread 建立 session，这个 thread 负责处理该 client 的所有请求。</p>

<p>另外一个需要考虑的是网络部分。网络收发包需要消耗大量的 CPU 资源。Shadowfox 通过将网络请求 offload 到智能卡处理，节省出来的 CPU 资源用于提升吞吐。</p>

<p>这样设计的好处是：</p>

<ul>
  <li>避免竞争。同一个 client 的请求（来自相同 session）由同一个 thread 处理，不需要跨线程协调。</li>
  <li>充分 batch，提高 pipeline。同一个 session 的请求可以充分 batch，以减少 per-packet 的开销。</li>
  <li>client 异步提交请求，避免 head-of-line blocking。因为 Shadowfox 随时会发生 reconfiguration，而 session 中的请求是有序的，发生 reconfiguration 时 client 能够知道哪些 request 一定失败。</li>
</ul>

<h3 id="hash-partition-and-view-number">Hash partition and View number</h3>

<p>Shadowfox 将数据通过 hash range 划分的方式分布到不同的 server 中。每个 server 负责服务一个 hash range。为了识别出 reconfiguration，每个 server 为当前的 hash range 计数（view number），每次 reconfiguration 发生时递增。</p>

<p>view number 需要和 reconfiguration 一起持久化到 meta server 中。</p>

<p>view number 的好处：</p>
<ul>
  <li>检查请求范围时只需要比较 view number 即可，不需要依次对比请求。</li>
  <li>允许进行异步、延迟执行的 record ownership change。</li>
</ul>

<p>第二项时通过 asynchronous global cut 实现的。所谓 asynchronous global cut，其实只是通过 epoch based protection 异步地更新 view number，并将这个变化通过 session 异步地传播给 client。这个方式非常简单，无需多说，但是要取得论文中提到的保证同一时间没有任何两个 server 服务相同区间，还需要 migration 机制参与。</p>

<blockquote>
  <p>This cut unambiguously ensures no two servers concurrently serve operations on an overlapping hash range. This approach is free of synchronous coordination, helping maintain high throughput.</p>
</blockquote>

<h3 id="migration">Migration</h3>

<p>Migration 机制可以看作两阶段提交，首先 source 发送 PrepForTransfer RPC 给 target，通知 target block 所有更大 view number 的请求。等这阶段完成后，source 就提升自己的 view number，并等待所有线程同步变更（一旦线程知道 view number 提升了，就会拒绝 staled request，交由 client 重试）。所有线程的 view number 一致后，就进入下一阶段，source 发送 TransferedOwnership RPC 给 target，这个时候 target 就开始服务请求了。</p>

<p>Shadowfox 的 migration 可以分为两个阶段，正如上文所述，需要先通过提升 view number 完成 record ownership transfer，此后再异步地传输数据给 target。</p>

<p>异步传输期间，尽管 target 已经拿到 ownership，在 source 同步这部分 record 给 target 前，它都不能服务这部分数据。</p>

<blockquote>
  <p>这中间显然有一个 gap，怎么看都不是异步的。。。</p>
</blockquote>

<p>当然，Shadowfox 为了减小这个 gap，会在开始 migration 前，对请求做一个 sampling，并将涉及到的 hot records 附带在 TransferedOwnership RPC 中一并发送给 target。这样 target 就能尽快的为 hot records 提供服务。</p>

<p>等到所有 record 都同步完成，migration 就算结束。整个过程可以组成一个状态机，如下图：</p>

<p><img src="/uploads/images/2022/shadowfox-2.png" alt="Figure 2: Migration states" /></p>

<p>一部分 record 可能没有在内存中，在 SSD 里，Shadowfox 可以将这部分 record 写到共享存储上，这样 target 就可以直接读取这部分 record 而不是等 source 复制给它。</p>

<h4 id="fault-tolerance">Fault tolerance</h4>

<p>为了保证容错，source 和 target 在标记 complete 前，需要创建一份 checkpoint，如果之后任何一台机器故障，都可以通过 checkpoint 恢复数据。如果时在迁移过程中发生了故障，则 shadowfox 会取消迁移操作，并将迁移涉及到的 hash range 迁移回 source。</p>

<p>如果某个机器不可用，shadowfox 需要从这条机器撤销其 record 的所有权，这是通过 lease 完成的。</p>

<h2 id="评估">评估</h2>

<p><img src="/uploads/images/2022/shadowfox-3.png" alt="Figure 3: throughput during migrate" /></p>

<p>看起来 migrate 和 scale up 仍然对 throughput 有较大影响。</p>

<p><img src="/uploads/images/2022/shadowfox-4.png" alt="Figure 4: Number of pending operations during scale up" /></p>

<p>同时看起来在迁移过程中，被 block 的请求数量也不少。</p>]]></content><author><name></name></author><category term="papers" /><category term="live-migration," /><category term="shared-everything," /><category term="epoch-based-protection" /><summary type="html"><![CDATA[背景 如果数据都来自同一台机器，那么可以用导入、索引数据达到 100Mops/s 的单机 multi-core key-value stores 处理。而实际上现在有数十亿的数据需要处理，所以数据必须经过网络传输，并通过云的弹性能力创建足够的实例进行服务。为了满足这个需求，Shadowfax 在 FASTER 的基础上，构建了一个具有快速数据迁移能力的高性能分布式 key-value store。 基本设计 Per core per thread but Shared Everthing Shadowfox 的设计目标是能够充分利用 CPU 资源，提高系统吞吐。减少核间通信、竞争是提高 CPU 资源的关键。 一种可行的方式是 shared nothing，每个 thread 有一个单独的 FASTER 实例，实例间互不影响。这需要路由请求到与之对应的 FASTER 线程上去，仍然不能避免跨线程协调。一个改进的方式是每个 client 和每个 server thread 都建立连接，将路由的工作交给 client 完成。但是这也要求 client 做跨线程协调，同时让连接数量暴涨。 Shadowfox 采用的则是 shared everthing 的方式，每个线程共享一个 FASTER 实例。FASTER 提供了一种延迟通信的机制，使得它在多核下仍能取得非常高的并发。每个 client 和一个指定的 server thread 建立 session，这个 thread 负责处理该 client 的所有请求。 另外一个需要考虑的是网络部分。网络收发包需要消耗大量的 CPU 资源。Shadowfox 通过将网络请求 offload 到智能卡处理，节省出来的 CPU 资源用于提升吞吐。 这样设计的好处是： 避免竞争。同一个 client 的请求（来自相同 session）由同一个 thread 处理，不需要跨线程协调。 充分 batch，提高 pipeline。同一个 session 的请求可以充分 batch，以减少 per-packet 的开销。 client 异步提交请求，避免 head-of-line blocking。因为 Shadowfox 随时会发生 reconfiguration，而 session 中的请求是有序的，发生 reconfiguration 时 client 能够知道哪些 request 一定失败。 Hash partition and View number Shadowfox 将数据通过 hash range 划分的方式分布到不同的 server 中。每个 server 负责服务一个 hash range。为了识别出 reconfiguration，每个 server 为当前的 hash range 计数（view number），每次 reconfiguration 发生时递增。 view number 需要和 reconfiguration 一起持久化到 meta server 中。 view number 的好处： 检查请求范围时只需要比较 view number 即可，不需要依次对比请求。 允许进行异步、延迟执行的 record ownership change。 第二项时通过 asynchronous global cut 实现的。所谓 asynchronous global cut，其实只是通过 epoch based protection 异步地更新 view number，并将这个变化通过 session 异步地传播给 client。这个方式非常简单，无需多说，但是要取得论文中提到的保证同一时间没有任何两个 server 服务相同区间，还需要 migration 机制参与。 This cut unambiguously ensures no two servers concurrently serve operations on an overlapping hash range. This approach is free of synchronous coordination, helping maintain high throughput. Migration Migration 机制可以看作两阶段提交，首先 source 发送 PrepForTransfer RPC 给 target，通知 target block 所有更大 view number 的请求。等这阶段完成后，source 就提升自己的 view number，并等待所有线程同步变更（一旦线程知道 view number 提升了，就会拒绝 staled request，交由 client 重试）。所有线程的 view number 一致后，就进入下一阶段，source 发送 TransferedOwnership RPC 给 target，这个时候 target 就开始服务请求了。 Shadowfox 的 migration 可以分为两个阶段，正如上文所述，需要先通过提升 view number 完成 record ownership transfer，此后再异步地传输数据给 target。 异步传输期间，尽管 target 已经拿到 ownership，在 source 同步这部分 record 给 target 前，它都不能服务这部分数据。 这中间显然有一个 gap，怎么看都不是异步的。。。 当然，Shadowfox 为了减小这个 gap，会在开始 migration 前，对请求做一个 sampling，并将涉及到的 hot records 附带在 TransferedOwnership RPC 中一并发送给 target。这样 target 就能尽快的为 hot records 提供服务。 等到所有 record 都同步完成，migration 就算结束。整个过程可以组成一个状态机，如下图： 一部分 record 可能没有在内存中，在 SSD 里，Shadowfox 可以将这部分 record 写到共享存储上，这样 target 就可以直接读取这部分 record 而不是等 source 复制给它。 Fault tolerance 为了保证容错，source 和 target 在标记 complete 前，需要创建一份 checkpoint，如果之后任何一台机器故障，都可以通过 checkpoint 恢复数据。如果时在迁移过程中发生了故障，则 shadowfox 会取消迁移操作，并将迁移涉及到的 hash range 迁移回 source。 如果某个机器不可用，shadowfox 需要从这条机器撤销其 record 的所有权，这是通过 lease 完成的。 评估 看起来 migrate 和 scale up 仍然对 throughput 有较大影响。 同时看起来在迁移过程中，被 block 的请求数量也不少。]]></summary></entry><entry><title type="html">OpLog - a library for scaling update heavy data structures</title><link href="/2022/03/30/OpLog-a-library-for-scaling-update-heavy-data-structures.html" rel="alternate" type="text/html" title="OpLog - a library for scaling update heavy data structures" /><published>2022-03-30T00:00:00+08:00</published><updated>2022-03-30T00:00:00+08:00</updated><id>/2022/03/30/OpLog-a-library-for-scaling-update-heavy-data-structures</id><content type="html" xml:base="/2022/03/30/OpLog-a-library-for-scaling-update-heavy-data-structures.html"><![CDATA[<h2 id="背景">背景</h2>

<p>在 multi-core scaling read-heavy data structure 上已经有了很多有用的技术，比如 Read-copy-update。但是 update-heavy 的数据结构还鲜有通用的方案。显然，对于 update-heavy 的数据结构来说，只要在读之前，将数据准备好就行。OpLog 针对这部分场景，提出了一种通用的 scaling update-heavy data structures 实现方式。</p>

<h2 id="思路">思路</h2>

<p>OpLog 的解决办法是为每个数据结构准备一个 per-core 的日志，写操作只需要将其追加到日志中即可。在读时，按照时间顺序合并日志并应用到数据结构上。这样的设计方式有几个好处：</p>

<ul>
  <li>Batching updates：通过延迟执行，很多 update 操作可以直接合并，计数操作，原来的 N 次 +1 操作可以合并为一次 +N</li>
  <li>Absorbing updates: 比如先执行 put，之后 delete，那么无需执行任何操作</li>
</ul>

<p>OpLog 作为一种通用的设计思路，还需要考虑到尽管某个实现需要解决 update-heavy 的问题，但是只有少数 update-heavy 的实例才会通过 OpLog 收益，多数情况下 per-core 的日志对这部分实例是一个负担。OpLog 只对最近使用过的对象设置 log，如果一个对象长期未更新，那么 OpLog 可以回收这部分空间。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Counter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Object</span><span class="o">&lt;</span><span class="n">CounterLog</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">IncOp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Op</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">exec</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">struct</span> <span class="nc">DecOp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Op</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">exec</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">inc</span><span class="p">()</span> <span class="p">{</span> <span class="n">log</span><span class="p">(</span><span class="n">IncOp</span><span class="p">());</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">dec</span><span class="p">()</span> <span class="p">{</span> <span class="n">log</span><span class="p">(</span><span class="n">DecOp</span><span class="p">());</span> <span class="p">}</span>

    <span class="kt">uint64_t</span> <span class="n">read</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">synchronize</span><span class="p">();</span>
        <span class="kt">uint64_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">val_</span><span class="p">;</span>
        <span class="n">unlock</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">uint64_t</span> <span class="n">val_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">CounterLog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Log</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">Op</span><span class="o">*</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">exec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val_</span><span class="p">);</span> <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">CounterLog</span><span class="o">*</span> <span class="n">qs</span><span class="p">[],</span> <span class="n">Counter</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">for_each_log</span><span class="p">(</span><span class="n">CounterLog</span><span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="n">qs</span><span class="p">)</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">val_</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">uint64_t</span> <span class="n">val_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>论文中有使用 OpLog 实现 Counter 的例子。<code class="language-plaintext highlighter-rouge">inc</code> 和 <code class="language-plaintext highlighter-rouge">dec</code> 操作生成一个 OP 并记录到 log 中，读操作需要先加锁，合并 log 并应用到 counter 上，再返回 <code class="language-plaintext highlighter-rouge">val_</code>。</p>

<h2 id="评估">评估</h2>

<p>一般会认为 OpLog 的实现对 read 不友好。不过论文也做了一个 benchmark。</p>

<p><img src="/uploads/images/2022/OpLog-update-heavy-data-structures.png" alt="Figure 1 fork-turncate" /></p>

<p>结果显示，OpLog 对一些 read periodically 的数据结构也有性能改善。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[背景 在 multi-core scaling read-heavy data structure 上已经有了很多有用的技术，比如 Read-copy-update。但是 update-heavy 的数据结构还鲜有通用的方案。显然，对于 update-heavy 的数据结构来说，只要在读之前，将数据准备好就行。OpLog 针对这部分场景，提出了一种通用的 scaling update-heavy data structures 实现方式。 思路 OpLog 的解决办法是为每个数据结构准备一个 per-core 的日志，写操作只需要将其追加到日志中即可。在读时，按照时间顺序合并日志并应用到数据结构上。这样的设计方式有几个好处： Batching updates：通过延迟执行，很多 update 操作可以直接合并，计数操作，原来的 N 次 +1 操作可以合并为一次 +N Absorbing updates: 比如先执行 put，之后 delete，那么无需执行任何操作 OpLog 作为一种通用的设计思路，还需要考虑到尽管某个实现需要解决 update-heavy 的问题，但是只有少数 update-heavy 的实例才会通过 OpLog 收益，多数情况下 per-core 的日志对这部分实例是一个负担。OpLog 只对最近使用过的对象设置 log，如果一个对象长期未更新，那么 OpLog 可以回收这部分空间。 struct Counter : public Object&lt;CounterLog&gt; { struct IncOp : public Op { void exec(uint64_t* v) { *v = *v + 1; } } struct DecOp : public Op { void exec(uint64_t* v) { *v = *v - 1; } } void inc() { log(IncOp()); } void dec() { log(DecOp()); } uint64_t read() { synchronize(); uint64_t r = val_; unlock(); return r; } uint64_t val_; }; struct CounterLog : public Log { void push(Op* op) { op-&gt;exec(&amp;val_); } static void apply(CounterLog* qs[], Counter* c) { for_each_log(CounterLog* q, qs) c-&gt;val_ += q-&gt;val_; } uint64_t val_; }; 论文中有使用 OpLog 实现 Counter 的例子。inc 和 dec 操作生成一个 OP 并记录到 log 中，读操作需要先加锁，合并 log 并应用到 counter 上，再返回 val_。 评估 一般会认为 OpLog 的实现对 read 不友好。不过论文也做了一个 benchmark。 结果显示，OpLog 对一些 read periodically 的数据结构也有性能改善。]]></summary></entry><entry><title type="html">HotRing - A Hotspot Aware In-Memory Key-Value Store</title><link href="/papers/2022/03/29/HotRing-A-Hotspot-Aware-In-Memory-Key-Value-Store.html" rel="alternate" type="text/html" title="HotRing - A Hotspot Aware In-Memory Key-Value Store" /><published>2022-03-29T00:00:00+08:00</published><updated>2022-03-29T00:00:00+08:00</updated><id>/papers/2022/03/29/HotRing-A-Hotspot-Aware-In-Memory-Key-Value-Store</id><content type="html" xml:base="/papers/2022/03/29/HotRing-A-Hotspot-Aware-In-Memory-Key-Value-Store.html"><![CDATA[<p>在 Alibaba 的生产环境中，KVS 的请求里有 50%-90% 只访问了 1% 的数据。如下图：</p>

<p><img src="/uploads/images/2022/hotring-1.png" alt="Figure 1: Access ratio of different keys." /></p>

<p>实现 KVS 有很多可用的索引结构，其中 HASH 用得最多。目前的 HASH 算法并没有优化热点访问，也就是说读取一条热点数据，所付出的代价和读取其他数据是一样的。如下图，传统 HASH INDEX 结构的热点数据可能分布在 collision chaining 的任意位置。</p>

<p><img src="/uploads/images/2022/hotring-2.png" alt="Figure 2: The conventional hash index structure" /></p>

<p>理想情况下，查找一条数据的内存访问次数应该和它的冷热层度负相关。</p>

<p><img src="/uploads/images/2022/hotring-3.png" alt="Figure 3: Expected memory accesses for an index lookup" /></p>

<p>想要达到理想的情况，需要解决两个问题：</p>
<ol>
  <li>检测并适应 hotspot shift</li>
  <li>concurrent access</li>
</ol>

<h2 id="hotring">HotRing</h2>

<p>论文的做法是：针对问题 1，将传统哈希表中的 collision chain 替换成 ordered-ring。如果热点发生迁移，那么直接将 bucket header 指向新的热点 item 即可。针对问题 2，采用 lock-free 设计。</p>

<p><img src="/uploads/images/2022/hotring-4.png" alt="Figure 4: The index structure of HotRing" /></p>

<p>ordered ring 的结构如上图所示，整个 ring 首尾相连，一旦发现热点迁移，只需要将 bucket 的 header 更新到新热点 item 即可。这样做的好处是热点迁移时无需重新给 ring 上数据排序。</p>

<p>查找时从 header 开始，遍历整个 ring ；同时 Ring 上的数据会按照 <code class="language-plaintext highlighter-rouge">&lt;tag, key&gt;</code> 的顺序插入到合适的位置。这样做的目的是：</p>
<ul>
  <li>tag 主要用来避免对 key 的比较</li>
  <li>顺序则是用于查询时判断 ring 是否结束，否则查找时可能会受到并发更新操作的影响，无法判断是否已经遍历完整个 ring。</li>
</ul>

<p><img src="/uploads/images/2022/hotring-5.png" alt="Figure 5: Lookup Termination" /></p>

<p>此外，排序还有另一个好处，根据 termination 条件，平均查找次数约为传统 collision chain 实现方式的一半。</p>

<h2 id="hotspot-shift-identification">Hotspot Shift Identification</h2>

<p>由于 hash 的 strongly uniformed distribution，可以认为热点数据也分布在各个 bucket 中，热点迁移识别的工作主要在 bucket 内部。</p>

<p>论文提出了两种识别方式：</p>
<ol>
  <li>random movement</li>
  <li>statistical sampling</li>
</ol>

<p>第一种方式是每隔 R 个请求，如果第 R 个请求是 hot access，则不做任何改变；如果第 R 个请求是 cold access ，那么这个请求对应的 item 会成为新的 hot item。</p>

<p>这种方式是一个简单的概率实现，其缺点也非常明显：参数 R 的大小显著影响热点识别效果；如果数据访问频率分布是均匀的，或者 collision ring 中有多个热点，那么 head pointer 可能会频繁在这些热点中跳变；</p>

<p>另一种方式则是在 item 里记录下访问次数，根据次数选择出合适的 item 来作为新的 hot item。</p>

<blockquote>
  <p>猜想：是否可以使用 thread-local 级别的数据采样算法，来得到更为精确的数据，同时也避免了不必要的 CAS 操作？</p>
</blockquote>

<p><img src="/uploads/images/2022/hotring-6.png" alt="Figure 6: Index Format" /></p>

<p>如上图所示，每个 head pointer 的前 16bits 和 item pointer 其中的 14 bits 用于存储采样信息。其中 Active 表示在这条 collision ring 上开启采样，它主要是为了进行优化：为了确保采样不对正常读写造成影响，默认情况下 Active 为 false；每 R 个请求进行一次判断，如果仍然是 hot access，则认为目前的 hot item 仍然是准确的；否则才设置 Active 为 true。一旦 Active 被设置，后续请求需要同时使用 CAS 更新 Total Counter 和 Item 的 Counter。</p>

<p>采样完成后，最后一个访问的线程负责计算 collision ring 上每个 item 的访问频率，并调整 hot item。（先清除 Active 的标记）</p>

<h3 id="write-intensive-hotspot-with-rcu">Write-Intensive Hotspot with RCU</h3>

<p>HotRing 上的 key 是通过 read-copy-update 操作进行的。更改一个 key 时，需要遍历整个 collision ring ，找到待更新的 key 的前项，并更改其指针到新 item 上。所以更新操作的 Counter 应该需要记录到 hot item 的前一项中，这样算法就会选择前一项作为 hot item，因更新操作所需要的访问次数也因此降低。</p>

<p><img src="/uploads/images/2022/hotring-7.png" alt="Figure 7: Update a Hot Item A with RCU makes item F hot" /></p>

<h2 id="concurrent">Concurrent</h2>

<ul>
  <li>read: 读操作从 head pointer 开始遍历 HotRing，直到碰到终止条件</li>
  <li>insert: 找到合适位置，更新前一项的 Next Item Address 即可</li>
</ul>

<p>update 和 deletion 会复杂一些。对于 update，如果 value 在 8 字节内，可以直接通过 CAS 进行 in-place 更新。否则，需要使用两阶段提交的策略来避免异常。</p>

<p><img src="/uploads/images/2022/hotring-8.png" alt="Figure 8: Concurrent issues" /></p>

<p>如果 read-copy-update 和其他更新操作同时执行，就会上图所示的异常。以 RCU Update &amp; Insert 为例，由于 update B 和 insert C 同时进行，C 负责更新 B 的 Next Item Address，而此时 B’ 更新了 A 的 Next Item Address，最终 C 丢失，无法被访问。</p>

<p>解决方式是在 update\delete 某个 item 时，先标记上 Occupied bit，这样其他尝试更新该 Next Item Address 的请求会失败并进行重试，所以后续对这个 Item 进行的操作就是安全的。</p>

<h3 id="head-pointer-movement">Head Pointer Movement</h3>

<p>head pointer 同样也会受到并发操作的影响，主要有两种情况：</p>
<ol>
  <li>热点迁移导致的 head pointer 更新</li>
  <li>其他 update 和 deletion 操作</li>
</ol>

<p>对于 case 1，head pointer 在迁移前，需要设置新 hot item 为 Occupied 保证这个过程中该节点不会被 update 或 delete。</p>

<p>对于 update head pointer 指向的 item，只需要在替换时设置上新 item 的 Occupied 即可；对于 delete head pointer 指向的 item，还需要设置 head pointer 指向的新 item 的 Occupied。</p>

<h2 id="lock-free-rehash">Lock free Rehash</h2>

<p>传统的 Hash Table 使用 load factor 来出发 rehash，这个过程显然没有考虑到 hotspot 的影响。HotRing 使用 access overhead 来出发 rehash。</p>

<p>由于 HotRing 是有序的，rehash 时只需要从中间某个位置断开，生成两个新的 HotRing 即可。这个阶段主要分为三步：</p>

<p><img src="/uploads/images/2022/hotring-9.png" alt="Figure 9: Rehash" /></p>

<h2 id="评估">评估</h2>

<p>略</p>]]></content><author><name></name></author><category term="papers" /><category term="concurrent" /><summary type="html"><![CDATA[在 Alibaba 的生产环境中，KVS 的请求里有 50%-90% 只访问了 1% 的数据。如下图： 实现 KVS 有很多可用的索引结构，其中 HASH 用得最多。目前的 HASH 算法并没有优化热点访问，也就是说读取一条热点数据，所付出的代价和读取其他数据是一样的。如下图，传统 HASH INDEX 结构的热点数据可能分布在 collision chaining 的任意位置。 理想情况下，查找一条数据的内存访问次数应该和它的冷热层度负相关。 想要达到理想的情况，需要解决两个问题： 检测并适应 hotspot shift concurrent access HotRing 论文的做法是：针对问题 1，将传统哈希表中的 collision chain 替换成 ordered-ring。如果热点发生迁移，那么直接将 bucket header 指向新的热点 item 即可。针对问题 2，采用 lock-free 设计。 ordered ring 的结构如上图所示，整个 ring 首尾相连，一旦发现热点迁移，只需要将 bucket 的 header 更新到新热点 item 即可。这样做的好处是热点迁移时无需重新给 ring 上数据排序。 查找时从 header 开始，遍历整个 ring ；同时 Ring 上的数据会按照 &lt;tag, key&gt; 的顺序插入到合适的位置。这样做的目的是： tag 主要用来避免对 key 的比较 顺序则是用于查询时判断 ring 是否结束，否则查找时可能会受到并发更新操作的影响，无法判断是否已经遍历完整个 ring。 此外，排序还有另一个好处，根据 termination 条件，平均查找次数约为传统 collision chain 实现方式的一半。 Hotspot Shift Identification 由于 hash 的 strongly uniformed distribution，可以认为热点数据也分布在各个 bucket 中，热点迁移识别的工作主要在 bucket 内部。 论文提出了两种识别方式： random movement statistical sampling 第一种方式是每隔 R 个请求，如果第 R 个请求是 hot access，则不做任何改变；如果第 R 个请求是 cold access ，那么这个请求对应的 item 会成为新的 hot item。 这种方式是一个简单的概率实现，其缺点也非常明显：参数 R 的大小显著影响热点识别效果；如果数据访问频率分布是均匀的，或者 collision ring 中有多个热点，那么 head pointer 可能会频繁在这些热点中跳变； 另一种方式则是在 item 里记录下访问次数，根据次数选择出合适的 item 来作为新的 hot item。 猜想：是否可以使用 thread-local 级别的数据采样算法，来得到更为精确的数据，同时也避免了不必要的 CAS 操作？ 如上图所示，每个 head pointer 的前 16bits 和 item pointer 其中的 14 bits 用于存储采样信息。其中 Active 表示在这条 collision ring 上开启采样，它主要是为了进行优化：为了确保采样不对正常读写造成影响，默认情况下 Active 为 false；每 R 个请求进行一次判断，如果仍然是 hot access，则认为目前的 hot item 仍然是准确的；否则才设置 Active 为 true。一旦 Active 被设置，后续请求需要同时使用 CAS 更新 Total Counter 和 Item 的 Counter。 采样完成后，最后一个访问的线程负责计算 collision ring 上每个 item 的访问频率，并调整 hot item。（先清除 Active 的标记） Write-Intensive Hotspot with RCU HotRing 上的 key 是通过 read-copy-update 操作进行的。更改一个 key 时，需要遍历整个 collision ring ，找到待更新的 key 的前项，并更改其指针到新 item 上。所以更新操作的 Counter 应该需要记录到 hot item 的前一项中，这样算法就会选择前一项作为 hot item，因更新操作所需要的访问次数也因此降低。 Concurrent read: 读操作从 head pointer 开始遍历 HotRing，直到碰到终止条件 insert: 找到合适位置，更新前一项的 Next Item Address 即可 update 和 deletion 会复杂一些。对于 update，如果 value 在 8 字节内，可以直接通过 CAS 进行 in-place 更新。否则，需要使用两阶段提交的策略来避免异常。 如果 read-copy-update 和其他更新操作同时执行，就会上图所示的异常。以 RCU Update &amp; Insert 为例，由于 update B 和 insert C 同时进行，C 负责更新 B 的 Next Item Address，而此时 B’ 更新了 A 的 Next Item Address，最终 C 丢失，无法被访问。 解决方式是在 update\delete 某个 item 时，先标记上 Occupied bit，这样其他尝试更新该 Next Item Address 的请求会失败并进行重试，所以后续对这个 Item 进行的操作就是安全的。 Head Pointer Movement head pointer 同样也会受到并发操作的影响，主要有两种情况： 热点迁移导致的 head pointer 更新 其他 update 和 deletion 操作 对于 case 1，head pointer 在迁移前，需要设置新 hot item 为 Occupied 保证这个过程中该节点不会被 update 或 delete。 对于 update head pointer 指向的 item，只需要在替换时设置上新 item 的 Occupied 即可；对于 delete head pointer 指向的 item，还需要设置 head pointer 指向的新 item 的 Occupied。 Lock free Rehash 传统的 Hash Table 使用 load factor 来出发 rehash，这个过程显然没有考虑到 hotspot 的影响。HotRing 使用 access overhead 来出发 rehash。 由于 HotRing 是有序的，rehash 时只需要从中间某个位置断开，生成两个新的 HotRing 即可。这个阶段主要分为三步： 评估 略]]></summary></entry><entry><title type="html">探究 Linux 下 TCP 的 RST Packet</title><link href="/network/2019/01/26/Linux-TCP-Rst.html" rel="alternate" type="text/html" title="探究 Linux 下 TCP 的 RST Packet" /><published>2019-01-26T15:13:00+08:00</published><updated>2019-01-26T15:13:00+08:00</updated><id>/network/2019/01/26/Linux-TCP-Rst</id><content type="html" xml:base="/network/2019/01/26/Linux-TCP-Rst.html"><![CDATA[<blockquote>
  <p>注：<strong>本文结论来自网络，真实性未考究，请批判性阅读，如果谬误，请斧正。</strong>本文所讨论内容，均假设工作环境为 Linux 服务器。</p>
</blockquote>

<p>作为 TCP 不可或缺的一部分，TCP 包头的 <code class="language-plaintext highlighter-rouge">RST</code> 为 $1$ 时，表示重置，关闭异常链接。发送 RST 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送 <code class="language-plaintext highlighter-rouge">RST</code> 包。而接收端收到 <code class="language-plaintext highlighter-rouge">RST</code> 包后，也不必发送 <code class="language-plaintext highlighter-rouge">ACK</code> 包来确认。TCP 处理程序会在自己认为的异常时刻发送 <code class="language-plaintext highlighter-rouge">RST</code> 包。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>14:59:23.379829 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>R], <span class="nb">seq </span>4127385762, win 0, length 0
</code></pre></div></div>

<p><em>通过 tcpdump 观察，<code class="language-plaintext highlighter-rouge">Flags [R]</code> 表示该包携带了 <code class="language-plaintext highlighter-rouge">RST</code> 。</em></p>

<p><code class="language-plaintext highlighter-rouge">RST</code> 主要用在三种场景中，保证 TCP 链接的安全性，三种场景分别是：1、到不存在端口的连接请求；2、异常终止连接；3、检测半打开连接。接下来看看 <code class="language-plaintext highlighter-rouge">RST</code> 的具体表现。</p>

<h1 id="三种错误">三种错误</h1>

<p>内核中的 TCP 协议栈将收到 <code class="language-plaintext highlighter-rouge">RST</code> 的场景分为三种，并抛出了对应的错误。</p>

<h2 id="connection-refused">connection refused</h2>

<p>当内核中的 TCP 协议栈收到了 <code class="language-plaintext highlighter-rouge">SYN</code> 请求，但是该端口上没有处于监听状态，则相应 <code class="language-plaintext highlighter-rouge">RST</code>，此时 client 看到的便是 <code class="language-plaintext highlighter-rouge">connection refused</code>。</p>

<h2 id="broken-pipe">broken pipe</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">fd</code> is connected to a pipe or socket whose reading end is closed.  When this happens the writing process will also receive a SIGPIPE signal.(Thus, the write return value is seen only if the program catches, blocks or ignores this signal.)</p>
</blockquote>

<p>简单的说，如果<strong>已知</strong>远端读通道已经被关闭，而应用程序仍然在调用 <code class="language-plaintext highlighter-rouge">write</code>(2) 尝试向 socket 中写入数据，TCP 协议栈便会抛出 <code class="language-plaintext highlighter-rouge">broken pipe</code>。</p>

<h2 id="connection-reset-by-peer">connection reset by peer</h2>

<blockquote>
  <p>A network connection was closed for reasons outside the control of the local host, such as by the remote machine rebooting or an unrecoverable protocol violation.</p>
</blockquote>

<p>如果远端已经 <code class="language-plaintext highlighter-rouge">close</code>(2) 连接了，本地服务仍发送了数据，此时 TCP 协议栈便会抛出 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<h1 id="broken-pipe-和-connection-reset-by-peer">broken pipe 和 connection reset by peer</h1>

<p>无论是 <code class="language-plaintext highlighter-rouge">broken pipe</code> 还是 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>，都是收到 <code class="language-plaintext highlighter-rouge">RST</code> 的表现，二者有何不同呢？</p>

<p>为了进一步研究，这里尝试着构建两个场景，分别重现 <code class="language-plaintext highlighter-rouge">broken pipe</code> 和 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<h2 id="重现-broken-pipe">重现 broken pipe</h2>

<p>首先，在服务中监听端口，每个连接分多次写入数据，然后关闭连接。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">server</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Acceptor</span> <span class="n">acceptor</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="n">InetAddress</span><span class="o">::</span><span class="n">parseV4</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">9490</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg1</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">,</span> <span class="o">*</span><span class="n">msg2</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">acceptor</span><span class="p">.</span><span class="n">accept</span><span class="p">();</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                        <span class="c1">// wait client shutdown</span>
        <span class="n">conn</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg1</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg1</span><span class="p">));</span>  <span class="c1">// write success, but RST recieved</span>
        <span class="n">conn</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg2</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg2</span><span class="p">));</span>  <span class="c1">// throw `broken pipe`</span>
    <span class="p">}</span> <span class="c1">// RAII close conn socket</span>
<span class="p">}</span> <span class="c1">// RAII close acceptor socket</span>
</code></pre></div></div>

<p>然后客户端连接到服务端，并立即关闭连接。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">client</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Connector</span> <span class="n">connector</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="n">InetAddress</span><span class="o">::</span><span class="n">parseV4</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">9490</span><span class="p">);</span>
    <span class="n">connector</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// RAII close connector socket</span>
</code></pre></div></div>

<p>通过 tcpdump 观察程序运行时请求：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>tcpdump <span class="nt">-i</span> lo <span class="s1">'(src host 127.0.0.1) and (port 9490)'</span>  <span class="nt">-B</span> 4096
14:59:13.376906 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>S], <span class="nb">seq </span>4127385760, win 43690, options <span class="o">[</span>mss 65495,sackOK,TS val 168040030 ecr 0,nop,wscale 10], length 0
14:59:13.376919 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>S.], <span class="nb">seq </span>2306780414, ack 4127385761, win 43690, options <span class="o">[</span>mss 65495,sackOK,TS val 168040030 ecr 168040030,nop,wscale 10], length 0
14:59:13.376928 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 1, win 43, options <span class="o">[</span>nop,nop,TS val 168040030 ecr 168040030], length 0
14:59:13.377089 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>P.], <span class="nb">seq </span>1:2, ack 1, win 43, options <span class="o">[</span>nop,nop,TS val 168040030 ecr 168040030], length 1
14:59:13.377223 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 2, win 43, options <span class="o">[</span>nop,nop,TS val 168040030 ecr 168040030], length 0
14:59:14.377352 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>P.], <span class="nb">seq </span>2:3, ack 1, win 43, options <span class="o">[</span>nop,nop,TS val 168040280 ecr 168040030], length 1
14:59:14.377439 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 3, win 43, options <span class="o">[</span>nop,nop,TS val 168040280 ecr 168040280], length 0
// ....
14:59:22.379462 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>P.], <span class="nb">seq </span>10:11, ack 1, win 43, options <span class="o">[</span>nop,nop,TS val 168042281 ecr 168042031], length 1
14:59:22.379489 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 11, win 43, options <span class="o">[</span>nop,nop,TS val 168042281 ecr 168042281], length 0
14:59:22.379626 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>F.], <span class="nb">seq </span>1, ack 11, win 43, options <span class="o">[</span>nop,nop,TS val 168042281 ecr 168042281], length 0
14:59:22.382190 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>.], ack 2, win 43, options <span class="o">[</span>nop,nop,TS val 168042282 ecr 168042281], length 0
14:59:23.379808 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>P.], <span class="nb">seq </span>11:12, ack 2, win 43, options <span class="o">[</span>nop,nop,TS val 168042531 ecr 168042281], length 1
14:59:23.379829 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>R], <span class="nb">seq </span>4127385762, win 0, length 0
</code></pre></div></div>

<p><em>上述 log 为实验过程中，和上面上面的代码略有出入。</em></p>

<p>可以观察到，client <code class="language-plaintext highlighter-rouge">close</code>(2)，发送了 <code class="language-plaintext highlighter-rouge">FIN</code> 给 server，并收到了 <code class="language-plaintext highlighter-rouge">ACK</code>。server 此时再次尝试 <code class="language-plaintext highlighter-rouge">write</code>(2)，便抛出了 <code class="language-plaintext highlighter-rouge">broken pipe</code> 异常。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">server</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em><code class="language-plaintext highlighter-rouge">server</code> 调用方式。</em></p>

<h3 id="sigpipe-与-broken-pipe">SIGPIPE 与 broken pipe</h3>

<p>按照预期，当 socket 抛出 <code class="language-plaintext highlighter-rouge">broken pipe</code> 时，会被最外层 <code class="language-plaintext highlighter-rouge">try</code> 和 <code class="language-plaintext highlighter-rouge">catch</code> 抓住，并输出。实际上运行结果为：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./server
<span class="nv">$ </span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
141
<span class="nv">$ </span>
</code></pre></div></div>

<p><em>某次 server 端运行结果，没有任何输出，程序返回值为 $141$。</em></p>

<p>内核中 TCP 栈如果已经接收到 <code class="language-plaintext highlighter-rouge">RST</code>，那么下一次使用 <code class="language-plaintext highlighter-rouge">write</code>(2) 时，除了会返回 <code class="language-plaintext highlighter-rouge">broken pipe</code> 外，还会产生 <code class="language-plaintext highlighter-rouge">SIGPIPE</code>，默认情况下这个信号会终止整个进程，当然你并不想让进程被 <code class="language-plaintext highlighter-rouge">SIGPIPE</code> 信号杀死。对 server 来说，为了不被 <code class="language-plaintext highlighter-rouge">SIGPIPE</code> 信号杀死，那就需要忽略 <code class="language-plaintext highlighter-rouge">SIGPIPE</code> 信号：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
</code></pre></div></div>

<p>最后，让我们整体分析下 <code class="language-plaintext highlighter-rouge">broken pipe</code> 产生方式：</p>

<ol>
  <li>client 发送了 <code class="language-plaintext highlighter-rouge">FIN</code> 给 server；</li>
  <li>server 仍给 client 发送数据，client 回复 <code class="language-plaintext highlighter-rouge">RST</code>；</li>
  <li>server 收到 <code class="language-plaintext highlighter-rouge">RST</code> 后，再次给 client 发送数据；往一个已经收到 <code class="language-plaintext highlighter-rouge">RST</code> 的 socket 继续写入数据，将引起 <code class="language-plaintext highlighter-rouge">SIGPIPE</code> 信号，<code class="language-plaintext highlighter-rouge">write</code>(2) 返回 <code class="language-plaintext highlighter-rouge">EPIPE</code>。</li>
</ol>

<h2 id="重现-connection-reset-by-peer">重现 <code class="language-plaintext highlighter-rouge">connection reset by peer</code></h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">server</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Acceptor</span> <span class="n">acceptor</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="n">InetAddress</span><span class="o">::</span><span class="n">parseV4</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">9490</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">acceptor</span><span class="p">.</span><span class="n">accept</span><span class="p">();</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>                       <span class="c1">// 给拔网线留下足够的时间</span>
    <span class="p">}</span> <span class="c1">// RAII close conn socket</span>
<span class="p">}</span> <span class="c1">// RAII close acceptor socket</span>
</code></pre></div></div>

<p><em>模拟服务端断线重启。</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">client</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Connector</span> <span class="n">connector</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="n">InetAddress</span><span class="o">::</span><span class="n">parseV4</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">9490</span><span class="p">);</span>
    <span class="n">connector</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">120</span><span class="p">);</span> 

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
    <span class="n">connector</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
<span class="p">}</span> <span class="c1">// RAII close connector socket</span>
</code></pre></div></div>

<p><em>一段时间后，再给服务器发送请求，此时服务器已经重启。</em></p>

<p>这里构造了这样一个场景，与客户端建立连接后，服务端由于不可抗力，比如断电，未能发送 <code class="language-plaintext highlighter-rouge">FIN</code> 给客户端。当服务器重启后，内核中 TCP 协议栈收到了客户端的数据包，回应 <code class="language-plaintext highlighter-rouge">RST</code>，此时客户端抛出 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>tcpdump <span class="nt">-i</span> lo <span class="s1">'(src host 127.0.0.1) and (port 9490)'</span>  <span class="nt">-B</span> 4096
15:43:12.638464 IP localhost.21316 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>S], <span class="nb">seq </span>3640034867, win 43690, options <span class="o">[</span>mss 65495,sackOK,TS val 168699846 ecr 0,nop,wscale 10], length 0
15:43:12.638478 IP localhost.9490 <span class="o">&gt;</span> localhost.21316: Flags <span class="o">[</span>S.], <span class="nb">seq </span>485213568, ack 3640034868, win 43690, options <span class="o">[</span>mss 65495,sackOK,TS val 168699846 ecr 168699846,nop,wscale 10], length 0
15:43:16.639791 IP localhost.9490 <span class="o">&gt;</span> localhost.21316: Flags <span class="o">[</span>P.], <span class="nb">seq </span>5:6, ack 6, win 43, options <span class="o">[</span>nop,nop,TS val 168700846 ecr 168700596], length 1
15:43:16.639807 IP localhost.21316 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 6, win 43, options <span class="o">[</span>nop,nop,TS val 168700846 ecr 168700846], length 0
15:43:17.640127 IP localhost.9490 <span class="o">&gt;</span> localhost.21316: Flags <span class="o">[</span>P.], <span class="nb">seq </span>6:7, ack 6, win 43, options <span class="o">[</span>nop,nop,TS val 168701096 ecr 168700846], length 1
15:43:17.640137 IP localhost.21316 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 7, win 43, options <span class="o">[</span>nop,nop,TS val 168701096 ecr 168701096], length 0
15:43:18.170130 IP localhost.9490 <span class="o">&gt;</span> localhost.21316: Flags <span class="o">[</span>R.], <span class="nb">seq </span>7, ack 6, win 43, options <span class="o">[</span>nop,nop,TS val 168701228 ecr 168701096], length 0
</code></pre></div></div>

<p><em>某次模拟 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</em></p>

<hr />

<p>这里从读写两个角度来看 <code class="language-plaintext highlighter-rouge">RST</code>，如果已经 <code class="language-plaintext highlighter-rouge">ACK</code> 远端的 <code class="language-plaintext highlighter-rouge">FIN</code> 包：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">read</code>(2) ：返回 0，表示 eof；</li>
  <li><code class="language-plaintext highlighter-rouge">write</code>(2) ：远端返回 <code class="language-plaintext highlighter-rouge">RST</code>，抛出 <code class="language-plaintext highlighter-rouge">broken pipe</code>；</li>
</ol>

<p>如果尚未接收到远端的 <code class="language-plaintext highlighter-rouge">FIN</code> 包，无论读写操作，收到 <code class="language-plaintext highlighter-rouge">RST</code> 时，抛出 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<h2 id="what-more-">what more ？</h2>

<p>除了上述几个场景外，还有其他可能吗？</p>

<h3 id="强行关闭">强行关闭</h3>

<p>正常关闭 TCP 链接时，主动关闭一方会进入 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 状态，等待 2MSL（报文段最大生存时间-Maximum Segment Lifetime，根据具体的实现不同，这个值会不同），此时该端口处于不可用状态。</p>

<p>解决 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 有三种手段：</p>

<ol>
  <li>设置 <code class="language-plaintext highlighter-rouge">SO_REUSEADDR</code> 和 <code class="language-plaintext highlighter-rouge">SO_REUSEPORT</code>；</li>
  <li>修改 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 等待时长；</li>
  <li>设置 <code class="language-plaintext highlighter-rouge">SO_LINGER</code>，强行关闭。</li>
</ol>

<p>设置 socket 选项 <code class="language-plaintext highlighter-rouge">SO_LINGER</code> 为 <code class="language-plaintext highlighter-rouge">(on, 0)</code> 后，<code class="language-plaintext highlighter-rouge">close</code>(2) 将立即向对端发送 <code class="language-plaintext highlighter-rouge">RST</code>，这种关闭方式称为“强行关闭”。而被动关闭方却不知道对端已经彻底断开，所以紧接着的读写操作，引发 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<h3 id="数据滞留">数据滞留</h3>

<p>socket 关闭时，如果接收窗口仍有数据滞留，那么会直接发送 <code class="language-plaintext highlighter-rouge">RST</code> ，不会进入正常的 <code class="language-plaintext highlighter-rouge">FIN</code> 流程。可以参考：<a href="http://cs.ecs.baylor.edu/~donahoo/practical/CSockets/TCPRST.pdf">TCP RST: Calling close() on a socket with data in the receive queue</a>。</p>

<p>和“强行关闭”一样，数据滞留也会导致被动关闭方引发 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>，这样造成的结果是：如果你的服务各种指标正常，但是有非常多的 <code class="language-plaintext highlighter-rouge">connection reset by peer</code> 警告，可能就是服务上游超时 <code class="language-plaintext highlighter-rouge">close</code>(2) socket，而由于接收窗口仍有数据滞留，发送了 <code class="language-plaintext highlighter-rouge">RST</code>。</p>

<h1 id="references">References</h1>

<p>[1] <a href="/2017/05/26/Linux-TCP-%E7%BC%96%E7%A8%8B/">Linux TCP 编程</a></p>

<p>[2] <a href="http://senlinzhan.github.io/2017/03/02/sigpipe/">网络编程中 SIGPIPE 信号</a></p>

<p>[3] <a href="http://xiangruix.com/2016/01/12/tcp-closed-without-fin/">Linux 下 TCP 连接断开未发送 FIN</a></p>

<p>[4] <a href="http://itindex.net/detail/56132-tcp-time-wait">TCP关闭连接(为什么会能Time_wait,Close_wait?)</a></p>]]></content><author><name></name></author><category term="Network" /><category term="Linux" /><category term="TCP/IP" /><category term="Socket" /><summary type="html"><![CDATA[注：本文结论来自网络，真实性未考究，请批判性阅读，如果谬误，请斧正。本文所讨论内容，均假设工作环境为 Linux 服务器。 作为 TCP 不可或缺的一部分，TCP 包头的 RST 为 $1$ 时，表示重置，关闭异常链接。发送 RST 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送 RST 包。而接收端收到 RST 包后，也不必发送 ACK 包来确认。TCP 处理程序会在自己认为的异常时刻发送 RST 包。 14:59:23.379829 IP localhost.62412 &gt; localhost.9490: Flags [R], seq 4127385762, win 0, length 0 通过 tcpdump 观察，Flags [R] 表示该包携带了 RST 。 RST 主要用在三种场景中，保证 TCP 链接的安全性，三种场景分别是：1、到不存在端口的连接请求；2、异常终止连接；3、检测半打开连接。接下来看看 RST 的具体表现。 三种错误 内核中的 TCP 协议栈将收到 RST 的场景分为三种，并抛出了对应的错误。 connection refused 当内核中的 TCP 协议栈收到了 SYN 请求，但是该端口上没有处于监听状态，则相应 RST，此时 client 看到的便是 connection refused。 broken pipe fd is connected to a pipe or socket whose reading end is closed. When this happens the writing process will also receive a SIGPIPE signal.(Thus, the write return value is seen only if the program catches, blocks or ignores this signal.) 简单的说，如果已知远端读通道已经被关闭，而应用程序仍然在调用 write(2) 尝试向 socket 中写入数据，TCP 协议栈便会抛出 broken pipe。 connection reset by peer A network connection was closed for reasons outside the control of the local host, such as by the remote machine rebooting or an unrecoverable protocol violation. 如果远端已经 close(2) 连接了，本地服务仍发送了数据，此时 TCP 协议栈便会抛出 connection reset by peer。 broken pipe 和 connection reset by peer 无论是 broken pipe 还是 connection reset by peer，都是收到 RST 的表现，二者有何不同呢？ 为了进一步研究，这里尝试着构建两个场景，分别重现 broken pipe 和 connection reset by peer。 重现 broken pipe 首先，在服务中监听端口，每个连接分多次写入数据，然后关闭连接。 int server() { Acceptor acceptor = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4("127.0.0.1", 9490); acceptor.bind(address); acceptor.listen(10); const char *msg1 = "hello", *msg2 = "world"; while (true) { Connection conn = acceptor.accept(); sleep(1); // wait client shutdown conn.write(msg1, strlen(msg1)); // write success, but RST recieved conn.write(msg2, strlen(msg2)); // throw `broken pipe` } // RAII close conn socket } // RAII close acceptor socket 然后客户端连接到服务端，并立即关闭连接。 int client() { Connector connector = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4("127.0.0.1", 9490); connector.connect(address); } // RAII close connector socket 通过 tcpdump 观察程序运行时请求： $ sudo tcpdump -i lo '(src host 127.0.0.1) and (port 9490)' -B 4096 14:59:13.376906 IP localhost.62412 &gt; localhost.9490: Flags [S], seq 4127385760, win 43690, options [mss 65495,sackOK,TS val 168040030 ecr 0,nop,wscale 10], length 0 14:59:13.376919 IP localhost.9490 &gt; localhost.62412: Flags [S.], seq 2306780414, ack 4127385761, win 43690, options [mss 65495,sackOK,TS val 168040030 ecr 168040030,nop,wscale 10], length 0 14:59:13.376928 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 1, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 0 14:59:13.377089 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 1:2, ack 1, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 1 14:59:13.377223 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 2, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 0 14:59:14.377352 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 2:3, ack 1, win 43, options [nop,nop,TS val 168040280 ecr 168040030], length 1 14:59:14.377439 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 3, win 43, options [nop,nop,TS val 168040280 ecr 168040280], length 0 // .... 14:59:22.379462 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 10:11, ack 1, win 43, options [nop,nop,TS val 168042281 ecr 168042031], length 1 14:59:22.379489 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 11, win 43, options [nop,nop,TS val 168042281 ecr 168042281], length 0 14:59:22.379626 IP localhost.62412 &gt; localhost.9490: Flags [F.], seq 1, ack 11, win 43, options [nop,nop,TS val 168042281 ecr 168042281], length 0 14:59:22.382190 IP localhost.9490 &gt; localhost.62412: Flags [.], ack 2, win 43, options [nop,nop,TS val 168042282 ecr 168042281], length 0 14:59:23.379808 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 11:12, ack 2, win 43, options [nop,nop,TS val 168042531 ecr 168042281], length 1 14:59:23.379829 IP localhost.62412 &gt; localhost.9490: Flags [R], seq 4127385762, win 0, length 0 上述 log 为实验过程中，和上面上面的代码略有出入。 可以观察到，client close(2)，发送了 FIN 给 server，并收到了 ACK。server 此时再次尝试 write(2)，便抛出了 broken pipe 异常。 int main(int argc, char** argv) { try { return server(); } catch (Exception&amp; e) { cout &lt;&lt; e.what() &lt;&lt; endl; return -1; } } server 调用方式。 SIGPIPE 与 broken pipe 按照预期，当 socket 抛出 broken pipe 时，会被最外层 try 和 catch 抓住，并输出。实际上运行结果为： $ ./server $ $ echo $? 141 $ 某次 server 端运行结果，没有任何输出，程序返回值为 $141$。 内核中 TCP 栈如果已经接收到 RST，那么下一次使用 write(2) 时，除了会返回 broken pipe 外，还会产生 SIGPIPE，默认情况下这个信号会终止整个进程，当然你并不想让进程被 SIGPIPE 信号杀死。对 server 来说，为了不被 SIGPIPE 信号杀死，那就需要忽略 SIGPIPE 信号： signal(SIGPIPE, SIG_IGN); 最后，让我们整体分析下 broken pipe 产生方式： client 发送了 FIN 给 server； server 仍给 client 发送数据，client 回复 RST； server 收到 RST 后，再次给 client 发送数据；往一个已经收到 RST 的 socket 继续写入数据，将引起 SIGPIPE 信号，write(2) 返回 EPIPE。 重现 connection reset by peer int server() { Acceptor acceptor = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4("127.0.0.1", 9490); acceptor.bind(address); acceptor.listen(10); while (true) { Connection conn = acceptor.accept(); sleep(10); // 给拔网线留下足够的时间 } // RAII close conn socket } // RAII close acceptor socket 模拟服务端断线重启。 int client() { Connector connector = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4("127.0.0.1", 9490); connector.connect(address); sleep(120); const char *msg = "hello"; connector.write(msg, strlen(msg)); } // RAII close connector socket 一段时间后，再给服务器发送请求，此时服务器已经重启。 这里构造了这样一个场景，与客户端建立连接后，服务端由于不可抗力，比如断电，未能发送 FIN 给客户端。当服务器重启后，内核中 TCP 协议栈收到了客户端的数据包，回应 RST，此时客户端抛出 connection reset by peer。 $ sudo tcpdump -i lo '(src host 127.0.0.1) and (port 9490)' -B 4096 15:43:12.638464 IP localhost.21316 &gt; localhost.9490: Flags [S], seq 3640034867, win 43690, options [mss 65495,sackOK,TS val 168699846 ecr 0,nop,wscale 10], length 0 15:43:12.638478 IP localhost.9490 &gt; localhost.21316: Flags [S.], seq 485213568, ack 3640034868, win 43690, options [mss 65495,sackOK,TS val 168699846 ecr 168699846,nop,wscale 10], length 0 15:43:16.639791 IP localhost.9490 &gt; localhost.21316: Flags [P.], seq 5:6, ack 6, win 43, options [nop,nop,TS val 168700846 ecr 168700596], length 1 15:43:16.639807 IP localhost.21316 &gt; localhost.9490: Flags [.], ack 6, win 43, options [nop,nop,TS val 168700846 ecr 168700846], length 0 15:43:17.640127 IP localhost.9490 &gt; localhost.21316: Flags [P.], seq 6:7, ack 6, win 43, options [nop,nop,TS val 168701096 ecr 168700846], length 1 15:43:17.640137 IP localhost.21316 &gt; localhost.9490: Flags [.], ack 7, win 43, options [nop,nop,TS val 168701096 ecr 168701096], length 0 15:43:18.170130 IP localhost.9490 &gt; localhost.21316: Flags [R.], seq 7, ack 6, win 43, options [nop,nop,TS val 168701228 ecr 168701096], length 0 某次模拟 connection reset by peer。 这里从读写两个角度来看 RST，如果已经 ACK 远端的 FIN 包： read(2) ：返回 0，表示 eof； write(2) ：远端返回 RST，抛出 broken pipe； 如果尚未接收到远端的 FIN 包，无论读写操作，收到 RST 时，抛出 connection reset by peer。 what more ？ 除了上述几个场景外，还有其他可能吗？ 强行关闭 正常关闭 TCP 链接时，主动关闭一方会进入 TIME_WAIT 状态，等待 2MSL（报文段最大生存时间-Maximum Segment Lifetime，根据具体的实现不同，这个值会不同），此时该端口处于不可用状态。 解决 TIME_WAIT 有三种手段： 设置 SO_REUSEADDR 和 SO_REUSEPORT； 修改 TIME_WAIT 等待时长； 设置 SO_LINGER，强行关闭。 设置 socket 选项 SO_LINGER 为 (on, 0) 后，close(2) 将立即向对端发送 RST，这种关闭方式称为“强行关闭”。而被动关闭方却不知道对端已经彻底断开，所以紧接着的读写操作，引发 connection reset by peer。 数据滞留 socket 关闭时，如果接收窗口仍有数据滞留，那么会直接发送 RST ，不会进入正常的 FIN 流程。可以参考：TCP RST: Calling close() on a socket with data in the receive queue。 和“强行关闭”一样，数据滞留也会导致被动关闭方引发 connection reset by peer，这样造成的结果是：如果你的服务各种指标正常，但是有非常多的 connection reset by peer 警告，可能就是服务上游超时 close(2) socket，而由于接收窗口仍有数据滞留，发送了 RST。 References [1] Linux TCP 编程 [2] 网络编程中 SIGPIPE 信号 [3] Linux 下 TCP 连接断开未发送 FIN [4] TCP关闭连接(为什么会能Time_wait,Close_wait?)]]></summary></entry><entry><title type="html">nsq read notes</title><link href="/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/2019/01/03/nsq-read-notes.html" rel="alternate" type="text/html" title="nsq read notes" /><published>2019-01-03T08:00:00+08:00</published><updated>2019-01-03T08:00:00+08:00</updated><id>/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/2019/01/03/nsq-read-notes</id><content type="html" xml:base="/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/2019/01/03/nsq-read-notes.html"><![CDATA[<h1 id="nsqd">nsqd</h1>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">topicMap</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">Topic</span>
<span class="n">clientMap</span> <span class="k">map</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">*</span><span class="n">Client</span>
</code></pre></div></div>

<h2 id="初始化过程">初始化过程</h2>

<ol>
  <li>new</li>
  <li>load meta data</li>
  <li>persist meta data</li>
  <li>main
    <ol>
      <li>listen tcp &amp; http port, start server</li>
      <li>start queueScanLoop, lookupLoop, statsLoop</li>
    </ol>
  </li>
</ol>

<p>有新连接到达时，会生成 connection 的 client，保存到 nsqd 的 clientMap 中，同时启动 goroutine 负责 client 的 messagePump。conn 所在的 goroutine 之后会负责读客户端的命令，并执行以及返回结果。可执行命令如下：</p>

<ol>
  <li>IDENTIFY: 表名身份</li>
  <li>FIN: 在 client 绑定的 channel 上，完成一条消息（调用 channel.FinishMessage），同时会更新当前 client 的 metrics 信息，以及状态</li>
  <li>RDY: 更新 client ready count</li>
  <li>REQ: 在 client 绑定的 channel 上，把一条消息重新送入队列（调用 channel.RequeueMessage），同时更新 metrics 和状态。这条消息会被放入 defered 队列，延后执行</li>
  <li>PUB: 往某个 client 有权限的 topic 发送一条消息（调用 topic.PutMessage），更新 metrics 状态</li>
  <li>MPUB: 和 PUB 一样，不过接收多条消息</li>
  <li>DPUB: 和 PUB 一样，不过会被放入 defered 队列</li>
  <li>NOP: 最简单，啥也不干</li>
  <li>TOUCH: 在 client 绑定的 channel 上，重置一条消息的过期时间（调用 channel.TouchMessage)</li>
  <li>SUB: 将 client 绑定到 channel 上，如果 topic 和 channel 任一个属于 “”, 且 topic 或 channel 正在关闭， client 会不断重试绑定操作。</li>
  <li>CLS: 关闭连接</li>
  <li>AUTH: 授权</li>
</ol>

<p>client 有多种状态：init, disconnect, connect, subscribe, closing ，状态迁移由一系列命令执行顺序决定。除此外还有 ready 状态，client 通过 RDY 更新了自己的 ready count，表示 client 最多同时处理多少条消息，如果 inflight count &gt;= ready count，则未 ready，需要等待。</p>

<p>client 使用 SUB 进入 subscribe 模式，该模式只能进入一次，进入后 messagePumb 会接收到 subEvent，然后从对应 channel 中读取 message 发送到 client 里。</p>

<h2 id="topic">topic</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">messageChan</span> <span class="k">chan</span> <span class="o">*</span><span class="n">Message</span>
<span class="n">backendChan</span> <span class="n">BackendChan</span>
<span class="n">channelsMap</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">Channels</span>
</code></pre></div></div>

<h3 id="topic-创建流程">topic 创建流程</h3>

<ol>
  <li>new topic, save to topicMap</li>
  <li>lookup each lookupd, get all channels in topic $TOPIC</li>
  <li>skip “#ephemeral” and create channels</li>
  <li>start topic messagePump</li>
</ol>

<h3 id="delete-channel">delete channel</h3>

<ol>
  <li>remove from topic channelsMap</li>
  <li>mark channel deleted</li>
  <li>if left channels is zero, and topic is ephemeral, delete topic self</li>
</ol>

<h3 id="put-messages">put messages</h3>

<ol>
  <li>try put message into memory message channel</li>
  <li>fallthrough into backend queue, most case into disk, but ephemeral just ignore</li>
  <li>update message count</li>
</ol>

<h3 id="message-pump">message pump</h3>

<ol>
  <li>read message from memory message channel</li>
  <li>else read from backend message</li>
  <li>else update channel status</li>
  <li>copy memory into each channels in current topic
    <ol>
      <li>if message is defered, put into channels defered</li>
      <li>else put into normal channels</li>
    </ol>
  </li>
</ol>

<h2 id="channel">channel</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clients</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">Consumer</span>
<span class="n">backend</span> <span class="n">BackendQueue</span>
<span class="n">memoryChan</span> <span class="k">chan</span> <span class="o">*</span><span class="n">Message</span>
<span class="n">deferedMessages</span> <span class="k">map</span><span class="p">[</span><span class="n">MessageID</span><span class="p">]</span><span class="o">*</span><span class="n">Message</span>
<span class="n">defredPQ</span> <span class="n">PriorityQueue</span>
<span class="n">inFlightMessages</span> <span class="k">map</span><span class="p">[</span><span class="n">MessageID</span><span class="p">]</span><span class="o">*</span><span class="n">Message</span>
<span class="n">inFlightPQ</span> <span class="n">PriorityQueue</span>
</code></pre></div></div>

<p>channel put message 和 topic put message 类似。put defered message 会把 message 放在deferedMessages 中，并加入 deferedPQ 中。如果 defered 时间到了，使用正常流程 put。clients 提供了 Add 和 Remove 接口，但管理职责不是 channel 的。</p>

<h1 id="nsqlookupd">nsqlookupd</h1>

<h2 id="nsqlookupd-数据组织方式">nsqlookupd 数据组织方式</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
	<span class="p">{</span><span class="s">"client"</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="s">""</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="s">"127.0.0.1:9490"</span> <span class="o">=&gt;</span> <span class="n">Producer</span><span class="p">{</span><span class="s">"127.0.0.1:8081"</span><span class="p">},</span>
		<span class="s">"127.0.0.1:9491"</span> <span class="o">=&gt;</span> <span class="n">Producer</span><span class="p">{</span><span class="s">"127.0.0.1:8081"</span><span class="p">},</span>
	<span class="p">},</span>

	<span class="p">{</span><span class="s">"channel"</span><span class="p">,</span> <span class="s">"topic_a"</span><span class="p">,</span> <span class="s">"channel_a"</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="s">"ip1"</span> <span class="o">=&gt;</span> <span class="n">Producer</span><span class="p">{</span><span class="s">"addr"</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span><span class="s">"topic"</span><span class="p">,</span> <span class="s">"topic_a"</span><span class="p">,</span> <span class="s">""</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="s">"ip1"</span> <span class="o">=&gt;</span> <span class="n">Producer</span><span class="p">{</span><span class="s">"addr_1"</span><span class="p">},</span>
		<span class="s">"ip2"</span> <span class="o">=&gt;</span> <span class="n">Producer</span><span class="p">{</span><span class="s">"addr2"</span><span class="p">},</span>
	<span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="nsqd---nsqlookupd-交互">nsqd &lt;-&gt; nsqlookupd 交互</h2>

<ol>
  <li>connect: send “  V1”</li>
  <li>ping: send “PING “
    <ol>
      <li>nsqlookupd update peer info’s lastUpdate</li>
      <li>response “OK”</li>
    </ol>
  </li>
  <li>identify: send “IDENTIFY LEN(data) data”
    <ol>
      <li>remote addr as id</li>
      <li>load broadcase address, tcp port, http port, version</li>
      <li>update peer info’s lastUpdate</li>
      <li>add producer to db: Registration{“client”} =&gt; PeerInfo{id}</li>
      <li>response {tcp_port, http_port, version, hostname, broadcast_address}</li>
    </ol>
  </li>
  <li>register: send “REGISTER TOPIC [CHANNEL]”
    <ol>
      <li>read topic and channel name</li>
      <li>if channel name exists:
        <ol>
          <li>add producer to db: Registration{“channel”, $TOPIC, $CHANNEL} =&gt; PeerInfo{id}</li>
        </ol>
      </li>
      <li>add producer to db: Registration{“topic”, $TOPIC, “”} =&gt; PeerInfo{id}</li>
      <li>response “OK”</li>
    </ol>
  </li>
  <li>unregister: send “UNREGISTER TOPIC [CHANNEL]”
    <ol>
      <li>read topic and channel name</li>
      <li>if channel name exists:
        <ol>
          <li>remove producer from db: Registration{“channel”, $TOPIC, $CHANNEL}</li>
          <li>remove registration for channel has suffix “#ephemeral” if left producer is zero</li>
        </ol>
      </li>
      <li>else:
        <ol>
          <li>find all registrations of channel of $TOPIC</li>
          <li>remove all channels of current peer</li>
          <li>remove producer form db: Registration{“topic”, $TOPIC, “”}</li>
        </ol>
      </li>
      <li>response “OK”</li>
    </ol>
  </li>
</ol>

<h2 id="nsqlookupd-support-http-request">nsqlookupd support http request</h2>

<ol>
  <li>GET /lookup?topic=topic_name
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"channels"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"channel1"</span><span class="p">],</span><span class="w">
 </span><span class="nl">"producers"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">

 </span><span class="p">}],</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>GET /topics</li>
  <li>GET /channels?topic=topic_name</li>
  <li>GET /nodes</li>
  <li>POST /topic/create?topic=</li>
  <li>POST /topic/delete?topic=</li>
  <li>POST /channel/create?topic=topic&amp;channel=channel</li>
  <li>POST /channel/delete?topic=&amp;channel=</li>
  <li>POST /topic/tombstone?topic=topic_name&amp;node=node_id</li>
</ol>]]></content><author><name></name></author><category term="消息中间件" /><category term="Nsq," /><category term="MessageQueue" /><summary type="html"><![CDATA[nsqd topicMap map[string]*Topic clientMap map[id]*Client 初始化过程 new load meta data persist meta data main listen tcp &amp; http port, start server start queueScanLoop, lookupLoop, statsLoop 有新连接到达时，会生成 connection 的 client，保存到 nsqd 的 clientMap 中，同时启动 goroutine 负责 client 的 messagePump。conn 所在的 goroutine 之后会负责读客户端的命令，并执行以及返回结果。可执行命令如下： IDENTIFY: 表名身份 FIN: 在 client 绑定的 channel 上，完成一条消息（调用 channel.FinishMessage），同时会更新当前 client 的 metrics 信息，以及状态 RDY: 更新 client ready count REQ: 在 client 绑定的 channel 上，把一条消息重新送入队列（调用 channel.RequeueMessage），同时更新 metrics 和状态。这条消息会被放入 defered 队列，延后执行 PUB: 往某个 client 有权限的 topic 发送一条消息（调用 topic.PutMessage），更新 metrics 状态 MPUB: 和 PUB 一样，不过接收多条消息 DPUB: 和 PUB 一样，不过会被放入 defered 队列 NOP: 最简单，啥也不干 TOUCH: 在 client 绑定的 channel 上，重置一条消息的过期时间（调用 channel.TouchMessage) SUB: 将 client 绑定到 channel 上，如果 topic 和 channel 任一个属于 “”, 且 topic 或 channel 正在关闭， client 会不断重试绑定操作。 CLS: 关闭连接 AUTH: 授权 client 有多种状态：init, disconnect, connect, subscribe, closing ，状态迁移由一系列命令执行顺序决定。除此外还有 ready 状态，client 通过 RDY 更新了自己的 ready count，表示 client 最多同时处理多少条消息，如果 inflight count &gt;= ready count，则未 ready，需要等待。 client 使用 SUB 进入 subscribe 模式，该模式只能进入一次，进入后 messagePumb 会接收到 subEvent，然后从对应 channel 中读取 message 发送到 client 里。 topic messageChan chan *Message backendChan BackendChan channelsMap map[string]Channels topic 创建流程 new topic, save to topicMap lookup each lookupd, get all channels in topic $TOPIC skip “#ephemeral” and create channels start topic messagePump delete channel remove from topic channelsMap mark channel deleted if left channels is zero, and topic is ephemeral, delete topic self put messages try put message into memory message channel fallthrough into backend queue, most case into disk, but ephemeral just ignore update message count message pump read message from memory message channel else read from backend message else update channel status copy memory into each channels in current topic if message is defered, put into channels defered else put into normal channels channel clients map[string]Consumer backend BackendQueue memoryChan chan *Message deferedMessages map[MessageID]*Message defredPQ PriorityQueue inFlightMessages map[MessageID]*Message inFlightPQ PriorityQueue channel put message 和 topic put message 类似。put defered message 会把 message 放在deferedMessages 中，并加入 deferedPQ 中。如果 defered 时间到了，使用正常流程 put。clients 提供了 Add 和 Remove 接口，但管理职责不是 channel 的。 nsqlookupd nsqlookupd 数据组织方式 { {"client", "", ""} =&gt; { "127.0.0.1:9490" =&gt; Producer{"127.0.0.1:8081"}, "127.0.0.1:9491" =&gt; Producer{"127.0.0.1:8081"}, }, {"channel", "topic_a", "channel_a"} =&gt; { "ip1" =&gt; Producer{"addr"}, }, {"topic", "topic_a", ""} =&gt; { "ip1" =&gt; Producer{"addr_1"}, "ip2" =&gt; Producer{"addr2"}, }, } nsqd &lt;-&gt; nsqlookupd 交互 connect: send “ V1” ping: send “PING “ nsqlookupd update peer info’s lastUpdate response “OK” identify: send “IDENTIFY LEN(data) data” remote addr as id load broadcase address, tcp port, http port, version update peer info’s lastUpdate add producer to db: Registration{“client”} =&gt; PeerInfo{id} response {tcp_port, http_port, version, hostname, broadcast_address} register: send “REGISTER TOPIC [CHANNEL]” read topic and channel name if channel name exists: add producer to db: Registration{“channel”, $TOPIC, $CHANNEL} =&gt; PeerInfo{id} add producer to db: Registration{“topic”, $TOPIC, “”} =&gt; PeerInfo{id} response “OK” unregister: send “UNREGISTER TOPIC [CHANNEL]” read topic and channel name if channel name exists: remove producer from db: Registration{“channel”, $TOPIC, $CHANNEL} remove registration for channel has suffix “#ephemeral” if left producer is zero else: find all registrations of channel of $TOPIC remove all channels of current peer remove producer form db: Registration{“topic”, $TOPIC, “”} response “OK” nsqlookupd support http request GET /lookup?topic=topic_name { "channels": ["channel1"], "producers": [{ }], } GET /topics GET /channels?topic=topic_name GET /nodes POST /topic/create?topic= POST /topic/delete?topic= POST /channel/create?topic=topic&amp;channel=channel POST /channel/delete?topic=&amp;channel= POST /topic/tombstone?topic=topic_name&amp;node=node_id]]></summary></entry><entry><title type="html">Write Ahead Log 杂谈</title><link href="/%E5%AD%98%E5%82%A8/2018/08/04/write-ahead-log.html" rel="alternate" type="text/html" title="Write Ahead Log 杂谈" /><published>2018-08-04T16:21:38+08:00</published><updated>2018-08-04T16:21:38+08:00</updated><id>/%E5%AD%98%E5%82%A8/2018/08/04/write-ahead-log</id><content type="html" xml:base="/%E5%AD%98%E5%82%A8/2018/08/04/write-ahead-log.html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Write-ahead_logging">预写式日志</a>（Write Ahead Log, WAL）主要用于实现存储系统中的原子性和持久性。预写式日志要求存储系统的修改操作在提交前都要先写入日志（Log）中。在硬盘数据不损坏的情况下，预写式日志允许存储系统在崩溃后能够在日志的指导下恢复到崩溃前的状态，避免数据丢失。</p>

<p>预写式日志并不是实现原子性和持久性的唯一办法，影页替换（Shadow Paging）是另一种实现方式，区别是预写式日志允许数据库进行原地更新（in-place），影页替换则不行。</p>

<p>预写式日志是一种套路，并不仅限于传统数据库中，在需要原子性和持久性的系统中经常见到它的身影。关系数据库的实现里，预写式日志常会被实现为重做（Redo Log）和撤销（Undo Log）两部分。LevelDB 中的日志模块就是预写式日志的简单应用，而最佳实践参考 ARIES algorithm。</p>

<p>Linux 文件系统里也有预写式日志的身影，不过叫做 Journaling。Journaling 提供了文件系统原子写入的可能，减轻存储系统实现难度。Journaling 在存储设备上开辟一段空间，用于记录文件操作，写操作先写入日志，然后复制数据到具体文件空间中，更新文件元信息，确保写入操作完成后再删除日志。Journaling 会在系统挂载文件系统时检查是否有未完成的日志，对其进行重做；系统卸载文件系统时，会将积压的日志写入。如果日志本身就不完整，直接丢弃更改。Journaling 每次操作需要将数据写两次，一种优化方式是先将数据写入对应位置，日志里只记录操作元信息，数据写入成功后再写日志。</p>

<p>预写式日志还应用在使用复制状态机（Replicated State Machine, RSM）进行协作的分布式系统中，如 Raft 算法为了保证安全性要求节点在将日志完整写入硬盘后才能回复该消息。</p>

<p>预写式日志在存储系统中扮演着举足轻重的地位，从文件系统，到分布式系统。不过在新的硬件环境下，出现了另一种与预写式日志相对的叫 Write-Behind Logging 的日志系统。WBL 在事务提交的时候，直接把藏页写入 NVRAM 中，等脏页刷盘后，再去更新日志。关于 WBL 的具体实现方式，参考论文：<a href="http://www.vldb.org/pvldb/vol10/p337-arulraj.pdf">Write-Behind Logging
</a></p>]]></content><author><name></name></author><category term="存储" /><category term="Storage" /><summary type="html"><![CDATA[预写式日志（Write Ahead Log, WAL）主要用于实现存储系统中的原子性和持久性。预写式日志要求存储系统的修改操作在提交前都要先写入日志（Log）中。在硬盘数据不损坏的情况下，预写式日志允许存储系统在崩溃后能够在日志的指导下恢复到崩溃前的状态，避免数据丢失。 预写式日志并不是实现原子性和持久性的唯一办法，影页替换（Shadow Paging）是另一种实现方式，区别是预写式日志允许数据库进行原地更新（in-place），影页替换则不行。 预写式日志是一种套路，并不仅限于传统数据库中，在需要原子性和持久性的系统中经常见到它的身影。关系数据库的实现里，预写式日志常会被实现为重做（Redo Log）和撤销（Undo Log）两部分。LevelDB 中的日志模块就是预写式日志的简单应用，而最佳实践参考 ARIES algorithm。 Linux 文件系统里也有预写式日志的身影，不过叫做 Journaling。Journaling 提供了文件系统原子写入的可能，减轻存储系统实现难度。Journaling 在存储设备上开辟一段空间，用于记录文件操作，写操作先写入日志，然后复制数据到具体文件空间中，更新文件元信息，确保写入操作完成后再删除日志。Journaling 会在系统挂载文件系统时检查是否有未完成的日志，对其进行重做；系统卸载文件系统时，会将积压的日志写入。如果日志本身就不完整，直接丢弃更改。Journaling 每次操作需要将数据写两次，一种优化方式是先将数据写入对应位置，日志里只记录操作元信息，数据写入成功后再写日志。 预写式日志还应用在使用复制状态机（Replicated State Machine, RSM）进行协作的分布式系统中，如 Raft 算法为了保证安全性要求节点在将日志完整写入硬盘后才能回复该消息。 预写式日志在存储系统中扮演着举足轻重的地位，从文件系统，到分布式系统。不过在新的硬件环境下，出现了另一种与预写式日志相对的叫 Write-Behind Logging 的日志系统。WBL 在事务提交的时候，直接把藏页写入 NVRAM 中，等脏页刷盘后，再去更新日志。关于 WBL 的具体实现方式，参考论文：Write-Behind Logging]]></summary></entry><entry><title type="html">Raft-实现指北-领导选举</title><link href="/destribution/2018/01/07/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE.html" rel="alternate" type="text/html" title="Raft-实现指北-领导选举" /><published>2018-01-07T21:31:18+08:00</published><updated>2018-01-07T21:31:18+08:00</updated><id>/destribution/2018/01/07/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE</id><content type="html" xml:base="/destribution/2018/01/07/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE.html"><![CDATA[<p>和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。在选举上，Raft 算法使用一个随机计时器来选举领导者，这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。[1]</p>

<p><img src="https://camo.githubusercontent.com/f9b80d45d67996bb9ce63ba6e5d37b6a03150097/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245352e706e67" alt="时间被划分成一个个的任期，每个任期开始都是一次选举" /></p>

<p>Raft 把时间分割任意长度的任期（term），并使用连续整数标记，每个任期都从一次选举开始。每次选举有一个或多个候选人参选，如果一个候选人赢得选举，其就会在该任期充当领导人的职责。某些情况下会出现选票瓜分的现象，那么该任期无法选出领导人，所以进入下一期选举，其中 Raft 通过随机计时来保证选举成功。[1]</p>

<h1 id="设计">设计</h1>

<p>实现领导人选举之前，先看到上一节提到的纯函数式的状态机，将 Raft 实现成为一个无副作用的纯函数状态机。Raft 算法可以看作一个角色状态机，通过其他节点传递的消息、计时器、客户端的提交请求和快照等输入消息，从一个状态转移到另一个状态、或修改部分内部状态并返回一个发送给外部的信息。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(state, message) -&gt; state machine -&gt; message
</code></pre></div></div>

<p>state machine 是一个纯函数式的状态机，负责处理消息，并将改动写入到 state 里，然后返回给外部的消息。</p>

<p>根据 Raft 论文，一个 state 几部分组成：</p>

<table>
  <thead>
    <tr>
      <th>状态</th>
      <th>所有服务器上持久存在的</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>currentTerm</td>
      <td>服务器最后一次知道的任期号（初始化为 0，持续递增）</td>
    </tr>
    <tr>
      <td>votedFor</td>
      <td>在当前获得选票的候选人的 Id</td>
    </tr>
    <tr>
      <td>log[]</td>
      <td>日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>状态</th>
      <th>所有服务器上经常变的</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>commitIndex</td>
      <td>已知的最大的已经被提交的日志条目的索引值</td>
    </tr>
    <tr>
      <td>lastApplied</td>
      <td>最后被应用到状态机的日志条目索引值（初始化为 0，持续递增）</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>状态</th>
      <th>在领导人里经常改变的 （选举后重新初始化）</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>nextIndex[]</td>
      <td>对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一）</td>
    </tr>
    <tr>
      <td>matchIndex[]</td>
      <td>对于每一个服务器，已经复制给他的日志的最高索引值</td>
    </tr>
  </tbody>
</table>

<p>实现大体是类似的，不过以后需要加入流量控制、成员加入退出等，所以将 state 中保存的其他服务器的信息抽象一下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">node</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">id</span> <span class="kt">uint64</span> 
    <span class="n">nextIdx</span> <span class="kt">uint64</span> 
    <span class="n">matched</span> <span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">id</code> 表示其他服务器在 Raft 中的唯一 ID，<code class="language-plaintext highlighter-rouge">nextIdx</code> 与 <code class="language-plaintext highlighter-rouge">matched</code> 分别是 <code class="language-plaintext highlighter-rouge">nextIndex</code> 数组和 <code class="language-plaintext highlighter-rouge">matchIndex</code> 数据中第 <code class="language-plaintext highlighter-rouge">id</code> 个元素。</p>

<p>Raft 通过超时来驱动心跳和选举，一共由两种超时：1、心跳超时，领导人定期给跟随者发送心跳信息宣布自己的领导权；2、选举超时，超时时间是随机选择的。</p>

<p>整个 state 如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">core</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">id</span> <span class="kt">uint64</span> 
    <span class="n">leaderId</span> <span class="kt">uint64</span>
    <span class="n">state</span> <span class="n">StateRole</span>

    <span class="n">term</span> <span class="kt">uint64</span> 
    <span class="n">vote</span> <span class="kt">uint64</span> 
    <span class="n">log</span> <span class="o">*</span><span class="n">LogHolder</span> 

    <span class="n">nodes</span> <span class="p">[]</span><span class="n">node</span> 

    <span class="n">timeElapsed</span> <span class="kt">int</span> 
    <span class="n">randomizedElectionTimtout</span> <span class="kt">int</span> 
    <span class="n">electionTimeout</span> <span class="kt">int</span> 
    <span class="n">heartbeatTimeout</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">id</code> 是 Raft weiyiqueding d  <code class="language-plaintext highlighter-rouge">term</code> 和 <code class="language-plaintext highlighter-rouge">vote</code> 分别是 <code class="language-plaintext highlighter-rouge">currentTerm</code> 和 <code class="language-plaintext highlighter-rouge">voteFor</code> 的实现，而日志由应用负责持久化。<code class="language-plaintext highlighter-rouge">lastApplied</code> 和 <code class="language-plaintext highlighter-rouge">commitIndex</code> 由 <code class="language-plaintext highlighter-rouge">log</code> 负责管理。<code class="language-plaintext highlighter-rouge">nodes</code> 表示该 Raft 集群的其他服务器的状态。<code class="language-plaintext highlighter-rouge">timeElapsed</code> 表示从时间累积，<code class="language-plaintext highlighter-rouge">randomizedElectionTimeout</code> 表示随机生成的选举超时阈值，每次转为跟随者、候选人状态时都会改变。<code class="language-plaintext highlighter-rouge">heartbeatTimeout</code> 表示领导人两次心跳的间隔。<code class="language-plaintext highlighter-rouge">electionTimeout</code> 用来表示领导人选举超时基准，其用于计算<code class="language-plaintext highlighter-rouge">randomizedElectionTimeout</code>，使用公式：$electionTimeout + rand() \% electionTimeout$ 计算得到。另外还有 <code class="language-plaintext highlighter-rouge">leaderId</code> 和 <code class="language-plaintext highlighter-rouge">state</code> 状态，<code class="language-plaintext highlighter-rouge">leaderId</code> 表示当前领导人的 ID，<code class="language-plaintext highlighter-rouge">state</code> 则是 Raft 目前所处的角色。</p>

<p>此外，还需要设计消息结构作为外部应用、服务器和 Raft 状态机进行数据交换。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Message</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">From</span> <span class="kt">uint64</span> 
    <span class="n">To</span> <span class="kt">uint64</span> 
    <span class="n">MsgType</span> <span class="n">MessageType</span>
    <span class="n">Term</span> <span class="kt">uint64</span> 
    <span class="n">Index</span> <span class="kt">uint64</span>
    <span class="n">LogIndex</span> <span class="kt">uint64</span> 
    <span class="n">LogTerm</span> <span class="kt">uint64</span> 
    <span class="n">Reject</span> <span class="kt">uint64</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>该结构不仅仅用于发起请求，也用于状态机返回数据，所以需要 <code class="language-plaintext highlighter-rouge">Reject</code> 字段表示拒绝请求，比如拒绝给某个候选人投票。</p>

<p>最后，状态机需要返回消息给消息发送者，由于希望将 Raft 设计为一个纯函数式状态机，消息的接受发送交给了应用处理，所以还得提供一个 <code class="language-plaintext highlighter-rouge">Application</code> 接口，供 Raft 和应用交互。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Application</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">send</span><span class="p">(</span><span class="n">msg</span> <span class="o">*</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当应用接收到消息后，将其输入到 Raft 状态机，处理完后，调用 <code class="language-plaintext highlighter-rouge">send</code> 发送回复消息，并保存信息到机中。整个状态机由消息驱动，所以 Raft 接口如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Raft</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Step</span><span class="p">(</span><span class="n">msg</span> <span class="o">*</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span>
    <span class="n">Periodic</span><span class="p">(</span><span class="n">millsSinceLastPeriod</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当应用接受到外部传递的消息后，调用 <code class="language-plaintext highlighter-rouge">Step</code> 驱动状态机改变状态。Raft 中通过超时进行心跳或选举，外部应用需要通过某个固定的定时源隔一段时间调用 <code class="language-plaintext highlighter-rouge">Periodic</code> 驱动状态机进行心跳、选举等。</p>

<h1 id="选举过程">选举过程</h1>

<p><img src="https://camo.githubusercontent.com/6396d99ee401327500ef9eafe92617d7812ecd4d/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245342d30312e706e67" alt="服务器状态变化图" /></p>

<p>系统进行初始化时，每个节点都处于跟随者状态，由于没有领导人定期广播心跳，所以一段时间后部分跟随者成为候选人并进行下一届选举。</p>

<p>当某个候选人获得了超过半数的投票后，成为领导人，并向所有节点广播自己成功的信息。当候选人接收到其他候选人成为领导人的信息后，一届只能选出一个领导人（<strong>选举安全特性</strong>），该候选人退回到跟随者的状态，并投票给该领导人。</p>

<p>如果到了下一个选举超时，仍然没有候选人成为领导人，就会跳过这一届，开始下一届的领导人选举。</p>

<h1 id="prevote">PreVote</h1>

<p>由于<strong>选举安全特性</strong>的限制，成员会忽略已经过期的信息时，并返回自己所在的任期，用于发送者更新自己。由于这一特性的存在，在一个存在网络延迟的网络中，某个节点由于延迟进入了选举，而实际上大多数节点都能接收到领导人的心跳，也会进入选举。Raft 原论文 9.6 节中提出了 Prevote 算法：在选举前可以选询问其他节点是否愿意参与选举，如果节点能够感知到领导人的心跳，那么它就不会参与选举，否则参与选举。只有过半的节点参与选举，才能开始下一届领导人选举。</p>

<h1 id="领导人选举实现">领导人选举实现</h1>

<p>加入了 PreVote 算法后，Raft 的状态变为 4 个：领导人、跟随者，候选人，预候选人。此时的外部事件为：选举、心跳超时；以及：</p>

<ul>
  <li>MsgPreVoteRequest</li>
  <li>MsgPreVoteResponse</li>
  <li>MsgVoteRequest</li>
  <li>MsgVoteResponse</li>
  <li>MsgAppendRequest</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">MsgAppendRequest</code> 这种消息类型发生在某个节点成竞选成功后向其他节点宣示领导权，在选举过程中也由该种类型在节点间传递。比如 PreVote 阶段正常的跟随者能够接收到领导人的心跳；又或者新晋领导人首次对外宣誓领导权。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">Periodic</span><span class="p">(</span><span class="n">millsSinceLastPeriod</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span> <span class="o">+=</span> <span class="n">millsSinceLastPeriod</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Debugf</span><span class="p">(</span><span class="s">"%d periodic %d, time elapsed %d"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">millsSinceLastPeriod</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">IsLeader</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">heartbeatTick</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">.</span><span class="n">broadcastAppend</span><span class="p">()</span>
            <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span> <span class="o">=</span> <span class="m">0</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">randomizedElectionTick</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">1</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">.</span><span class="n">campaign</span><span class="p">(</span><span class="n">campaignPreCandidate</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>每次应用程序调用 <code class="language-plaintext highlighter-rouge">Periodic</code> 时，Raft 判断是否为 leader，是判断 <code class="language-plaintext highlighter-rouge">timeElapsed</code> 是否超过 <code class="language-plaintext highlighter-rouge">heartbeatTick</code>，然后向其他节点发送追加日志（心跳）信息，并清空 <code class="language-plaintext highlighter-rouge">timElapsed</code>；如果不是领导人，且已经超过随机生成的选举超时，那么状态转移到预候选人同时开始 PreVote 阶段。</p>

<p>除此之外，PreVote 算法还需要记录其他节点对某次预选举请求的响应状态，所以在 node 结构中添加字段标记：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">voteState</span> <span class="kt">int</span>

<span class="k">const</span> <span class="p">(</span>
    <span class="n">voteNone</span>    <span class="n">voteState</span> <span class="o">=</span> <span class="no">iota</span>
    <span class="n">voteReject</span>
    <span class="n">voteGranted</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">node</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="n">vote</span>    <span class="n">voteState</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="状态间转换">状态间转换</h2>

<p>继续之前需要看看 Raft 状态机的状态转换是如何实现的：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">resetRandomizedElectionTimeout</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">randomizedElectionTick</span> <span class="o">=</span>
        <span class="n">c</span><span class="o">.</span><span class="n">electionTick</span> <span class="o">+</span> <span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">electionTick</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">reset</span><span class="p">(</span><span class="n">term</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="o">!=</span> <span class="n">term</span> <span class="p">{</span>
        <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="o">=</span> <span class="n">term</span>
        <span class="n">c</span><span class="o">.</span><span class="n">vote</span> <span class="o">=</span> <span class="n">InvalidId</span>
    <span class="p">}</span>
    <span class="n">c</span><span class="o">.</span><span class="n">leaderId</span> <span class="o">=</span> <span class="n">InvalidId</span>
    <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span> <span class="o">=</span> <span class="m">0</span>
    <span class="n">c</span><span class="o">.</span><span class="n">resetRandomizedElectionTimeout</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">becomeFollower</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">leaderId</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">leaderId</span> <span class="o">=</span> <span class="n">leaderId</span>
    <span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">FOLLOWER</span>
    <span class="n">c</span><span class="o">.</span><span class="n">vote</span> <span class="o">=</span> <span class="n">leaderId</span>

    <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%v become follower at %d"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">becomeLeader</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">CANDIDATE</span><span class="p">,</span> <span class="s">"invalid translation [%v =&gt; Leader]"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>

    <span class="n">c</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">leaderId</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span>
    <span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">LEADER</span>
    <span class="n">c</span><span class="o">.</span><span class="n">vote</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span>

    <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%v become leader at %d"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">becomeCandidate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LEADER</span><span class="p">,</span> <span class="s">"invalid translation [Leader =&gt; Candidate]"</span><span class="p">)</span>

    <span class="n">c</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">vote</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span>
    <span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CANDIDATE</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">node</span><span class="o">.</span><span class="n">resetVoteState</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%v become candidate at %d"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">becomePreCandidate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">PRE_CANDIDATE</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">node</span><span class="o">.</span><span class="n">resetVoteState</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c">// Becoming a pre-candidate changes our state,</span>
    <span class="c">// but doesn't change anything else. In particular it does not increase</span>
    <span class="c">// currentTerm or change votedFor.</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%x became pre-candidate at term %d"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>首先看到 <code class="language-plaintext highlighter-rouge">reset</code>，它是负责在 Raft 状态转换过程中重置部分状态。<code class="language-plaintext highlighter-rouge">reset</code> 中第一步是根据任期是否改变决定重置 <code class="language-plaintext highlighter-rouge">vote</code> 和 <code class="language-plaintext highlighter-rouge">term</code> 信息；除此之外还重置了 <code class="language-plaintext highlighter-rouge">leaderId</code> 以及超时相关的两个属性: <code class="language-plaintext highlighter-rouge">timeElapsed</code> 和 <code class="language-plaintext highlighter-rouge">randomizedElectionTimeout</code>。</p>

<p>进入预选举的节点在被大多数节点拒绝后会回退到跟随者的状态，因此在 <code class="language-plaintext highlighter-rouge">becomePreCandidate</code> 中除了重置基础状态外，仅仅修改了 <code class="language-plaintext highlighter-rouge">state</code> 属性和重置其他节点的投票情况。<strong>特别需要注意的是不能修改 <code class="language-plaintext highlighter-rouge">currentTerm</code> 和 <code class="language-plaintext highlighter-rouge">votedFor</code></strong>。</p>

<p>如果预选举的节点获得了半数的节点参选支持，就会进入候选人状态，因此任期加一，同时给自己投票。</p>

<p>此外，当领导者和跟随者在发送心跳或接收到领导人的通知后，都需要重置 <code class="language-plaintext highlighter-rouge">timeElappsed</code>，因此将 <code class="language-plaintext highlighter-rouge">becomeLeader</code> 和 <code class="language-plaintext highlighter-rouge">becomeFollower</code> 设计为重入只会影响到 <code class="language-plaintext highlighter-rouge">timeElapsed</code> 和 <code class="language-plaintext highlighter-rouge">randomizedElectinTimeout</code> 属性。</p>

<h2 id="precampaign">PreCampaign</h2>

<p>竞选时首先调用 <code class="language-plaintext highlighter-rouge">campaign</code> 给其他节点发送 <code class="language-plaintext highlighter-rouge">MsgPreVoteRequest</code> 请求。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">campaign</span><span class="p">(</span><span class="n">ct</span> <span class="n">campaignState</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LEADER</span><span class="p">,</span>
        <span class="s">"invalid translation [Leader =&gt; PreCandidate/Candidate]"</span><span class="p">)</span>

    <span class="n">msg</span> <span class="o">:=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">{}</span>
    <span class="n">msg</span><span class="o">.</span><span class="n">LogIndex</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">lastIndex</span><span class="p">()</span>
    <span class="n">msg</span><span class="o">.</span><span class="n">LogTerm</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">lastTerm</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ct</span> <span class="o">==</span> <span class="n">campaignPreCandidate</span> <span class="p">{</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="o">+</span> <span class="m">1</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgPreVoteRequest</span>
        <span class="n">c</span><span class="o">.</span><span class="n">becomePreCandidate</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgVoteRequest</span>
        <span class="n">c</span><span class="o">.</span><span class="n">becomeCandidate</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">To</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span>

        <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%x [term: %d, index: %d] send %v request to %x at term %d"</span><span class="p">,</span>
            <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">lastTerm</span><span class="p">(),</span> <span class="n">c</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">lastIndex</span><span class="p">(),</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">To</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>PreVote 要求某个节点只有在长时间未和领导人交换心跳时才参与选举。同时参与选举要求候选人的日志必须是最新的（<strong>领导人完全特性</strong>）。所以在接收到其他节点发送的 <code class="language-plaintext highlighter-rouge">MsgPreVoteRequest</code> 时，1、如果在一个选举超时内（注意：<code class="language-plaintext highlighter-rouge">electionTimeout</code>）有和领导交换过一次心跳；2、或者候选人的任期号小于自身的任期号；3、或者候选人的日志不是最新的都拒绝参加选举。否则回复参加选举。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">handlePreVote</span><span class="p">(</span><span class="n">msg</span> <span class="o">*</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">reply</span> <span class="o">:=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">{}</span>
    <span class="n">reply</span><span class="o">.</span><span class="n">To</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">From</span>
    <span class="n">reply</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgPreVoteResponse</span>

    <span class="c">// Reply false if last AppendEntries call was received less than election timeout ago.</span>
    <span class="c">// Reply false if term &lt; currentTerm.</span>
    <span class="c">// Reply false if candidate's log isn't at least as up­to­date as receiver's log.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">leaderId</span> <span class="o">!=</span> <span class="n">InvalidId</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="n">electionTick</span><span class="p">)</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span> <span class="o">||</span>
        <span class="o">!</span><span class="n">c</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">IsUpToDate</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">LogIndex</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">LogTerm</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">reply</span><span class="o">.</span><span class="n">Reject</span> <span class="o">=</span> <span class="no">false</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">reply</span><span class="o">.</span><span class="n">Reject</span> <span class="o">=</span> <span class="no">true</span>
    <span class="p">}</span>

    <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意：实际上在处理远程信息时，如果接收到了过期信息，会直接丢弃（后面有讲），不会进入 <code class="language-plaintext highlighter-rouge">handlePreVote</code> 函数，所以上面第二点实际上永远为假。</p>

<p>预候选人接收到其他节点回复的信息时:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">handleVoteResponse</span><span class="p">(</span><span class="n">msg</span> <span class="o">*</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">Reject</span> <span class="p">{</span>
        <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%x received %v rejection from %x at term %d"</span><span class="p">,</span>
            <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">From</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%x received %v from %x at term %s"</span><span class="p">,</span>
            <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">From</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">Term</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">node</span> <span class="o">:=</span> <span class="n">c</span><span class="o">.</span><span class="n">getNodeById</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">From</span><span class="p">)</span>
    <span class="n">node</span><span class="o">.</span><span class="n">updateVoteState</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">Reject</span><span class="p">)</span>

    <span class="n">count</span> <span class="o">:=</span> <span class="n">c</span><span class="o">.</span><span class="n">voteStateCount</span><span class="p">(</span><span class="n">voteGranted</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">quorum</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">==</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgVoteResponse</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">.</span><span class="n">becomeLeader</span><span class="p">()</span>
            <span class="n">c</span><span class="o">.</span><span class="n">broadcastVictory</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">.</span><span class="n">campaign</span><span class="p">(</span><span class="n">campaignCandidate</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="c">// return to follower state if it receives vote denial from a majority</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">voteStateCount</span><span class="p">(</span><span class="n">voteReject</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">quorum</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">c</span><span class="o">.</span><span class="n">becomeFollower</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">Term</span><span class="p">,</span> <span class="n">InvalidId</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>更新某个 node 对此次请求的投票情况，并判断支持者和反对者人数，如果支持者人数过半，那么调用 <code class="language-plaintext highlighter-rouge">campaign(campaignCandidate)</code> 进入候选人状态。如果反对者人数过半，那么节点会回退到跟随者的状态。</p>

<h2 id="campaign">Campaign</h2>

<p>在候选人一方，选举过程使用了相同的函数，不同的是跟随者对候选人的处理。只有当候选人未投票或者上一次投给了该候选人，候选人才能获得跟随者的选票。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">handleVote</span><span class="p">(</span><span class="n">msg</span> <span class="o">*</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">reply</span> <span class="o">:=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">{}</span>
    <span class="n">reply</span><span class="o">.</span><span class="n">To</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">From</span>
    <span class="n">reply</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgVoteResponse</span>

    <span class="c">// no vote or vote for candidate, and log is at least as up-to-date as receiver's.</span>
    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">vote</span> <span class="o">==</span> <span class="n">InvalidId</span> <span class="o">||</span> <span class="n">c</span><span class="o">.</span><span class="n">vote</span> <span class="o">==</span> <span class="n">msg</span><span class="o">.</span><span class="n">From</span> <span class="o">||</span>
        <span class="n">c</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">IsUpToDate</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">LogIndex</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">LogTerm</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">reply</span><span class="o">.</span><span class="n">Reject</span> <span class="o">=</span> <span class="no">false</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">reply</span><span class="o">.</span><span class="n">Reject</span> <span class="o">=</span> <span class="no">true</span>
    <span class="p">}</span>

    <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="处理过时消息">处理过时消息</h2>

<p>根据 Raft 论文中将 term 用作逻辑时间，判断过期的消息。在论文图 2 中提到如果接收到来自高任期的消息，应该回退到跟随者状态；接收到过时消息，直接忽略。所以代码可以写为：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">reject</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="p">}</span> <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">becomeFollower</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>实际上可能某个节点成为候选人后，又重新连接到网络中。此时发起投票会导致其他节点增大任期，因此对投票相关的消息做特殊处理。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">Step</span><span class="p">(</span><span class="n">msg</span> <span class="o">*</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="p">{</span>
        <span class="n">c</span><span class="o">.</span><span class="n">reject</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">==</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgPreVoteRequest</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">==</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgPreVoteResponse</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="n">Reject</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">.</span><span class="n">becomeFollower</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">Term</span><span class="p">,</span> <span class="n">leaderId</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">switch</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgPreVoteRequest</span><span class="o">:</span>
        <span class="n">c</span><span class="o">.</span><span class="n">handlePreVote</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgVoteRequest</span><span class="o">:</span>
        <span class="n">c</span><span class="o">.</span><span class="n">handleVote</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">c</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Raft 算法虽然更易于理解，但是实现并不简单。就以上述代码为例，Raft 如果没有 PreVote 机制，那么重新上线的候选人会通过 <code class="language-plaintext highlighter-rouge">c.reject(msg)</code> 强制让候选人参与选举。加入 PreVote 机制也不能完全避免这种情况。如果一个节点成为了候选人，此时领导人重新上线，那么候选人仍然会强制发起一次选举[3]。</p>

<h1 id="references">References</h1>

<ol>
  <li><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">寻找一种易于理解的一致性算法（扩展版）</a></li>
  <li><a href="http://blog.neverchanje.com/2017/01/30/etcd_raft_core/">Etcd-raft-core 阅读</a></li>
  <li><a href="http://blog.neverchanje.com/2017/01/31/morning_paper_four_modifications_mongo_raft/">Morning Paper, MongoDB 对 Raft 算法的 4 个改动</a></li>
</ol>]]></content><author><name></name></author><category term="Destribution" /><category term="Raft" /><category term="Consensus" /><category term="Practice" /><category term="Destribution" /><summary type="html"><![CDATA[和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。在选举上，Raft 算法使用一个随机计时器来选举领导者，这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。[1] Raft 把时间分割任意长度的任期（term），并使用连续整数标记，每个任期都从一次选举开始。每次选举有一个或多个候选人参选，如果一个候选人赢得选举，其就会在该任期充当领导人的职责。某些情况下会出现选票瓜分的现象，那么该任期无法选出领导人，所以进入下一期选举，其中 Raft 通过随机计时来保证选举成功。[1] 设计 实现领导人选举之前，先看到上一节提到的纯函数式的状态机，将 Raft 实现成为一个无副作用的纯函数状态机。Raft 算法可以看作一个角色状态机，通过其他节点传递的消息、计时器、客户端的提交请求和快照等输入消息，从一个状态转移到另一个状态、或修改部分内部状态并返回一个发送给外部的信息。 (state, message) -&gt; state machine -&gt; message state machine 是一个纯函数式的状态机，负责处理消息，并将改动写入到 state 里，然后返回给外部的消息。 根据 Raft 论文，一个 state 几部分组成： 状态 所有服务器上持久存在的 currentTerm 服务器最后一次知道的任期号（初始化为 0，持续递增） votedFor 在当前获得选票的候选人的 Id log[] 日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号 状态 所有服务器上经常变的 commitIndex 已知的最大的已经被提交的日志条目的索引值 lastApplied 最后被应用到状态机的日志条目索引值（初始化为 0，持续递增） 状态 在领导人里经常改变的 （选举后重新初始化） nextIndex[] 对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一） matchIndex[] 对于每一个服务器，已经复制给他的日志的最高索引值 实现大体是类似的，不过以后需要加入流量控制、成员加入退出等，所以将 state 中保存的其他服务器的信息抽象一下： type node struct { id uint64 nextIdx uint64 matched uint64 } id 表示其他服务器在 Raft 中的唯一 ID，nextIdx 与 matched 分别是 nextIndex 数组和 matchIndex 数据中第 id 个元素。 Raft 通过超时来驱动心跳和选举，一共由两种超时：1、心跳超时，领导人定期给跟随者发送心跳信息宣布自己的领导权；2、选举超时，超时时间是随机选择的。 整个 state 如下： type core struct { id uint64 leaderId uint64 state StateRole term uint64 vote uint64 log *LogHolder nodes []node timeElapsed int randomizedElectionTimtout int electionTimeout int heartbeatTimeout int } id 是 Raft weiyiqueding d term 和 vote 分别是 currentTerm 和 voteFor 的实现，而日志由应用负责持久化。lastApplied 和 commitIndex 由 log 负责管理。nodes 表示该 Raft 集群的其他服务器的状态。timeElapsed 表示从时间累积，randomizedElectionTimeout 表示随机生成的选举超时阈值，每次转为跟随者、候选人状态时都会改变。heartbeatTimeout 表示领导人两次心跳的间隔。electionTimeout 用来表示领导人选举超时基准，其用于计算randomizedElectionTimeout，使用公式：$electionTimeout + rand() \% electionTimeout$ 计算得到。另外还有 leaderId 和 state 状态，leaderId 表示当前领导人的 ID，state 则是 Raft 目前所处的角色。 此外，还需要设计消息结构作为外部应用、服务器和 Raft 状态机进行数据交换。 type Message struct { From uint64 To uint64 MsgType MessageType Term uint64 Index uint64 LogIndex uint64 LogTerm uint64 Reject uint64 } 该结构不仅仅用于发起请求，也用于状态机返回数据，所以需要 Reject 字段表示拒绝请求，比如拒绝给某个候选人投票。 最后，状态机需要返回消息给消息发送者，由于希望将 Raft 设计为一个纯函数式状态机，消息的接受发送交给了应用处理，所以还得提供一个 Application 接口，供 Raft 和应用交互。 type Application interface { send(msg *raftpd.Message) } 当应用接收到消息后，将其输入到 Raft 状态机，处理完后，调用 send 发送回复消息，并保存信息到机中。整个状态机由消息驱动，所以 Raft 接口如下： type Raft interface { Step(msg *raftpd.Message) Periodic(millsSinceLastPeriod int) } 当应用接受到外部传递的消息后，调用 Step 驱动状态机改变状态。Raft 中通过超时进行心跳或选举，外部应用需要通过某个固定的定时源隔一段时间调用 Periodic 驱动状态机进行心跳、选举等。 选举过程 系统进行初始化时，每个节点都处于跟随者状态，由于没有领导人定期广播心跳，所以一段时间后部分跟随者成为候选人并进行下一届选举。 当某个候选人获得了超过半数的投票后，成为领导人，并向所有节点广播自己成功的信息。当候选人接收到其他候选人成为领导人的信息后，一届只能选出一个领导人（选举安全特性），该候选人退回到跟随者的状态，并投票给该领导人。 如果到了下一个选举超时，仍然没有候选人成为领导人，就会跳过这一届，开始下一届的领导人选举。 PreVote 由于选举安全特性的限制，成员会忽略已经过期的信息时，并返回自己所在的任期，用于发送者更新自己。由于这一特性的存在，在一个存在网络延迟的网络中，某个节点由于延迟进入了选举，而实际上大多数节点都能接收到领导人的心跳，也会进入选举。Raft 原论文 9.6 节中提出了 Prevote 算法：在选举前可以选询问其他节点是否愿意参与选举，如果节点能够感知到领导人的心跳，那么它就不会参与选举，否则参与选举。只有过半的节点参与选举，才能开始下一届领导人选举。 领导人选举实现 加入了 PreVote 算法后，Raft 的状态变为 4 个：领导人、跟随者，候选人，预候选人。此时的外部事件为：选举、心跳超时；以及： MsgPreVoteRequest MsgPreVoteResponse MsgVoteRequest MsgVoteResponse MsgAppendRequest MsgAppendRequest 这种消息类型发生在某个节点成竞选成功后向其他节点宣示领导权，在选举过程中也由该种类型在节点间传递。比如 PreVote 阶段正常的跟随者能够接收到领导人的心跳；又或者新晋领导人首次对外宣誓领导权。 func (c *core) Periodic(millsSinceLastPeriod int) { c.timeElapsed += millsSinceLastPeriod log.Debugf("%d periodic %d, time elapsed %d", c.id, millsSinceLastPeriod, c.timeElapsed) if c.state.IsLeader() { if c.heartbeatTick &lt;= c.timeElapsed { c.broadcastAppend() c.timeElapsed = 0 } } else if c.randomizedElectionTick &lt;= c.timeElapsed { if len(c.nodes) &gt; 1 { c.campaign(campaignPreCandidate) } } } 每次应用程序调用 Periodic 时，Raft 判断是否为 leader，是判断 timeElapsed 是否超过 heartbeatTick，然后向其他节点发送追加日志（心跳）信息，并清空 timElapsed；如果不是领导人，且已经超过随机生成的选举超时，那么状态转移到预候选人同时开始 PreVote 阶段。 除此之外，PreVote 算法还需要记录其他节点对某次预选举请求的响应状态，所以在 node 结构中添加字段标记： type voteState int const ( voteNone voteState = iota voteReject voteGranted ) type node struct { ... vote voteState } 状态间转换 继续之前需要看看 Raft 状态机的状态转换是如何实现的： func (c *core) resetRandomizedElectionTimeout() { c.randomizedElectionTick = c.electionTick + rand.Intn(c.electionTick) } func (c *core) reset(term uint64) { if c.term != term { c.term = term c.vote = InvalidId } c.leaderId = InvalidId c.timeElapsed = 0 c.resetRandomizedElectionTimeout() } func (c *core) becomeFollower(term, leaderId uint64) { c.reset(term) c.leaderId = leaderId c.state = FOLLOWER c.vote = leaderId log.Infof("%v become follower at %d", c.id, c.term) } func (c *core) becomeLeader() { utils.Assert(c.state == CANDIDATE, "invalid translation [%v =&gt; Leader]", c.state) c.reset(c.term) c.leaderId = c.id c.state = LEADER c.vote = c.id log.Infof("%v become leader at %d", c.id, c.term) } func (c *core) becomeCandidate() { utils.Assert(c.state != LEADER, "invalid translation [Leader =&gt; Candidate]") c.reset(c.term + 1) c.vote = c.id c.state = CANDIDATE for i := 0; i &lt; len(c.nodes); i++ { node := &amp;c.nodes[i] node.resetVoteState() } log.Infof("%v become candidate at %d", c.id, c.term) } func (c *core) becomePreCandidate() { c.reset(c.term) c.state = PRE_CANDIDATE for i := 0; i &lt; len(c.nodes); i++ { node := &amp;c.nodes[i] node.resetVoteState() } // Becoming a pre-candidate changes our state, // but doesn't change anything else. In particular it does not increase // currentTerm or change votedFor. log.Infof("%x became pre-candidate at term %d", c.id, c.term) } 首先看到 reset，它是负责在 Raft 状态转换过程中重置部分状态。reset 中第一步是根据任期是否改变决定重置 vote 和 term 信息；除此之外还重置了 leaderId 以及超时相关的两个属性: timeElapsed 和 randomizedElectionTimeout。 进入预选举的节点在被大多数节点拒绝后会回退到跟随者的状态，因此在 becomePreCandidate 中除了重置基础状态外，仅仅修改了 state 属性和重置其他节点的投票情况。特别需要注意的是不能修改 currentTerm 和 votedFor。 如果预选举的节点获得了半数的节点参选支持，就会进入候选人状态，因此任期加一，同时给自己投票。 此外，当领导者和跟随者在发送心跳或接收到领导人的通知后，都需要重置 timeElappsed，因此将 becomeLeader 和 becomeFollower 设计为重入只会影响到 timeElapsed 和 randomizedElectinTimeout 属性。 PreCampaign 竞选时首先调用 campaign 给其他节点发送 MsgPreVoteRequest 请求。 func (c *core) campaign(ct campaignState) { utils.Assert(c.state != LEADER, "invalid translation [Leader =&gt; PreCandidate/Candidate]") msg := raftpd.Message{} msg.LogIndex = c.log.lastIndex() msg.LogTerm = c.log.lastTerm() if ct == campaignPreCandidate { msg.Term = c.term + 1 msg.MsgType = raftpd.MsgPreVoteRequest c.becomePreCandidate() } else { msg.Term = c.term msg.MsgType = raftpd.MsgVoteRequest c.becomeCandidate() } for i := 0; i &lt; len(c.nodes); i++ { node := &amp;c.nodes[i] msg.To = node.id log.Infof("%x [term: %d, index: %d] send %v request to %x at term %d", c.id, c.log.lastTerm(), c.log.lastIndex(), msg.MsgType, msg.To, c.term) c.send(&amp;msg) } } PreVote 要求某个节点只有在长时间未和领导人交换心跳时才参与选举。同时参与选举要求候选人的日志必须是最新的（领导人完全特性）。所以在接收到其他节点发送的 MsgPreVoteRequest 时，1、如果在一个选举超时内（注意：electionTimeout）有和领导交换过一次心跳；2、或者候选人的任期号小于自身的任期号；3、或者候选人的日志不是最新的都拒绝参加选举。否则回复参加选举。 func (c *core) handlePreVote(msg *raftpd.Message) { reply := raftpd.Message{} reply.To = msg.From reply.MsgType = raftpd.MsgPreVoteResponse // Reply false if last AppendEntries call was received less than election timeout ago. // Reply false if term &lt; currentTerm. // Reply false if candidate's log isn't at least as up­to­date as receiver's log. if (c.leaderId != InvalidId &amp;&amp; c.timeElapsed &lt; c.electionTick) || (msg.Term &lt; c.term) || !c.log.IsUpToDate(msg.LogIndex, msg.LogTerm) { reply.Reject = false } else { reply.Reject = true } c.send(&amp;reply) } 注意：实际上在处理远程信息时，如果接收到了过期信息，会直接丢弃（后面有讲），不会进入 handlePreVote 函数，所以上面第二点实际上永远为假。 预候选人接收到其他节点回复的信息时: func (c *core) handleVoteResponse(msg *raftpd.Message) { if msg.Reject { log.Infof("%x received %v rejection from %x at term %d", c.id, msg.MsgType, msg.From, c.term) } else { log.Infof("%x received %v from %x at term %s", c.id, msg.MsgType, msg.From, msg.Term) } node := c.getNodeById(msg.From) node.updateVoteState(msg.Reject) count := c.voteStateCount(voteGranted) if count &gt;= c.quorum() { if msg.MsgType == raftpd.MsgVoteResponse { c.becomeLeader() c.broadcastVictory() } else { c.campaign(campaignCandidate) } return } // return to follower state if it receives vote denial from a majority count = c.voteStateCount(voteReject) if count &gt;= c.quorum() { c.becomeFollower(msg.Term, InvalidId) } } 更新某个 node 对此次请求的投票情况，并判断支持者和反对者人数，如果支持者人数过半，那么调用 campaign(campaignCandidate) 进入候选人状态。如果反对者人数过半，那么节点会回退到跟随者的状态。 Campaign 在候选人一方，选举过程使用了相同的函数，不同的是跟随者对候选人的处理。只有当候选人未投票或者上一次投给了该候选人，候选人才能获得跟随者的选票。 func (c *core) handleVote(msg *raftpd.Message) { reply := raftpd.Message{} reply.To = msg.From reply.MsgType = raftpd.MsgVoteResponse // no vote or vote for candidate, and log is at least as up-to-date as receiver's. if c.vote == InvalidId || c.vote == msg.From || c.log.IsUpToDate(msg.LogIndex, msg.LogTerm) { reply.Reject = false } else { reply.Reject = true } c.send(&amp;reply) } 处理过时消息 根据 Raft 论文中将 term 用作逻辑时间，判断过期的消息。在论文图 2 中提到如果接收到来自高任期的消息，应该回退到跟随者状态；接收到过时消息，直接忽略。所以代码可以写为： if msg.Term &lt; c.term { c.reject(msg) } if msg.Term &gt; c.term { c.becomeFollower() } 实际上可能某个节点成为候选人后，又重新连接到网络中。此时发起投票会导致其他节点增大任期，因此对投票相关的消息做特殊处理。 func (c *core) Step(msg *raftpd.Message) { if msg.Term &lt; c.term { c.reject(msg) } else if msg.Term &gt; c.term { if msg.MsgType == raftpd.MsgPreVoteRequest { } else if msg.MsgType == raftpd.MsgPreVoteResponse &amp;&amp; msg.Reject { } else { c.becomeFollower(msg.Term, leaderId) } } switch msg.MsgType { case raftpd.MsgPreVoteRequest: c.handlePreVote(msg) case raftpd.MsgVoteRequest: c.handleVote(msg) default: c.dispatch(msg) } } Raft 算法虽然更易于理解，但是实现并不简单。就以上述代码为例，Raft 如果没有 PreVote 机制，那么重新上线的候选人会通过 c.reject(msg) 强制让候选人参与选举。加入 PreVote 机制也不能完全避免这种情况。如果一个节点成为了候选人，此时领导人重新上线，那么候选人仍然会强制发起一次选举[3]。 References 寻找一种易于理解的一致性算法（扩展版） Etcd-raft-core 阅读 Morning Paper, MongoDB 对 Raft 算法的 4 个改动]]></summary></entry><entry><title type="html">Raft 实现指北-日志模块</title><link href="/destribution/2018/01/03/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html" rel="alternate" type="text/html" title="Raft 实现指北-日志模块" /><published>2018-01-03T05:14:14+08:00</published><updated>2018-01-03T05:14:14+08:00</updated><id>/destribution/2018/01/03/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97</id><content type="html" xml:base="/destribution/2018/01/03/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html"><![CDATA[<p>在真正开始设计之前，需要考虑好 Raft 框架的搭建。如下图所示，一个服务器由三部分组成：共识算法、状态机以及日志系统。共识算法控制多副本之间日志的同步、广播。Raft 算法主要的工作是管理日志复制，所以在 Raft 应该有一个可操作的日志模块。</p>

<p><img src="https://camo.githubusercontent.com/ad683fbaefbc0bc0fcb31b1d6ca6ca8f715c12cd/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245312d30312e706e67" alt="图一：复制状态机的结构" /></p>

<h1 id="write-ahead-log">Write Ahead Log</h1>

<p>在设计日志模块之前，需要先说说<strong>预写式日志</strong>（Write Ahead Log, WAL）。预写式日志通常出现在存储系统中，以保证数据的持久性[1]。WAL 的中心思想是对数据文件进行修改前，需要保证操作日志已经同步到稳定存储介质中。如果在进行操作时出现了错误导致程序崩溃，重启的程序可以通过读取日志重建原有状态。</p>

<p>Raft 算法中也需要 WAL 配合工作，比如领导人得知某条日志已经有超过半数的人响应，便将其应用到状态机并将其应用结果返回给客户端。状态机将数据保存在内存中，等待系统写入磁盘。此时如果发生错误，客户端的操作日志丢失，而它又接收到了应用成功的消息，便出现了不一致。</p>

<h1 id="日志模块">日志模块</h1>

<pre><code class="language-C++">struct LogHolder {
    vector&lt;Entry&gt; entries;
}
</code></pre>

<p>日志的存储结构可以简单如上设计，<code class="language-plaintext highlighter-rouge">Entry</code> 表示一套操作日志记录。所有已经通过 WAL 持久化的操作日志保存在 Raft 的 <code class="language-plaintext highlighter-rouge">LogHolder</code> 中做缓存。IO 操作非常耗时，在实际的项目中每次操作先进行 IO 操作，效率不高。通常考虑 Batch 操作，将结构修改为：</p>

<pre><code class="language-C++">struct LogHolder {
    vector&lt;Entry&gt; entries;
    size_t stabled_to;
} 
</code></pre>

<p>这样操作日志和已经持久化的日志保存在一起，并通过 <code class="language-plaintext highlighter-rouge">stable_to</code> 区分开。这样将多个日志 <code class="language-plaintext highlighter-rouge">Entry</code> 一起写入 WAL，Batch 的方法可以提升系统整体的吞吐量，不过对于单条数据，会有部分延迟，与提升比起来是非常值得的。</p>

<p>当某条日志被成功复制到集群中过半数的节点中时，Raft 变认为这条日志可以被应用到状态机中，并标记这部分日志为提交状态。提交的日志采用追加的方式，那么原有数据将一直占用存储空间，而对于系统而言，已经被应用了的日志是无用的，所以 Raft 也提出了日志压缩思想。和存储系统中的日志压缩思路一致，都是通过选取某个时间点的日志创建状态机的快照，将时间点之前的日志全部丢弃。[2]</p>

<p>这里将上述的思想也设计到日志系统中：</p>

<pre><code class="language-C++">// +--------------+--------------+-------------+-------------+
// | wait compact |  wait apply  | wait commit | wait stable |
// +--------------+--------------+-------------+-------------+
// ^ offset       ^ Applied      ^ committed   ^ stabled     ^ last
struct LogHolder {
    vector&lt;Entry&gt; entries;
    size_t offset;
    size_t last_applied;
    size_t last_committed;
    size_t last_stabled;
} 
</code></pre>

<p><code class="language-plaintext highlighter-rouge">offset</code> 表示日志压缩后日志系统里存储的第一条日志在整个日志中的偏移。整个模块需要保证 $0 \le offset \le last\_applied \lt last\_committed \lt entreis.size()$。需要注意，<code class="language-plaintext highlighter-rouge">last_stabled</code> 和 <code class="language-plaintext highlighter-rouge">last_committed</code> 之前不一定存在着先后顺序，比如一个出现了网络隔离的节点在一段时间后上线，领导者将将其日志复制给该节点并告知其已经全部提交了，那么就会出现日志属于已经提交的状态，但是还未持久化。</p>

<p>在 Raft 论文中提到，在生成日志快照时，需要保存快照最后一条日志的 <code class="language-plaintext highlighter-rouge">index</code> 和 <code class="language-plaintext highlighter-rouge">term</code> 作为元信息。也有很多访问该元信息的需求，因此可以在 <code class="language-plaintext highlighter-rouge">entries</code> 中保留一个空白（dummy）日志作为快照元信息，那么 <code class="language-plaintext highlighter-rouge">offset</code> 完全可以被该日志项替代。</p>

<p>整个 <code class="language-plaintext highlighter-rouge">LogHolder</code> 只负责维护日志在内存中的缓存，提供日志追加、应用、提交、持久化以及压缩的基本功能，至于具体的操作实际由使用者负责管理。</p>

<h2 id="api-设计">API 设计</h2>

<p>API 设计是一个模块好用与否的关键，良好的 API 设计可以减少内部设计的暴露，减少模块间的耦合，同时提供最大程度的灵活性。这里希望 API 设计简单易用，接口数量少，粒度适中。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">LogHolder</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">compactTo</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">term</span> <span class="kt">uint64</span><span class="p">)</span>
    <span class="n">commitTo</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span>
    <span class="n">applyEntries</span><span class="p">()</span> <span class="p">[]</span><span class="n">Entry</span>
    <span class="n">stableEntries</span><span class="p">()</span> <span class="p">[]</span><span class="n">Entry</span>
    <span class="n">term</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span>
    <span class="n">isUpToDate</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">term</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="n">tryAppend</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">commitIdx</span> <span class="kt">uint64</span><span class="p">,</span> <span class="n">entries</span> <span class="p">[]</span><span class="n">Entry</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
    <span class="nb">append</span><span class="p">(</span><span class="n">entries</span> <span class="p">[]</span><span class="n">Entry</span><span class="p">)</span> <span class="kt">uint64</span>
    <span class="n">slice</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">[]</span><span class="n">Entry</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">compactTo</code>: 当应用生成了快照后，需要对冗余的日志进行压缩；</li>
  <li><code class="language-plaintext highlighter-rouge">commitTo</code>: 日志复制到集群中半数节点中或跟随者接收到领导人提交日志的命令时调用，修改 <code class="language-plaintext highlighter-rouge">last_commit</code> 属性；</li>
  <li><code class="language-plaintext highlighter-rouge">stableEntries</code>: 读取待持久化的日志，并将这部分日志标记为已经持久化；</li>
  <li><code class="language-plaintext highlighter-rouge">applyEntries</code>: 读取待应用到状态机的日志，同时将其日志标记为已经应用；</li>
  <li><code class="language-plaintext highlighter-rouge">term</code>: 返回某个日志提交到集群中的 <code class="language-plaintext highlighter-rouge">term</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">isUpToDate</code>: 用于判断候选人是否拥有最新的日志；</li>
  <li><code class="language-plaintext highlighter-rouge">tryAppend</code>: 跟随者添加日志，会将冲突的日志丢弃；</li>
  <li><code class="language-plaintext highlighter-rouge">append</code>: 领导添加日志，只有追加功能；</li>
  <li><code class="language-plaintext highlighter-rouge">slice</code>: 分片</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">compactTo</code>，<code class="language-plaintext highlighter-rouge">commitTo</code> 负责修改其只修改日志模块属性信息。<code class="language-plaintext highlighter-rouge">compactTo</code> 对日志进行压缩，其可用范围为 $[offset, last\_applied]$，范围内的数据均已经应用到状态机中。实际上在跟随者从网络隔离中恢复或新加入集群时，领导人会选择发送日志来加速跟随者的同步，此时快照并没有落到可用范围内，或者日志与快照的元信息冲突（跟随者在一个少数派的网络中增加了很多日志），因此需要对整个日志系统进行重建。<code class="language-plaintext highlighter-rouge">commitTo</code> 只需要对 <code class="language-plaintext highlighter-rouge">to</code> 范围进行验证，修改 <code class="language-plaintext highlighter-rouge">last_commit</code> 即可。</p>

<p><code class="language-plaintext highlighter-rouge">stableEntries</code> 和 <code class="language-plaintext highlighter-rouge">applyEntries</code> 不需要任何参数，根据属性设置对应的 <code class="language-plaintext highlighter-rouge">slice</code>，并返回需要持久化、应用的日志队列。</p>

<p><code class="language-plaintext highlighter-rouge">isUpToDate</code> 比较给出的日志项和日志模块谁更新。根据 Raft 论文中给出了谁<strong>比较新</strong>的定义：如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新；如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</p>

<p><code class="language-plaintext highlighter-rouge">tryAppend</code> 是用于提交领导人复制给候选人的日志，由于网络分化或者节点的加入退出，获选人的日志可能落后、冲突于领导人提供的日志，日志模块需要对待追加的日志进行检查，并找出冲突项目并替换。</p>

<h2 id="实现">实现</h2>

<p><code class="language-plaintext highlighter-rouge">compactTo</code> 设计如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">holder</span> <span class="o">*</span><span class="n">LogHolder</span><span class="p">)</span> <span class="n">CompactTo</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">term</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">to</span><span class="p">)</span> <span class="o">!=</span> <span class="n">term</span> <span class="o">||</span> <span class="n">to</span> <span class="o">&lt;=</span> <span class="n">holder</span><span class="o">.</span><span class="n">offset</span><span class="p">()</span> <span class="o">||</span> <span class="n">to</span> <span class="o">&gt;</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastApplied</span> <span class="p">{</span>
		<span class="c">// log entry conflict with exists, or less than offset, or great than applied</span>
		<span class="c">// so need to rebuild log</span>
		<span class="n">entries</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Entry</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
		<span class="n">entries</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">.</span><span class="n">Index</span> <span class="o">=</span> <span class="n">to</span>
		<span class="n">entries</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">.</span><span class="n">Term</span> <span class="o">=</span> <span class="n">term</span>
		<span class="n">holder</span><span class="o">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">entries</span>
		<span class="n">holder</span><span class="o">.</span><span class="n">lastApplied</span> <span class="o">=</span> <span class="n">to</span>
		<span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span> <span class="o">=</span> <span class="n">to</span>
		<span class="n">holder</span><span class="o">.</span><span class="n">lastStabled</span> <span class="o">=</span> <span class="n">to</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">:=</span> <span class="n">holder</span><span class="o">.</span><span class="n">offset</span><span class="p">()</span>
		<span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">to</span><span class="p">,</span> <span class="s">"%d compact idx: %d less than first index: %d"</span><span class="p">,</span>
			<span class="n">holder</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
		<span class="n">holder</span><span class="o">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">drain</span><span class="p">(</span><span class="n">holder</span><span class="o">.</span><span class="n">entries</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">to</span><span class="o">-</span><span class="n">offset</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>首先检查是否存在冲突、或者没有在范围之内，都不存在才对日志队列进行压缩；否则重建日志模块，清空日志队列。因为使用了 dummy 日志项的缘故，这里也要把快照元信息作为一个 dummy log 保存。</p>

<p>和 <code class="language-plaintext highlighter-rouge">compactTo</code> 比起来，<code class="language-plaintext highlighter-rouge">commitTo</code> 的实现就容易得多。<code class="language-plaintext highlighter-rouge">commitTo</code> 需要保证<strong>状态机安全性</strong>和<strong>领导人完全性</strong>[2]，不能减少 <code class="language-plaintext highlighter-rouge">commit_index</code>；同时也要保证容错，即在服务器宕机恢复后数据具有一致性，每个可提交的日志需要已经持久化到本地。<code class="language-plaintext highlighter-rouge">commitTo</code> 需要保证数据范围在 $[commit_index, last\_stabled]$ 之间。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">holder</span> <span class="o">*</span><span class="n">LogHolder</span><span class="p">)</span> <span class="n">CommitTo</span><span class="p">(</span><span class="n">to</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span> <span class="o">&gt;=</span> <span class="n">to</span> <span class="p">{</span>
		<span class="c">/* never decrease commit */</span>
		<span class="k">return</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastStabled</span> <span class="o">&lt;</span> <span class="n">to</span> <span class="p">{</span>
		<span class="c">/* cannot commit unstable log entry */</span>
		<span class="n">to</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">MinUint64</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastStabled</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">holder</span><span class="o">.</span><span class="n">lastIndex</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">to</span><span class="p">,</span> <span class="s">"%d toCommit %d is out of range [last index: %d]"</span><span class="p">,</span>
		<span class="n">holder</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastIndex</span><span class="p">())</span>

	<span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span> <span class="o">=</span> <span class="n">to</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">stableEntries</code> 和 <code class="language-plaintext highlighter-rouge">applyEntries</code> 需要返回待持久化或待应用的日志，同时会修改属性，将这已返回的日志标记为已持久化或已经应用。<code class="language-plaintext highlighter-rouge">term</code> 的实现比较直观，<code class="language-plaintext highlighter-rouge">isUpToDate</code> 的实现按照论文给出的定义即可。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">holder</span> <span class="o">*</span><span class="n">LogHolder</span><span class="p">)</span> <span class="n">IsUpToDate</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">term</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">term</span> <span class="o">&gt;</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastTerm</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">term</span> <span class="o">==</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastTerm</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastIndex</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">append</code> 由领导人负责调用，由<strong>领导人只附加原则</strong>决定其只追加新日志到模块中。因为 Raft 的日志具有连续性，追加时要保证第一条追加的日志要紧接着日志模块的最后一条日志。<code class="language-plaintext highlighter-rouge">tryAppend</code> 由跟随者调用，正常情况下领导人发送的日志可以直接追加到跟随者的日志模块中。跟随者可能是新加入集群，并通过快照已经恢复到了快照所处的状态，此时也可以直接追加到日志模块里。当跟随者出现网络隔离导致日志远低于领导人复制来的第一条日志项（重新选举时），或日志项与领导人提供的存在冲突。如果第一条日志存在冲突，那么需要提醒领导人发送合适的日志；如果仅仅部分日志存在冲突，跟随者需要丢弃冲突日志，然后将领导人提供的日志追加到日志模块中（根据<strong>日志匹配原则</strong>），此时需要保证不能抛弃任何已经提交的日志（<strong>状态机安全性</strong>和<strong>领导人完全性</strong>）。</p>

<p><code class="language-plaintext highlighter-rouge">tryAppend</code> 的第一步是找出第一个与现有日志存在冲突的日志索引，然后根据冲突索引丢弃存在冲突的日志，并返回。<code class="language-plaintext highlighter-rouge">tryAppend</code> 的返回值表示是否成功的将日志追加到系统中。Raft 论文 5.3 节提出了一个优化方式，<em>算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化</em>，这里可以使用算法给出的一种优化方式：当附加日志 RPC 的请求被拒绝的时候，跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。因此在拒绝该追加请求时，还给领导人返回提示索引。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">holder</span> <span class="o">*</span><span class="n">LogHolder</span><span class="p">)</span> <span class="n">getHintIndex</span><span class="p">(</span><span class="n">prevIdx</span><span class="p">,</span> <span class="n">prevTerm</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
	<span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">prevIdx</span> <span class="o">!=</span> <span class="n">InvalidIndex</span> <span class="o">&amp;&amp;</span> <span class="n">prevTerm</span> <span class="o">!=</span> <span class="n">InvalidTerm</span><span class="p">,</span>
		<span class="s">"%d get hint index with invalid idx or Term"</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

	<span class="n">idx</span> <span class="o">:=</span> <span class="n">prevIdx</span>
	<span class="n">term</span> <span class="o">:=</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="n">InvalidIndex</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">!=</span> <span class="n">term</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">MaxUint64</span><span class="p">(</span><span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="n">idx</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span>
<span class="p">}</span>

<span class="c">// findConflict return the first index which Entries[i].Term is not equal</span>
<span class="c">// to holder.Term(Entries[i].Index), if all Term with same index are equals,</span>
<span class="c">// return zero.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">holder</span> <span class="o">*</span><span class="n">LogHolder</span><span class="p">)</span> <span class="n">findConflict</span><span class="p">(</span><span class="n">entries</span> <span class="p">[]</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Entry</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">Index</span><span class="p">)</span> <span class="o">!=</span> <span class="n">entry</span><span class="o">.</span><span class="n">Term</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">Index</span> <span class="o">&lt;=</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastIndex</span><span class="p">()</span> <span class="p">{</span>
				<span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%d found conflict at index %d, "</span><span class="o">+</span>
					<span class="s">"[existing Term: %d, conflicting Term: %d]"</span><span class="p">,</span>
					<span class="n">holder</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">Index</span><span class="p">),</span> <span class="n">entry</span><span class="o">.</span><span class="n">Term</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">entry</span><span class="o">.</span><span class="n">Index</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">holder</span> <span class="o">*</span><span class="n">LogHolder</span><span class="p">)</span> <span class="n">TryAppend</span><span class="p">(</span><span class="n">prevIdx</span><span class="p">,</span> <span class="n">prevTerm</span><span class="p">,</span> <span class="n">leaderCommittedIdx</span> <span class="kt">uint64</span><span class="p">,</span>
	<span class="n">entries</span> <span class="p">[]</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Entry</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">lastIdxOfEntries</span> <span class="o">:=</span> <span class="n">prevIdx</span> <span class="o">+</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">)(</span><span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">prevIdx</span><span class="p">)</span> <span class="o">==</span> <span class="n">prevTerm</span> <span class="p">{</span>
		<span class="n">conflictIdx</span> <span class="o">:=</span> <span class="n">holder</span><span class="o">.</span><span class="n">findConflict</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">conflictIdx</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="c">/* success, no conflict */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">conflictIdx</span> <span class="o">&lt;=</span> <span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Panicf</span><span class="p">(</span><span class="s">"%d entry %d conflict with committed entry %d"</span><span class="p">,</span>
				<span class="n">holder</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">conflictIdx</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">:=</span> <span class="n">prevIdx</span> <span class="o">+</span> <span class="m">1</span>
			<span class="n">holder</span><span class="o">.</span><span class="n">Append</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="n">conflictIdx</span><span class="o">-</span><span class="n">offset</span><span class="o">:</span><span class="p">])</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">lastIdxOfEntries</span><span class="p">,</span> <span class="no">true</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">prevIdx</span> <span class="o">&gt;</span> <span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span><span class="p">,</span>
			<span class="s">"%d entry %d [Term: %d] conflict with committed entry Term: %d"</span><span class="p">,</span>
			<span class="n">holder</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">prevIdx</span><span class="p">,</span> <span class="n">prevTerm</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">prevIdx</span><span class="p">))</span>

		<span class="k">return</span> <span class="n">holder</span><span class="o">.</span><span class="n">getHintIndex</span><span class="p">(</span><span class="n">prevIdx</span><span class="p">,</span> <span class="n">prevTerm</span><span class="p">),</span> <span class="no">false</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="done">done</h1>

<p>至此，日志模块的实现就结束了。日志模块是整个 Raft 算法的基础，这里将日志模块剥离出来，并将提供一些原子方法。每个方法只干一件事，从而使分析方法正确性的分析更容易；每个方法都可以看作是纯函数，所以输入一定，输出则一定。实际上分布式程序的调试是一个非常困难的方式：</p>

<blockquote>
  <p>你的并发模型往往会成为你代码库中的病毒。你希望有细粒度的并发控制，好吧，你得到了，代码里到处都是。因此是并发导致了不确定性，而不确定性造成了麻烦。因此必须得把并发给踢出去。可是你又不能抛弃并发，你需要它。那么，你一定要禁止把并发和你的分布式状态机结合在一起。换句话说，你的分布式状态机必须成为纯函数式的。没有IO操作，没有并发，什么都没有。[3]</p>
</blockquote>

<p>好的办法是将其抽象成纯函数式的，通过消息进行驱动，这样能够对程序拥有控制力，出现问题是可以完美重现，也能够跟踪定位到问题所在。从 Raft 算法的角度看，在上面的实现里，日志模块只是一个黑匣子，每个操作好比一个按钮，如果得到的不是想要的结果，那肯定是输入有问题（前提是黑匣子实现正确）。因此上面的代码很好的解开了算法和日志模块的耦合，隔离了双方的错误干扰。</p>

<h1 id="references">References</h1>

<ol>
  <li><a href="https://zh.wikipedia.org/wiki/%E9%A2%84%E5%86%99%E5%BC%8F%E6%97%A5%E5%BF%97">预写式日志</a></li>
  <li><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">寻找一种易于理解的一致性算法（扩展版）</a></li>
  <li><a href="http://blog.jobbole.com/20304/">分布式系统编程，你到哪一级了？</a></li>
</ol>]]></content><author><name></name></author><category term="Destribution" /><category term="Raft" /><category term="Consensus" /><category term="Practice" /><category term="Destribution" /><summary type="html"><![CDATA[在真正开始设计之前，需要考虑好 Raft 框架的搭建。如下图所示，一个服务器由三部分组成：共识算法、状态机以及日志系统。共识算法控制多副本之间日志的同步、广播。Raft 算法主要的工作是管理日志复制，所以在 Raft 应该有一个可操作的日志模块。 Write Ahead Log 在设计日志模块之前，需要先说说预写式日志（Write Ahead Log, WAL）。预写式日志通常出现在存储系统中，以保证数据的持久性[1]。WAL 的中心思想是对数据文件进行修改前，需要保证操作日志已经同步到稳定存储介质中。如果在进行操作时出现了错误导致程序崩溃，重启的程序可以通过读取日志重建原有状态。 Raft 算法中也需要 WAL 配合工作，比如领导人得知某条日志已经有超过半数的人响应，便将其应用到状态机并将其应用结果返回给客户端。状态机将数据保存在内存中，等待系统写入磁盘。此时如果发生错误，客户端的操作日志丢失，而它又接收到了应用成功的消息，便出现了不一致。 日志模块 struct LogHolder { vector&lt;Entry&gt; entries; } 日志的存储结构可以简单如上设计，Entry 表示一套操作日志记录。所有已经通过 WAL 持久化的操作日志保存在 Raft 的 LogHolder 中做缓存。IO 操作非常耗时，在实际的项目中每次操作先进行 IO 操作，效率不高。通常考虑 Batch 操作，将结构修改为： struct LogHolder { vector&lt;Entry&gt; entries; size_t stabled_to; } 这样操作日志和已经持久化的日志保存在一起，并通过 stable_to 区分开。这样将多个日志 Entry 一起写入 WAL，Batch 的方法可以提升系统整体的吞吐量，不过对于单条数据，会有部分延迟，与提升比起来是非常值得的。 当某条日志被成功复制到集群中过半数的节点中时，Raft 变认为这条日志可以被应用到状态机中，并标记这部分日志为提交状态。提交的日志采用追加的方式，那么原有数据将一直占用存储空间，而对于系统而言，已经被应用了的日志是无用的，所以 Raft 也提出了日志压缩思想。和存储系统中的日志压缩思路一致，都是通过选取某个时间点的日志创建状态机的快照，将时间点之前的日志全部丢弃。[2] 这里将上述的思想也设计到日志系统中： // +--------------+--------------+-------------+-------------+ // | wait compact | wait apply | wait commit | wait stable | // +--------------+--------------+-------------+-------------+ // ^ offset ^ Applied ^ committed ^ stabled ^ last struct LogHolder { vector&lt;Entry&gt; entries; size_t offset; size_t last_applied; size_t last_committed; size_t last_stabled; } offset 表示日志压缩后日志系统里存储的第一条日志在整个日志中的偏移。整个模块需要保证 $0 \le offset \le last\_applied \lt last\_committed \lt entreis.size()$。需要注意，last_stabled 和 last_committed 之前不一定存在着先后顺序，比如一个出现了网络隔离的节点在一段时间后上线，领导者将将其日志复制给该节点并告知其已经全部提交了，那么就会出现日志属于已经提交的状态，但是还未持久化。 在 Raft 论文中提到，在生成日志快照时，需要保存快照最后一条日志的 index 和 term 作为元信息。也有很多访问该元信息的需求，因此可以在 entries 中保留一个空白（dummy）日志作为快照元信息，那么 offset 完全可以被该日志项替代。 整个 LogHolder 只负责维护日志在内存中的缓存，提供日志追加、应用、提交、持久化以及压缩的基本功能，至于具体的操作实际由使用者负责管理。 API 设计 API 设计是一个模块好用与否的关键，良好的 API 设计可以减少内部设计的暴露，减少模块间的耦合，同时提供最大程度的灵活性。这里希望 API 设计简单易用，接口数量少，粒度适中。 type LogHolder interface { compactTo(to, term uint64) commitTo(uint64) applyEntries() []Entry stableEntries() []Entry term(uint64) uint64 isUpToDate(idx, term uint64) bool tryAppend(idx, term, commitIdx uint64, entries []Entry) (uint64, bool) append(entries []Entry) uint64 slice(lo, hi uint64) []Entry } compactTo: 当应用生成了快照后，需要对冗余的日志进行压缩； commitTo: 日志复制到集群中半数节点中或跟随者接收到领导人提交日志的命令时调用，修改 last_commit 属性； stableEntries: 读取待持久化的日志，并将这部分日志标记为已经持久化； applyEntries: 读取待应用到状态机的日志，同时将其日志标记为已经应用； term: 返回某个日志提交到集群中的 term； isUpToDate: 用于判断候选人是否拥有最新的日志； tryAppend: 跟随者添加日志，会将冲突的日志丢弃； append: 领导添加日志，只有追加功能； slice: 分片 compactTo，commitTo 负责修改其只修改日志模块属性信息。compactTo 对日志进行压缩，其可用范围为 $[offset, last\_applied]$，范围内的数据均已经应用到状态机中。实际上在跟随者从网络隔离中恢复或新加入集群时，领导人会选择发送日志来加速跟随者的同步，此时快照并没有落到可用范围内，或者日志与快照的元信息冲突（跟随者在一个少数派的网络中增加了很多日志），因此需要对整个日志系统进行重建。commitTo 只需要对 to 范围进行验证，修改 last_commit 即可。 stableEntries 和 applyEntries 不需要任何参数，根据属性设置对应的 slice，并返回需要持久化、应用的日志队列。 isUpToDate 比较给出的日志项和日志模块谁更新。根据 Raft 论文中给出了谁比较新的定义：如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新；如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。 tryAppend 是用于提交领导人复制给候选人的日志，由于网络分化或者节点的加入退出，获选人的日志可能落后、冲突于领导人提供的日志，日志模块需要对待追加的日志进行检查，并找出冲突项目并替换。 实现 compactTo 设计如下： func (holder *LogHolder) CompactTo(to, term uint64) { if holder.Term(to) != term || to &lt;= holder.offset() || to &gt; holder.lastApplied { // log entry conflict with exists, or less than offset, or great than applied // so need to rebuild log entries := make([]raftpd.Entry, 1) entries[0].Index = to entries[0].Term = term holder.entries = entries holder.lastApplied = to holder.commitIndex = to holder.lastStabled = to } else { offset := holder.offset() utils.Assert(offset &lt;= to, "%d compact idx: %d less than first index: %d", holder.id, to, offset) holder.entries = drain(holder.entries, int(to-offset)) } } 首先检查是否存在冲突、或者没有在范围之内，都不存在才对日志队列进行压缩；否则重建日志模块，清空日志队列。因为使用了 dummy 日志项的缘故，这里也要把快照元信息作为一个 dummy log 保存。 和 compactTo 比起来，commitTo 的实现就容易得多。commitTo 需要保证状态机安全性和领导人完全性[2]，不能减少 commit_index；同时也要保证容错，即在服务器宕机恢复后数据具有一致性，每个可提交的日志需要已经持久化到本地。commitTo 需要保证数据范围在 $[commit_index, last\_stabled]$ 之间。 func (holder *LogHolder) CommitTo(to uint64) { if holder.commitIndex &gt;= to { /* never decrease commit */ return } else if holder.lastStabled &lt; to { /* cannot commit unstable log entry */ to = utils.MinUint64(to, holder.lastStabled) } utils.Assert(holder.lastIndex() &gt;= to, "%d toCommit %d is out of range [last index: %d]", holder.id, to, holder.lastIndex()) holder.commitIndex = to } stableEntries 和 applyEntries 需要返回待持久化或待应用的日志，同时会修改属性，将这已返回的日志标记为已持久化或已经应用。term 的实现比较直观，isUpToDate 的实现按照论文给出的定义即可。 func (holder *LogHolder) IsUpToDate(idx, term uint64) bool { return term &gt; holder.lastTerm() || (term == holder.lastTerm() &amp;&amp; idx &gt;= holder.lastIndex()) } append 由领导人负责调用，由领导人只附加原则决定其只追加新日志到模块中。因为 Raft 的日志具有连续性，追加时要保证第一条追加的日志要紧接着日志模块的最后一条日志。tryAppend 由跟随者调用，正常情况下领导人发送的日志可以直接追加到跟随者的日志模块中。跟随者可能是新加入集群，并通过快照已经恢复到了快照所处的状态，此时也可以直接追加到日志模块里。当跟随者出现网络隔离导致日志远低于领导人复制来的第一条日志项（重新选举时），或日志项与领导人提供的存在冲突。如果第一条日志存在冲突，那么需要提醒领导人发送合适的日志；如果仅仅部分日志存在冲突，跟随者需要丢弃冲突日志，然后将领导人提供的日志追加到日志模块中（根据日志匹配原则），此时需要保证不能抛弃任何已经提交的日志（状态机安全性和领导人完全性）。 tryAppend 的第一步是找出第一个与现有日志存在冲突的日志索引，然后根据冲突索引丢弃存在冲突的日志，并返回。tryAppend 的返回值表示是否成功的将日志追加到系统中。Raft 论文 5.3 节提出了一个优化方式，算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化，这里可以使用算法给出的一种优化方式：当附加日志 RPC 的请求被拒绝的时候，跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。因此在拒绝该追加请求时，还给领导人返回提示索引。 func (holder *LogHolder) getHintIndex(prevIdx, prevTerm uint64) uint64 { utils.Assert(prevIdx != InvalidIndex &amp;&amp; prevTerm != InvalidTerm, "%d get hint index with invalid idx or Term", holder.id) idx := prevIdx term := holder.Term(idx) for idx &gt; InvalidIndex { if holder.Term(idx) != term { return utils.MaxUint64(holder.commitIndex, idx) } idx-- } return holder.commitIndex } // findConflict return the first index which Entries[i].Term is not equal // to holder.Term(Entries[i].Index), if all Term with same index are equals, // return zero. func (holder *LogHolder) findConflict(entries []raftpd.Entry) uint64 { for i := 0; i &lt; len(entries); i++ { entry := &amp;entries[i] if holder.Term(entry.Index) != entry.Term { if entry.Index &lt;= holder.lastIndex() { log.Infof("%d found conflict at index %d, "+ "[existing Term: %d, conflicting Term: %d]", holder.id, entry.Index, holder.Term(entry.Index), entry.Term) } return entry.Index } } return 0 } func (holder *LogHolder) TryAppend(prevIdx, prevTerm, leaderCommittedIdx uint64, entries []raftpd.Entry) (uint64, bool) { lastIdxOfEntries := prevIdx + (uint64)(len(entries)) if holder.Term(prevIdx) == prevTerm { conflictIdx := holder.findConflict(entries) if conflictIdx == 0 { /* success, no conflict */ } else if conflictIdx &lt;= holder.commitIndex { log.Panicf("%d entry %d conflict with committed entry %d", holder.id, conflictIdx, holder.commitIndex) } else { offset := prevIdx + 1 holder.Append(entries[conflictIdx-offset:]) } return lastIdxOfEntries, true } else { utils.Assert(prevIdx &gt; holder.commitIndex, "%d entry %d [Term: %d] conflict with committed entry Term: %d", holder.id, prevIdx, prevTerm, holder.Term(prevIdx)) return holder.getHintIndex(prevIdx, prevTerm), false } } done 至此，日志模块的实现就结束了。日志模块是整个 Raft 算法的基础，这里将日志模块剥离出来，并将提供一些原子方法。每个方法只干一件事，从而使分析方法正确性的分析更容易；每个方法都可以看作是纯函数，所以输入一定，输出则一定。实际上分布式程序的调试是一个非常困难的方式： 你的并发模型往往会成为你代码库中的病毒。你希望有细粒度的并发控制，好吧，你得到了，代码里到处都是。因此是并发导致了不确定性，而不确定性造成了麻烦。因此必须得把并发给踢出去。可是你又不能抛弃并发，你需要它。那么，你一定要禁止把并发和你的分布式状态机结合在一起。换句话说，你的分布式状态机必须成为纯函数式的。没有IO操作，没有并发，什么都没有。[3] 好的办法是将其抽象成纯函数式的，通过消息进行驱动，这样能够对程序拥有控制力，出现问题是可以完美重现，也能够跟踪定位到问题所在。从 Raft 算法的角度看，在上面的实现里，日志模块只是一个黑匣子，每个操作好比一个按钮，如果得到的不是想要的结果，那肯定是输入有问题（前提是黑匣子实现正确）。因此上面的代码很好的解开了算法和日志模块的耦合，隔离了双方的错误干扰。 References 预写式日志 寻找一种易于理解的一致性算法（扩展版） 分布式系统编程，你到哪一级了？]]></summary></entry></feed>