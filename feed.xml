<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-03-29T19:24:53+08:00</updated><id>/feed.xml</id><title type="html">W41ter’s Bistro</title><subtitle>Focus on distributed storage system, compiler.</subtitle><entry><title type="html">HotRing - A Hotspot Aware In-Memory Key-Value Store</title><link href="/papers/2022/03/29/HotRing-A-Hotspot-Aware-In-Memory-Key-Value-Store.html" rel="alternate" type="text/html" title="HotRing - A Hotspot Aware In-Memory Key-Value Store" /><published>2022-03-29T00:00:00+08:00</published><updated>2022-03-29T00:00:00+08:00</updated><id>/papers/2022/03/29/HotRing-A-Hotspot-Aware-In-Memory-Key-Value-Store</id><content type="html" xml:base="/papers/2022/03/29/HotRing-A-Hotspot-Aware-In-Memory-Key-Value-Store.html"><![CDATA[<p>在 Alibaba 的生产环境中，KVS 的请求里有 50%-90% 只访问了 1% 的数据。如下图：</p>

<p><img src="/uploads/images/2022/hotring-1.png" alt="Figure 1: Access ratio of different keys." /></p>

<p>实现 KVS 有很多可用的索引结构，其中 HASH 用得最多。目前的 HASH 算法并没有优化热点访问，也就是说读取一条热点数据，所付出的代价和读取其他数据是一样的。如下图，传统 HASH INDEX 结构的热点数据可能分布在 collision chaining 的任意位置。</p>

<p><img src="/uploads/images/2022/hotring-2.png" alt="Figure 2: The conventional hash index structure" /></p>

<p>理想情况下，查找一条数据的内存访问次数应该和它的冷热层度负相关。</p>

<p><img src="/uploads/images/2022/hotring-3.png" alt="Figure 3: Expected memory accesses for an index lookup" /></p>

<p>想要达到理想的情况，需要解决两个问题：</p>
<ol>
  <li>检测并适应 hotspot shift</li>
  <li>concurrent access</li>
</ol>

<h2 id="hotring">HotRing</h2>

<p>论文的做法是：针对问题 1，将传统哈希表中的 collision chain 替换成 ordered-ring。如果热点发生迁移，那么直接将 bucket header 指向新的热点 item 即可。针对问题 2，采用 lock-free 设计。</p>

<p><img src="/uploads/images/2022/hotring-4.png" alt="Figure 4: The index structure of HotRing" /></p>

<p>ordered ring 的结构如上图所示，整个 ring 首尾相连，一旦发现热点迁移，只需要将 bucket 的 header 更新到新热点 item 即可。这样做的好处是热点迁移时无需重新给 ring 上数据排序。</p>

<p>查找时从 header 开始，遍历整个 ring ；同时 Ring 上的数据会按照 <code class="language-plaintext highlighter-rouge">&lt;tag, key&gt;</code> 的顺序插入到合适的位置。这样做的目的是：</p>
<ul>
  <li>tag 主要用来避免对 key 的比较</li>
  <li>顺序则是用于查询时判断 ring 是否结束，否则查找时可能会受到并发更新操作的影响，无法判断是否已经遍历完整个 ring。</li>
</ul>

<p><img src="/uploads/images/2022/hotring-5.png" alt="Figure 5: Lookup Termination" /></p>

<p>此外，排序还有另一个好处，根据 termination 条件，平均查找次数约为传统 collision chain 实现方式的一半。</p>

<h2 id="hotspot-shift-identification">Hotspot Shift Identification</h2>

<p>由于 hash 的 strongly uniformed distribution，可以认为热点数据也分布在各个 bucket 中，热点迁移识别的工作主要在 bucket 内部。</p>

<p>论文提出了两种识别方式：</p>
<ol>
  <li>random movement</li>
  <li>statistical sampling</li>
</ol>

<p>第一种方式是每隔 R 个请求，如果第 R 个请求是 hot access，则不做任何改变；如果第 R 个请求是 cold access ，那么这个请求对应的 item 会成为新的 hot item。</p>

<p>这种方式是一个简单的概率实现，其缺点也非常明显：参数 R 的大小显著影响热点识别效果；如果数据访问频率分布是均匀的，或者 collision ring 中有多个热点，那么 head pointer 可能会频繁在这些热点中跳变；</p>

<p>另一种方式则是在 item 里记录下访问次数，根据次数选择出合适的 item 来作为新的 hot item。</p>

<blockquote>
  <p>猜想：是否可以使用 thread-local 级别的数据采样算法，来得到更为精确的数据，同时也避免了不必要的 CAS 操作？</p>
</blockquote>

<p><img src="/uploads/images/2022/hotring-6.png" alt="Figure 6: Index Format" /></p>

<p>如上图所示，每个 head pointer 的前 16bits 和 item pointer 其中的 14 bits 用于存储采样信息。其中 Active 表示在这条 collision ring 上开启采样，它主要是为了进行优化：为了确保采样不对正常读写造成影响，默认情况下 Active 为 false；每 R 个请求进行一次判断，如果仍然是 hot access，则认为目前的 hot item 仍然是准确的；否则才设置 Active 为 true。一旦 Active 被设置，后续请求需要同时使用 CAS 更新 Total Counter 和 Item 的 Counter。</p>

<p>采样完成后，最后一个访问的线程负责计算 collision ring 上每个 item 的访问频率，并调整 hot item。（先清除 Active 的标记）</p>

<h3 id="write-intensive-hotspot-with-rcu">Write-Intensive Hotspot with RCU</h3>

<p>HotRing 上的 key 是通过 read-copy-update 操作进行的。更改一个 key 时，需要遍历整个 collision ring ，找到待更新的 key 的前项，并更改其指针到新 item 上。所以更新操作的 Counter 应该需要记录到 hot item 的前一项中，这样算法就会选择前一项作为 hot item，因更新操作所需要的访问次数也因此降低。</p>

<p><img src="/uploads/images/2022/hotring-7.png" alt="Figure 7: Update a Hot Item A with RCU makes item F hot" /></p>

<h2 id="concurrent">Concurrent</h2>

<ul>
  <li>read: 读操作从 head pointer 开始遍历 HotRing，直到碰到终止条件</li>
  <li>insert: 找到合适位置，更新前一项的 Next Item Address 即可</li>
</ul>

<p>update 和 deletion 会复杂一些。对于 update，如果 value 在 8 字节内，可以直接通过 CAS 进行 in-place 更新。否则，需要使用两阶段提交的策略来避免异常。</p>

<p><img src="/uploads/images/2022/hotring-8.png" alt="Figure 8: Concurrent issues" /></p>

<p>如果 read-copy-update 和其他更新操作同时执行，就会上图所示的异常。以 RCU Update &amp; Insert 为例，由于 update B 和 insert C 同时进行，C 负责更新 B 的 Next Item Address，而此时 B’ 更新了 A 的 Next Item Address，最终 C 丢失，无法被访问。</p>

<p>解决方式是在 update\delete 某个 item 时，先标记上 Occupied bit，这样其他尝试更新该 Next Item Address 的请求会失败并进行重试，所以后续对这个 Item 进行的操作就是安全的。</p>

<h3 id="head-pointer-movement">Head Pointer Movement</h3>

<p>head pointer 同样也会受到并发操作的影响，主要有两种情况：</p>
<ol>
  <li>热点迁移导致的 head pointer 更新</li>
  <li>其他 update 和 deletion 操作</li>
</ol>

<p>对于 case 1，head pointer 在迁移前，需要设置新 hot item 为 Occupied 保证这个过程中该节点不会被 update 或 delete。</p>

<p>对于 update head pointer 指向的 item，只需要在替换时设置上新 item 的 Occupied 即可；对于 delete head pointer 指向的 item，还需要设置 head pointer 指向的新 item 的 Occupied。</p>

<h2 id="lock-free-rehash">Lock free Rehash</h2>

<p>传统的 Hash Table 使用 load factor 来出发 rehash，这个过程显然没有考虑到 hotspot 的影响。HotRing 使用 access overhead 来出发 rehash。</p>

<p>由于 HotRing 是有序的，rehash 时只需要从中间某个位置断开，生成两个新的 HotRing 即可。这个阶段主要分为三步：</p>

<p><img src="/uploads/images/2022/hotring-9.png" alt="Figure 9: Rehash" /></p>

<h2 id="评估">评估</h2>

<p>略</p>]]></content><author><name></name></author><category term="papers" /><category term="concurrent" /><summary type="html"><![CDATA[在 Alibaba 的生产环境中，KVS 的请求里有 50%-90% 只访问了 1% 的数据。如下图： 实现 KVS 有很多可用的索引结构，其中 HASH 用得最多。目前的 HASH 算法并没有优化热点访问，也就是说读取一条热点数据，所付出的代价和读取其他数据是一样的。如下图，传统 HASH INDEX 结构的热点数据可能分布在 collision chaining 的任意位置。 理想情况下，查找一条数据的内存访问次数应该和它的冷热层度负相关。 想要达到理想的情况，需要解决两个问题： 检测并适应 hotspot shift concurrent access HotRing 论文的做法是：针对问题 1，将传统哈希表中的 collision chain 替换成 ordered-ring。如果热点发生迁移，那么直接将 bucket header 指向新的热点 item 即可。针对问题 2，采用 lock-free 设计。 ordered ring 的结构如上图所示，整个 ring 首尾相连，一旦发现热点迁移，只需要将 bucket 的 header 更新到新热点 item 即可。这样做的好处是热点迁移时无需重新给 ring 上数据排序。 查找时从 header 开始，遍历整个 ring ；同时 Ring 上的数据会按照 &lt;tag, key&gt; 的顺序插入到合适的位置。这样做的目的是： tag 主要用来避免对 key 的比较 顺序则是用于查询时判断 ring 是否结束，否则查找时可能会受到并发更新操作的影响，无法判断是否已经遍历完整个 ring。 此外，排序还有另一个好处，根据 termination 条件，平均查找次数约为传统 collision chain 实现方式的一半。 Hotspot Shift Identification 由于 hash 的 strongly uniformed distribution，可以认为热点数据也分布在各个 bucket 中，热点迁移识别的工作主要在 bucket 内部。 论文提出了两种识别方式： random movement statistical sampling 第一种方式是每隔 R 个请求，如果第 R 个请求是 hot access，则不做任何改变；如果第 R 个请求是 cold access ，那么这个请求对应的 item 会成为新的 hot item。 这种方式是一个简单的概率实现，其缺点也非常明显：参数 R 的大小显著影响热点识别效果；如果数据访问频率分布是均匀的，或者 collision ring 中有多个热点，那么 head pointer 可能会频繁在这些热点中跳变； 另一种方式则是在 item 里记录下访问次数，根据次数选择出合适的 item 来作为新的 hot item。 猜想：是否可以使用 thread-local 级别的数据采样算法，来得到更为精确的数据，同时也避免了不必要的 CAS 操作？ 如上图所示，每个 head pointer 的前 16bits 和 item pointer 其中的 14 bits 用于存储采样信息。其中 Active 表示在这条 collision ring 上开启采样，它主要是为了进行优化：为了确保采样不对正常读写造成影响，默认情况下 Active 为 false；每 R 个请求进行一次判断，如果仍然是 hot access，则认为目前的 hot item 仍然是准确的；否则才设置 Active 为 true。一旦 Active 被设置，后续请求需要同时使用 CAS 更新 Total Counter 和 Item 的 Counter。 采样完成后，最后一个访问的线程负责计算 collision ring 上每个 item 的访问频率，并调整 hot item。（先清除 Active 的标记） Write-Intensive Hotspot with RCU HotRing 上的 key 是通过 read-copy-update 操作进行的。更改一个 key 时，需要遍历整个 collision ring ，找到待更新的 key 的前项，并更改其指针到新 item 上。所以更新操作的 Counter 应该需要记录到 hot item 的前一项中，这样算法就会选择前一项作为 hot item，因更新操作所需要的访问次数也因此降低。 Concurrent read: 读操作从 head pointer 开始遍历 HotRing，直到碰到终止条件 insert: 找到合适位置，更新前一项的 Next Item Address 即可 update 和 deletion 会复杂一些。对于 update，如果 value 在 8 字节内，可以直接通过 CAS 进行 in-place 更新。否则，需要使用两阶段提交的策略来避免异常。 如果 read-copy-update 和其他更新操作同时执行，就会上图所示的异常。以 RCU Update &amp; Insert 为例，由于 update B 和 insert C 同时进行，C 负责更新 B 的 Next Item Address，而此时 B’ 更新了 A 的 Next Item Address，最终 C 丢失，无法被访问。 解决方式是在 update\delete 某个 item 时，先标记上 Occupied bit，这样其他尝试更新该 Next Item Address 的请求会失败并进行重试，所以后续对这个 Item 进行的操作就是安全的。 Head Pointer Movement head pointer 同样也会受到并发操作的影响，主要有两种情况： 热点迁移导致的 head pointer 更新 其他 update 和 deletion 操作 对于 case 1，head pointer 在迁移前，需要设置新 hot item 为 Occupied 保证这个过程中该节点不会被 update 或 delete。 对于 update head pointer 指向的 item，只需要在替换时设置上新 item 的 Occupied 即可；对于 delete head pointer 指向的 item，还需要设置 head pointer 指向的新 item 的 Occupied。 Lock free Rehash 传统的 Hash Table 使用 load factor 来出发 rehash，这个过程显然没有考虑到 hotspot 的影响。HotRing 使用 access overhead 来出发 rehash。 由于 HotRing 是有序的，rehash 时只需要从中间某个位置断开，生成两个新的 HotRing 即可。这个阶段主要分为三步： 评估 略]]></summary></entry><entry><title type="html">探究 Linux 下 TCP 的 RST Packet</title><link href="/network/2019/01/26/Linux-TCP-Rst.html" rel="alternate" type="text/html" title="探究 Linux 下 TCP 的 RST Packet" /><published>2019-01-26T15:13:00+08:00</published><updated>2019-01-26T15:13:00+08:00</updated><id>/network/2019/01/26/Linux-TCP-Rst</id><content type="html" xml:base="/network/2019/01/26/Linux-TCP-Rst.html"><![CDATA[<blockquote>
  <p>注：<strong>本文结论来自网络，真实性未考究，请批判性阅读，如果谬误，请斧正。</strong>本文所讨论内容，均假设工作环境为 Linux 服务器。</p>
</blockquote>

<p>作为 TCP 不可或缺的一部分，TCP 包头的 <code class="language-plaintext highlighter-rouge">RST</code> 为 $1$ 时，表示重置，关闭异常链接。发送 RST 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送 <code class="language-plaintext highlighter-rouge">RST</code> 包。而接收端收到 <code class="language-plaintext highlighter-rouge">RST</code> 包后，也不必发送 <code class="language-plaintext highlighter-rouge">ACK</code> 包来确认。TCP 处理程序会在自己认为的异常时刻发送 <code class="language-plaintext highlighter-rouge">RST</code> 包。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>14:59:23.379829 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>R], <span class="nb">seq </span>4127385762, win 0, length 0
</code></pre></div></div>

<p><em>通过 tcpdump 观察，<code class="language-plaintext highlighter-rouge">Flags [R]</code> 表示该包携带了 <code class="language-plaintext highlighter-rouge">RST</code> 。</em></p>

<p><code class="language-plaintext highlighter-rouge">RST</code> 主要用在三种场景中，保证 TCP 链接的安全性，三种场景分别是：1、到不存在端口的连接请求；2、异常终止连接；3、检测半打开连接。接下来看看 <code class="language-plaintext highlighter-rouge">RST</code> 的具体表现。</p>

<h1 id="三种错误">三种错误</h1>

<p>内核中的 TCP 协议栈将收到 <code class="language-plaintext highlighter-rouge">RST</code> 的场景分为三种，并抛出了对应的错误。</p>

<h2 id="connection-refused">connection refused</h2>

<p>当内核中的 TCP 协议栈收到了 <code class="language-plaintext highlighter-rouge">SYN</code> 请求，但是该端口上没有处于监听状态，则相应 <code class="language-plaintext highlighter-rouge">RST</code>，此时 client 看到的便是 <code class="language-plaintext highlighter-rouge">connection refused</code>。</p>

<h2 id="broken-pipe">broken pipe</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">fd</code> is connected to a pipe or socket whose reading end is closed.  When this happens the writing process will also receive a SIGPIPE signal.(Thus, the write return value is seen only if the program catches, blocks or ignores this signal.)</p>
</blockquote>

<p>简单的说，如果<strong>已知</strong>远端读通道已经被关闭，而应用程序仍然在调用 <code class="language-plaintext highlighter-rouge">write</code>(2) 尝试向 socket 中写入数据，TCP 协议栈便会抛出 <code class="language-plaintext highlighter-rouge">broken pipe</code>。</p>

<h2 id="connection-reset-by-peer">connection reset by peer</h2>

<blockquote>
  <p>A network connection was closed for reasons outside the control of the local host, such as by the remote machine rebooting or an unrecoverable protocol violation.</p>
</blockquote>

<p>如果远端已经 <code class="language-plaintext highlighter-rouge">close</code>(2) 连接了，本地服务仍发送了数据，此时 TCP 协议栈便会抛出 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<h1 id="broken-pipe-和-connection-reset-by-peer">broken pipe 和 connection reset by peer</h1>

<p>无论是 <code class="language-plaintext highlighter-rouge">broken pipe</code> 还是 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>，都是收到 <code class="language-plaintext highlighter-rouge">RST</code> 的表现，二者有何不同呢？</p>

<p>为了进一步研究，这里尝试着构建两个场景，分别重现 <code class="language-plaintext highlighter-rouge">broken pipe</code> 和 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<h2 id="重现-broken-pipe">重现 broken pipe</h2>

<p>首先，在服务中监听端口，每个连接分多次写入数据，然后关闭连接。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">server</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Acceptor</span> <span class="n">acceptor</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="n">InetAddress</span><span class="o">::</span><span class="n">parseV4</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">9490</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg1</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">,</span> <span class="o">*</span><span class="n">msg2</span> <span class="o">=</span> <span class="s">"world"</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">acceptor</span><span class="p">.</span><span class="n">accept</span><span class="p">();</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                        <span class="c1">// wait client shutdown</span>
        <span class="n">conn</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg1</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg1</span><span class="p">));</span>  <span class="c1">// write success, but RST recieved</span>
        <span class="n">conn</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg2</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg2</span><span class="p">));</span>  <span class="c1">// throw `broken pipe`</span>
    <span class="p">}</span> <span class="c1">// RAII close conn socket</span>
<span class="p">}</span> <span class="c1">// RAII close acceptor socket</span>
</code></pre></div></div>

<p>然后客户端连接到服务端，并立即关闭连接。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">client</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Connector</span> <span class="n">connector</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="n">InetAddress</span><span class="o">::</span><span class="n">parseV4</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">9490</span><span class="p">);</span>
    <span class="n">connector</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// RAII close connector socket</span>
</code></pre></div></div>

<p>通过 tcpdump 观察程序运行时请求：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>tcpdump <span class="nt">-i</span> lo <span class="s1">'(src host 127.0.0.1) and (port 9490)'</span>  <span class="nt">-B</span> 4096
14:59:13.376906 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>S], <span class="nb">seq </span>4127385760, win 43690, options <span class="o">[</span>mss 65495,sackOK,TS val 168040030 ecr 0,nop,wscale 10], length 0
14:59:13.376919 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>S.], <span class="nb">seq </span>2306780414, ack 4127385761, win 43690, options <span class="o">[</span>mss 65495,sackOK,TS val 168040030 ecr 168040030,nop,wscale 10], length 0
14:59:13.376928 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 1, win 43, options <span class="o">[</span>nop,nop,TS val 168040030 ecr 168040030], length 0
14:59:13.377089 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>P.], <span class="nb">seq </span>1:2, ack 1, win 43, options <span class="o">[</span>nop,nop,TS val 168040030 ecr 168040030], length 1
14:59:13.377223 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 2, win 43, options <span class="o">[</span>nop,nop,TS val 168040030 ecr 168040030], length 0
14:59:14.377352 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>P.], <span class="nb">seq </span>2:3, ack 1, win 43, options <span class="o">[</span>nop,nop,TS val 168040280 ecr 168040030], length 1
14:59:14.377439 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 3, win 43, options <span class="o">[</span>nop,nop,TS val 168040280 ecr 168040280], length 0
// ....
14:59:22.379462 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>P.], <span class="nb">seq </span>10:11, ack 1, win 43, options <span class="o">[</span>nop,nop,TS val 168042281 ecr 168042031], length 1
14:59:22.379489 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 11, win 43, options <span class="o">[</span>nop,nop,TS val 168042281 ecr 168042281], length 0
14:59:22.379626 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>F.], <span class="nb">seq </span>1, ack 11, win 43, options <span class="o">[</span>nop,nop,TS val 168042281 ecr 168042281], length 0
14:59:22.382190 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>.], ack 2, win 43, options <span class="o">[</span>nop,nop,TS val 168042282 ecr 168042281], length 0
14:59:23.379808 IP localhost.9490 <span class="o">&gt;</span> localhost.62412: Flags <span class="o">[</span>P.], <span class="nb">seq </span>11:12, ack 2, win 43, options <span class="o">[</span>nop,nop,TS val 168042531 ecr 168042281], length 1
14:59:23.379829 IP localhost.62412 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>R], <span class="nb">seq </span>4127385762, win 0, length 0
</code></pre></div></div>

<p><em>上述 log 为实验过程中，和上面上面的代码略有出入。</em></p>

<p>可以观察到，client <code class="language-plaintext highlighter-rouge">close</code>(2)，发送了 <code class="language-plaintext highlighter-rouge">FIN</code> 给 server，并收到了 <code class="language-plaintext highlighter-rouge">ACK</code>。server 此时再次尝试 <code class="language-plaintext highlighter-rouge">write</code>(2)，便抛出了 <code class="language-plaintext highlighter-rouge">broken pipe</code> 异常。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">server</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em><code class="language-plaintext highlighter-rouge">server</code> 调用方式。</em></p>

<h3 id="sigpipe-与-broken-pipe">SIGPIPE 与 broken pipe</h3>

<p>按照预期，当 socket 抛出 <code class="language-plaintext highlighter-rouge">broken pipe</code> 时，会被最外层 <code class="language-plaintext highlighter-rouge">try</code> 和 <code class="language-plaintext highlighter-rouge">catch</code> 抓住，并输出。实际上运行结果为：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./server
<span class="nv">$ </span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
141
<span class="nv">$ </span>
</code></pre></div></div>

<p><em>某次 server 端运行结果，没有任何输出，程序返回值为 $141$。</em></p>

<p>内核中 TCP 栈如果已经接收到 <code class="language-plaintext highlighter-rouge">RST</code>，那么下一次使用 <code class="language-plaintext highlighter-rouge">write</code>(2) 时，除了会返回 <code class="language-plaintext highlighter-rouge">broken pipe</code> 外，还会产生 <code class="language-plaintext highlighter-rouge">SIGPIPE</code>，默认情况下这个信号会终止整个进程，当然你并不想让进程被 <code class="language-plaintext highlighter-rouge">SIGPIPE</code> 信号杀死。对 server 来说，为了不被 <code class="language-plaintext highlighter-rouge">SIGPIPE</code> 信号杀死，那就需要忽略 <code class="language-plaintext highlighter-rouge">SIGPIPE</code> 信号：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
</code></pre></div></div>

<p>最后，让我们整体分析下 <code class="language-plaintext highlighter-rouge">broken pipe</code> 产生方式：</p>

<ol>
  <li>client 发送了 <code class="language-plaintext highlighter-rouge">FIN</code> 给 server；</li>
  <li>server 仍给 client 发送数据，client 回复 <code class="language-plaintext highlighter-rouge">RST</code>；</li>
  <li>server 收到 <code class="language-plaintext highlighter-rouge">RST</code> 后，再次给 client 发送数据；往一个已经收到 <code class="language-plaintext highlighter-rouge">RST</code> 的 socket 继续写入数据，将引起 <code class="language-plaintext highlighter-rouge">SIGPIPE</code> 信号，<code class="language-plaintext highlighter-rouge">write</code>(2) 返回 <code class="language-plaintext highlighter-rouge">EPIPE</code>。</li>
</ol>

<h2 id="重现-connection-reset-by-peer">重现 <code class="language-plaintext highlighter-rouge">connection reset by peer</code></h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">server</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Acceptor</span> <span class="n">acceptor</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="n">InetAddress</span><span class="o">::</span><span class="n">parseV4</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">9490</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">acceptor</span><span class="p">.</span><span class="n">accept</span><span class="p">();</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>                       <span class="c1">// 给拔网线留下足够的时间</span>
    <span class="p">}</span> <span class="c1">// RAII close conn socket</span>
<span class="p">}</span> <span class="c1">// RAII close acceptor socket</span>
</code></pre></div></div>

<p><em>模拟服务端断线重启。</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">client</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Connector</span> <span class="n">connector</span> <span class="o">=</span> <span class="n">Socket</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">InetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="n">InetAddress</span><span class="o">::</span><span class="n">parseV4</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="mi">9490</span><span class="p">);</span>
    <span class="n">connector</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">120</span><span class="p">);</span> 

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
    <span class="n">connector</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
<span class="p">}</span> <span class="c1">// RAII close connector socket</span>
</code></pre></div></div>

<p><em>一段时间后，再给服务器发送请求，此时服务器已经重启。</em></p>

<p>这里构造了这样一个场景，与客户端建立连接后，服务端由于不可抗力，比如断电，未能发送 <code class="language-plaintext highlighter-rouge">FIN</code> 给客户端。当服务器重启后，内核中 TCP 协议栈收到了客户端的数据包，回应 <code class="language-plaintext highlighter-rouge">RST</code>，此时客户端抛出 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>tcpdump <span class="nt">-i</span> lo <span class="s1">'(src host 127.0.0.1) and (port 9490)'</span>  <span class="nt">-B</span> 4096
15:43:12.638464 IP localhost.21316 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>S], <span class="nb">seq </span>3640034867, win 43690, options <span class="o">[</span>mss 65495,sackOK,TS val 168699846 ecr 0,nop,wscale 10], length 0
15:43:12.638478 IP localhost.9490 <span class="o">&gt;</span> localhost.21316: Flags <span class="o">[</span>S.], <span class="nb">seq </span>485213568, ack 3640034868, win 43690, options <span class="o">[</span>mss 65495,sackOK,TS val 168699846 ecr 168699846,nop,wscale 10], length 0
15:43:16.639791 IP localhost.9490 <span class="o">&gt;</span> localhost.21316: Flags <span class="o">[</span>P.], <span class="nb">seq </span>5:6, ack 6, win 43, options <span class="o">[</span>nop,nop,TS val 168700846 ecr 168700596], length 1
15:43:16.639807 IP localhost.21316 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 6, win 43, options <span class="o">[</span>nop,nop,TS val 168700846 ecr 168700846], length 0
15:43:17.640127 IP localhost.9490 <span class="o">&gt;</span> localhost.21316: Flags <span class="o">[</span>P.], <span class="nb">seq </span>6:7, ack 6, win 43, options <span class="o">[</span>nop,nop,TS val 168701096 ecr 168700846], length 1
15:43:17.640137 IP localhost.21316 <span class="o">&gt;</span> localhost.9490: Flags <span class="o">[</span>.], ack 7, win 43, options <span class="o">[</span>nop,nop,TS val 168701096 ecr 168701096], length 0
15:43:18.170130 IP localhost.9490 <span class="o">&gt;</span> localhost.21316: Flags <span class="o">[</span>R.], <span class="nb">seq </span>7, ack 6, win 43, options <span class="o">[</span>nop,nop,TS val 168701228 ecr 168701096], length 0
</code></pre></div></div>

<p><em>某次模拟 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</em></p>

<hr />

<p>这里从读写两个角度来看 <code class="language-plaintext highlighter-rouge">RST</code>，如果已经 <code class="language-plaintext highlighter-rouge">ACK</code> 远端的 <code class="language-plaintext highlighter-rouge">FIN</code> 包：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">read</code>(2) ：返回 0，表示 eof；</li>
  <li><code class="language-plaintext highlighter-rouge">write</code>(2) ：远端返回 <code class="language-plaintext highlighter-rouge">RST</code>，抛出 <code class="language-plaintext highlighter-rouge">broken pipe</code>；</li>
</ol>

<p>如果尚未接收到远端的 <code class="language-plaintext highlighter-rouge">FIN</code> 包，无论读写操作，收到 <code class="language-plaintext highlighter-rouge">RST</code> 时，抛出 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<h2 id="what-more-">what more ？</h2>

<p>除了上述几个场景外，还有其他可能吗？</p>

<h3 id="强行关闭">强行关闭</h3>

<p>正常关闭 TCP 链接时，主动关闭一方会进入 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 状态，等待 2MSL（报文段最大生存时间-Maximum Segment Lifetime，根据具体的实现不同，这个值会不同），此时该端口处于不可用状态。</p>

<p>解决 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 有三种手段：</p>

<ol>
  <li>设置 <code class="language-plaintext highlighter-rouge">SO_REUSEADDR</code> 和 <code class="language-plaintext highlighter-rouge">SO_REUSEPORT</code>；</li>
  <li>修改 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 等待时长；</li>
  <li>设置 <code class="language-plaintext highlighter-rouge">SO_LINGER</code>，强行关闭。</li>
</ol>

<p>设置 socket 选项 <code class="language-plaintext highlighter-rouge">SO_LINGER</code> 为 <code class="language-plaintext highlighter-rouge">(on, 0)</code> 后，<code class="language-plaintext highlighter-rouge">close</code>(2) 将立即向对端发送 <code class="language-plaintext highlighter-rouge">RST</code>，这种关闭方式称为“强行关闭”。而被动关闭方却不知道对端已经彻底断开，所以紧接着的读写操作，引发 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>。</p>

<h3 id="数据滞留">数据滞留</h3>

<p>socket 关闭时，如果接收窗口仍有数据滞留，那么会直接发送 <code class="language-plaintext highlighter-rouge">RST</code> ，不会进入正常的 <code class="language-plaintext highlighter-rouge">FIN</code> 流程。可以参考：<a href="http://cs.ecs.baylor.edu/~donahoo/practical/CSockets/TCPRST.pdf">TCP RST: Calling close() on a socket with data in the receive queue</a>。</p>

<p>和“强行关闭”一样，数据滞留也会导致被动关闭方引发 <code class="language-plaintext highlighter-rouge">connection reset by peer</code>，这样造成的结果是：如果你的服务各种指标正常，但是有非常多的 <code class="language-plaintext highlighter-rouge">connection reset by peer</code> 警告，可能就是服务上游超时 <code class="language-plaintext highlighter-rouge">close</code>(2) socket，而由于接收窗口仍有数据滞留，发送了 <code class="language-plaintext highlighter-rouge">RST</code>。</p>

<h1 id="references">References</h1>

<p>[1] <a href="/2017/05/26/Linux-TCP-%E7%BC%96%E7%A8%8B/">Linux TCP 编程</a></p>

<p>[2] <a href="http://senlinzhan.github.io/2017/03/02/sigpipe/">网络编程中 SIGPIPE 信号</a></p>

<p>[3] <a href="http://xiangruix.com/2016/01/12/tcp-closed-without-fin/">Linux 下 TCP 连接断开未发送 FIN</a></p>

<p>[4] <a href="http://itindex.net/detail/56132-tcp-time-wait">TCP关闭连接(为什么会能Time_wait,Close_wait?)</a></p>]]></content><author><name></name></author><category term="Network" /><category term="Linux" /><category term="TCP/IP" /><category term="Socket" /><summary type="html"><![CDATA[注：本文结论来自网络，真实性未考究，请批判性阅读，如果谬误，请斧正。本文所讨论内容，均假设工作环境为 Linux 服务器。 作为 TCP 不可或缺的一部分，TCP 包头的 RST 为 $1$ 时，表示重置，关闭异常链接。发送 RST 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送 RST 包。而接收端收到 RST 包后，也不必发送 ACK 包来确认。TCP 处理程序会在自己认为的异常时刻发送 RST 包。 14:59:23.379829 IP localhost.62412 &gt; localhost.9490: Flags [R], seq 4127385762, win 0, length 0 通过 tcpdump 观察，Flags [R] 表示该包携带了 RST 。 RST 主要用在三种场景中，保证 TCP 链接的安全性，三种场景分别是：1、到不存在端口的连接请求；2、异常终止连接；3、检测半打开连接。接下来看看 RST 的具体表现。 三种错误 内核中的 TCP 协议栈将收到 RST 的场景分为三种，并抛出了对应的错误。 connection refused 当内核中的 TCP 协议栈收到了 SYN 请求，但是该端口上没有处于监听状态，则相应 RST，此时 client 看到的便是 connection refused。 broken pipe fd is connected to a pipe or socket whose reading end is closed. When this happens the writing process will also receive a SIGPIPE signal.(Thus, the write return value is seen only if the program catches, blocks or ignores this signal.) 简单的说，如果已知远端读通道已经被关闭，而应用程序仍然在调用 write(2) 尝试向 socket 中写入数据，TCP 协议栈便会抛出 broken pipe。 connection reset by peer A network connection was closed for reasons outside the control of the local host, such as by the remote machine rebooting or an unrecoverable protocol violation. 如果远端已经 close(2) 连接了，本地服务仍发送了数据，此时 TCP 协议栈便会抛出 connection reset by peer。 broken pipe 和 connection reset by peer 无论是 broken pipe 还是 connection reset by peer，都是收到 RST 的表现，二者有何不同呢？ 为了进一步研究，这里尝试着构建两个场景，分别重现 broken pipe 和 connection reset by peer。 重现 broken pipe 首先，在服务中监听端口，每个连接分多次写入数据，然后关闭连接。 int server() { Acceptor acceptor = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4("127.0.0.1", 9490); acceptor.bind(address); acceptor.listen(10); const char *msg1 = "hello", *msg2 = "world"; while (true) { Connection conn = acceptor.accept(); sleep(1); // wait client shutdown conn.write(msg1, strlen(msg1)); // write success, but RST recieved conn.write(msg2, strlen(msg2)); // throw `broken pipe` } // RAII close conn socket } // RAII close acceptor socket 然后客户端连接到服务端，并立即关闭连接。 int client() { Connector connector = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4("127.0.0.1", 9490); connector.connect(address); } // RAII close connector socket 通过 tcpdump 观察程序运行时请求： $ sudo tcpdump -i lo '(src host 127.0.0.1) and (port 9490)' -B 4096 14:59:13.376906 IP localhost.62412 &gt; localhost.9490: Flags [S], seq 4127385760, win 43690, options [mss 65495,sackOK,TS val 168040030 ecr 0,nop,wscale 10], length 0 14:59:13.376919 IP localhost.9490 &gt; localhost.62412: Flags [S.], seq 2306780414, ack 4127385761, win 43690, options [mss 65495,sackOK,TS val 168040030 ecr 168040030,nop,wscale 10], length 0 14:59:13.376928 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 1, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 0 14:59:13.377089 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 1:2, ack 1, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 1 14:59:13.377223 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 2, win 43, options [nop,nop,TS val 168040030 ecr 168040030], length 0 14:59:14.377352 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 2:3, ack 1, win 43, options [nop,nop,TS val 168040280 ecr 168040030], length 1 14:59:14.377439 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 3, win 43, options [nop,nop,TS val 168040280 ecr 168040280], length 0 // .... 14:59:22.379462 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 10:11, ack 1, win 43, options [nop,nop,TS val 168042281 ecr 168042031], length 1 14:59:22.379489 IP localhost.62412 &gt; localhost.9490: Flags [.], ack 11, win 43, options [nop,nop,TS val 168042281 ecr 168042281], length 0 14:59:22.379626 IP localhost.62412 &gt; localhost.9490: Flags [F.], seq 1, ack 11, win 43, options [nop,nop,TS val 168042281 ecr 168042281], length 0 14:59:22.382190 IP localhost.9490 &gt; localhost.62412: Flags [.], ack 2, win 43, options [nop,nop,TS val 168042282 ecr 168042281], length 0 14:59:23.379808 IP localhost.9490 &gt; localhost.62412: Flags [P.], seq 11:12, ack 2, win 43, options [nop,nop,TS val 168042531 ecr 168042281], length 1 14:59:23.379829 IP localhost.62412 &gt; localhost.9490: Flags [R], seq 4127385762, win 0, length 0 上述 log 为实验过程中，和上面上面的代码略有出入。 可以观察到，client close(2)，发送了 FIN 给 server，并收到了 ACK。server 此时再次尝试 write(2)，便抛出了 broken pipe 异常。 int main(int argc, char** argv) { try { return server(); } catch (Exception&amp; e) { cout &lt;&lt; e.what() &lt;&lt; endl; return -1; } } server 调用方式。 SIGPIPE 与 broken pipe 按照预期，当 socket 抛出 broken pipe 时，会被最外层 try 和 catch 抓住，并输出。实际上运行结果为： $ ./server $ $ echo $? 141 $ 某次 server 端运行结果，没有任何输出，程序返回值为 $141$。 内核中 TCP 栈如果已经接收到 RST，那么下一次使用 write(2) 时，除了会返回 broken pipe 外，还会产生 SIGPIPE，默认情况下这个信号会终止整个进程，当然你并不想让进程被 SIGPIPE 信号杀死。对 server 来说，为了不被 SIGPIPE 信号杀死，那就需要忽略 SIGPIPE 信号： signal(SIGPIPE, SIG_IGN); 最后，让我们整体分析下 broken pipe 产生方式： client 发送了 FIN 给 server； server 仍给 client 发送数据，client 回复 RST； server 收到 RST 后，再次给 client 发送数据；往一个已经收到 RST 的 socket 继续写入数据，将引起 SIGPIPE 信号，write(2) 返回 EPIPE。 重现 connection reset by peer int server() { Acceptor acceptor = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4("127.0.0.1", 9490); acceptor.bind(address); acceptor.listen(10); while (true) { Connection conn = acceptor.accept(); sleep(10); // 给拔网线留下足够的时间 } // RAII close conn socket } // RAII close acceptor socket 模拟服务端断线重启。 int client() { Connector connector = Socket::create(AF_INET, SOCK_STREAM, 0); InetAddress address = InetAddress::parseV4("127.0.0.1", 9490); connector.connect(address); sleep(120); const char *msg = "hello"; connector.write(msg, strlen(msg)); } // RAII close connector socket 一段时间后，再给服务器发送请求，此时服务器已经重启。 这里构造了这样一个场景，与客户端建立连接后，服务端由于不可抗力，比如断电，未能发送 FIN 给客户端。当服务器重启后，内核中 TCP 协议栈收到了客户端的数据包，回应 RST，此时客户端抛出 connection reset by peer。 $ sudo tcpdump -i lo '(src host 127.0.0.1) and (port 9490)' -B 4096 15:43:12.638464 IP localhost.21316 &gt; localhost.9490: Flags [S], seq 3640034867, win 43690, options [mss 65495,sackOK,TS val 168699846 ecr 0,nop,wscale 10], length 0 15:43:12.638478 IP localhost.9490 &gt; localhost.21316: Flags [S.], seq 485213568, ack 3640034868, win 43690, options [mss 65495,sackOK,TS val 168699846 ecr 168699846,nop,wscale 10], length 0 15:43:16.639791 IP localhost.9490 &gt; localhost.21316: Flags [P.], seq 5:6, ack 6, win 43, options [nop,nop,TS val 168700846 ecr 168700596], length 1 15:43:16.639807 IP localhost.21316 &gt; localhost.9490: Flags [.], ack 6, win 43, options [nop,nop,TS val 168700846 ecr 168700846], length 0 15:43:17.640127 IP localhost.9490 &gt; localhost.21316: Flags [P.], seq 6:7, ack 6, win 43, options [nop,nop,TS val 168701096 ecr 168700846], length 1 15:43:17.640137 IP localhost.21316 &gt; localhost.9490: Flags [.], ack 7, win 43, options [nop,nop,TS val 168701096 ecr 168701096], length 0 15:43:18.170130 IP localhost.9490 &gt; localhost.21316: Flags [R.], seq 7, ack 6, win 43, options [nop,nop,TS val 168701228 ecr 168701096], length 0 某次模拟 connection reset by peer。 这里从读写两个角度来看 RST，如果已经 ACK 远端的 FIN 包： read(2) ：返回 0，表示 eof； write(2) ：远端返回 RST，抛出 broken pipe； 如果尚未接收到远端的 FIN 包，无论读写操作，收到 RST 时，抛出 connection reset by peer。 what more ？ 除了上述几个场景外，还有其他可能吗？ 强行关闭 正常关闭 TCP 链接时，主动关闭一方会进入 TIME_WAIT 状态，等待 2MSL（报文段最大生存时间-Maximum Segment Lifetime，根据具体的实现不同，这个值会不同），此时该端口处于不可用状态。 解决 TIME_WAIT 有三种手段： 设置 SO_REUSEADDR 和 SO_REUSEPORT； 修改 TIME_WAIT 等待时长； 设置 SO_LINGER，强行关闭。 设置 socket 选项 SO_LINGER 为 (on, 0) 后，close(2) 将立即向对端发送 RST，这种关闭方式称为“强行关闭”。而被动关闭方却不知道对端已经彻底断开，所以紧接着的读写操作，引发 connection reset by peer。 数据滞留 socket 关闭时，如果接收窗口仍有数据滞留，那么会直接发送 RST ，不会进入正常的 FIN 流程。可以参考：TCP RST: Calling close() on a socket with data in the receive queue。 和“强行关闭”一样，数据滞留也会导致被动关闭方引发 connection reset by peer，这样造成的结果是：如果你的服务各种指标正常，但是有非常多的 connection reset by peer 警告，可能就是服务上游超时 close(2) socket，而由于接收窗口仍有数据滞留，发送了 RST。 References [1] Linux TCP 编程 [2] 网络编程中 SIGPIPE 信号 [3] Linux 下 TCP 连接断开未发送 FIN [4] TCP关闭连接(为什么会能Time_wait,Close_wait?)]]></summary></entry><entry><title type="html">nsq read notes</title><link href="/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/2019/01/03/nsq-read-notes.html" rel="alternate" type="text/html" title="nsq read notes" /><published>2019-01-03T08:00:00+08:00</published><updated>2019-01-03T08:00:00+08:00</updated><id>/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/2019/01/03/nsq-read-notes</id><content type="html" xml:base="/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/2019/01/03/nsq-read-notes.html"><![CDATA[<h1 id="nsqd">nsqd</h1>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">topicMap</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="n">Topic</span>
<span class="n">clientMap</span> <span class="k">map</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="o">*</span><span class="n">Client</span>
</code></pre></div></div>

<h2 id="初始化过程">初始化过程</h2>

<ol>
  <li>new</li>
  <li>load meta data</li>
  <li>persist meta data</li>
  <li>main
    <ol>
      <li>listen tcp &amp; http port, start server</li>
      <li>start queueScanLoop, lookupLoop, statsLoop</li>
    </ol>
  </li>
</ol>

<p>有新连接到达时，会生成 connection 的 client，保存到 nsqd 的 clientMap 中，同时启动 goroutine 负责 client 的 messagePump。conn 所在的 goroutine 之后会负责读客户端的命令，并执行以及返回结果。可执行命令如下：</p>

<ol>
  <li>IDENTIFY: 表名身份</li>
  <li>FIN: 在 client 绑定的 channel 上，完成一条消息（调用 channel.FinishMessage），同时会更新当前 client 的 metrics 信息，以及状态</li>
  <li>RDY: 更新 client ready count</li>
  <li>REQ: 在 client 绑定的 channel 上，把一条消息重新送入队列（调用 channel.RequeueMessage），同时更新 metrics 和状态。这条消息会被放入 defered 队列，延后执行</li>
  <li>PUB: 往某个 client 有权限的 topic 发送一条消息（调用 topic.PutMessage），更新 metrics 状态</li>
  <li>MPUB: 和 PUB 一样，不过接收多条消息</li>
  <li>DPUB: 和 PUB 一样，不过会被放入 defered 队列</li>
  <li>NOP: 最简单，啥也不干</li>
  <li>TOUCH: 在 client 绑定的 channel 上，重置一条消息的过期时间（调用 channel.TouchMessage)</li>
  <li>SUB: 将 client 绑定到 channel 上，如果 topic 和 channel 任一个属于 “”, 且 topic 或 channel 正在关闭， client 会不断重试绑定操作。</li>
  <li>CLS: 关闭连接</li>
  <li>AUTH: 授权</li>
</ol>

<p>client 有多种状态：init, disconnect, connect, subscribe, closing ，状态迁移由一系列命令执行顺序决定。除此外还有 ready 状态，client 通过 RDY 更新了自己的 ready count，表示 client 最多同时处理多少条消息，如果 inflight count &gt;= ready count，则未 ready，需要等待。</p>

<p>client 使用 SUB 进入 subscribe 模式，该模式只能进入一次，进入后 messagePumb 会接收到 subEvent，然后从对应 channel 中读取 message 发送到 client 里。</p>

<h2 id="topic">topic</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">messageChan</span> <span class="k">chan</span> <span class="o">*</span><span class="n">Message</span>
<span class="n">backendChan</span> <span class="n">BackendChan</span>
<span class="n">channelsMap</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">Channels</span>
</code></pre></div></div>

<h3 id="topic-创建流程">topic 创建流程</h3>

<ol>
  <li>new topic, save to topicMap</li>
  <li>lookup each lookupd, get all channels in topic $TOPIC</li>
  <li>skip “#ephemeral” and create channels</li>
  <li>start topic messagePump</li>
</ol>

<h3 id="delete-channel">delete channel</h3>

<ol>
  <li>remove from topic channelsMap</li>
  <li>mark channel deleted</li>
  <li>if left channels is zero, and topic is ephemeral, delete topic self</li>
</ol>

<h3 id="put-messages">put messages</h3>

<ol>
  <li>try put message into memory message channel</li>
  <li>fallthrough into backend queue, most case into disk, but ephemeral just ignore</li>
  <li>update message count</li>
</ol>

<h3 id="message-pump">message pump</h3>

<ol>
  <li>read message from memory message channel</li>
  <li>else read from backend message</li>
  <li>else update channel status</li>
  <li>copy memory into each channels in current topic
    <ol>
      <li>if message is defered, put into channels defered</li>
      <li>else put into normal channels</li>
    </ol>
  </li>
</ol>

<h2 id="channel">channel</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clients</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">Consumer</span>
<span class="n">backend</span> <span class="n">BackendQueue</span>
<span class="n">memoryChan</span> <span class="k">chan</span> <span class="o">*</span><span class="n">Message</span>
<span class="n">deferedMessages</span> <span class="k">map</span><span class="p">[</span><span class="n">MessageID</span><span class="p">]</span><span class="o">*</span><span class="n">Message</span>
<span class="n">defredPQ</span> <span class="n">PriorityQueue</span>
<span class="n">inFlightMessages</span> <span class="k">map</span><span class="p">[</span><span class="n">MessageID</span><span class="p">]</span><span class="o">*</span><span class="n">Message</span>
<span class="n">inFlightPQ</span> <span class="n">PriorityQueue</span>
</code></pre></div></div>

<p>channel put message 和 topic put message 类似。put defered message 会把 message 放在deferedMessages 中，并加入 deferedPQ 中。如果 defered 时间到了，使用正常流程 put。clients 提供了 Add 和 Remove 接口，但管理职责不是 channel 的。</p>

<h1 id="nsqlookupd">nsqlookupd</h1>

<h2 id="nsqlookupd-数据组织方式">nsqlookupd 数据组织方式</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
	<span class="p">{</span><span class="s">"client"</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="s">""</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="s">"127.0.0.1:9490"</span> <span class="o">=&gt;</span> <span class="n">Producer</span><span class="p">{</span><span class="s">"127.0.0.1:8081"</span><span class="p">},</span>
		<span class="s">"127.0.0.1:9491"</span> <span class="o">=&gt;</span> <span class="n">Producer</span><span class="p">{</span><span class="s">"127.0.0.1:8081"</span><span class="p">},</span>
	<span class="p">},</span>

	<span class="p">{</span><span class="s">"channel"</span><span class="p">,</span> <span class="s">"topic_a"</span><span class="p">,</span> <span class="s">"channel_a"</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="s">"ip1"</span> <span class="o">=&gt;</span> <span class="n">Producer</span><span class="p">{</span><span class="s">"addr"</span><span class="p">},</span>
	<span class="p">},</span>
	<span class="p">{</span><span class="s">"topic"</span><span class="p">,</span> <span class="s">"topic_a"</span><span class="p">,</span> <span class="s">""</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="s">"ip1"</span> <span class="o">=&gt;</span> <span class="n">Producer</span><span class="p">{</span><span class="s">"addr_1"</span><span class="p">},</span>
		<span class="s">"ip2"</span> <span class="o">=&gt;</span> <span class="n">Producer</span><span class="p">{</span><span class="s">"addr2"</span><span class="p">},</span>
	<span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="nsqd---nsqlookupd-交互">nsqd &lt;-&gt; nsqlookupd 交互</h2>

<ol>
  <li>connect: send “  V1”</li>
  <li>ping: send “PING “
    <ol>
      <li>nsqlookupd update peer info’s lastUpdate</li>
      <li>response “OK”</li>
    </ol>
  </li>
  <li>identify: send “IDENTIFY LEN(data) data”
    <ol>
      <li>remote addr as id</li>
      <li>load broadcase address, tcp port, http port, version</li>
      <li>update peer info’s lastUpdate</li>
      <li>add producer to db: Registration{“client”} =&gt; PeerInfo{id}</li>
      <li>response {tcp_port, http_port, version, hostname, broadcast_address}</li>
    </ol>
  </li>
  <li>register: send “REGISTER TOPIC [CHANNEL]”
    <ol>
      <li>read topic and channel name</li>
      <li>if channel name exists:
        <ol>
          <li>add producer to db: Registration{“channel”, $TOPIC, $CHANNEL} =&gt; PeerInfo{id}</li>
        </ol>
      </li>
      <li>add producer to db: Registration{“topic”, $TOPIC, “”} =&gt; PeerInfo{id}</li>
      <li>response “OK”</li>
    </ol>
  </li>
  <li>unregister: send “UNREGISTER TOPIC [CHANNEL]”
    <ol>
      <li>read topic and channel name</li>
      <li>if channel name exists:
        <ol>
          <li>remove producer from db: Registration{“channel”, $TOPIC, $CHANNEL}</li>
          <li>remove registration for channel has suffix “#ephemeral” if left producer is zero</li>
        </ol>
      </li>
      <li>else:
        <ol>
          <li>find all registrations of channel of $TOPIC</li>
          <li>remove all channels of current peer</li>
          <li>remove producer form db: Registration{“topic”, $TOPIC, “”}</li>
        </ol>
      </li>
      <li>response “OK”</li>
    </ol>
  </li>
</ol>

<h2 id="nsqlookupd-support-http-request">nsqlookupd support http request</h2>

<ol>
  <li>GET /lookup?topic=topic_name
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"channels"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"channel1"</span><span class="p">],</span><span class="w">
 </span><span class="nl">"producers"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">

 </span><span class="p">}],</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>GET /topics</li>
  <li>GET /channels?topic=topic_name</li>
  <li>GET /nodes</li>
  <li>POST /topic/create?topic=</li>
  <li>POST /topic/delete?topic=</li>
  <li>POST /channel/create?topic=topic&amp;channel=channel</li>
  <li>POST /channel/delete?topic=&amp;channel=</li>
  <li>POST /topic/tombstone?topic=topic_name&amp;node=node_id</li>
</ol>]]></content><author><name></name></author><category term="消息中间件" /><category term="Nsq," /><category term="MessageQueue" /><summary type="html"><![CDATA[nsqd topicMap map[string]*Topic clientMap map[id]*Client 初始化过程 new load meta data persist meta data main listen tcp &amp; http port, start server start queueScanLoop, lookupLoop, statsLoop 有新连接到达时，会生成 connection 的 client，保存到 nsqd 的 clientMap 中，同时启动 goroutine 负责 client 的 messagePump。conn 所在的 goroutine 之后会负责读客户端的命令，并执行以及返回结果。可执行命令如下： IDENTIFY: 表名身份 FIN: 在 client 绑定的 channel 上，完成一条消息（调用 channel.FinishMessage），同时会更新当前 client 的 metrics 信息，以及状态 RDY: 更新 client ready count REQ: 在 client 绑定的 channel 上，把一条消息重新送入队列（调用 channel.RequeueMessage），同时更新 metrics 和状态。这条消息会被放入 defered 队列，延后执行 PUB: 往某个 client 有权限的 topic 发送一条消息（调用 topic.PutMessage），更新 metrics 状态 MPUB: 和 PUB 一样，不过接收多条消息 DPUB: 和 PUB 一样，不过会被放入 defered 队列 NOP: 最简单，啥也不干 TOUCH: 在 client 绑定的 channel 上，重置一条消息的过期时间（调用 channel.TouchMessage) SUB: 将 client 绑定到 channel 上，如果 topic 和 channel 任一个属于 “”, 且 topic 或 channel 正在关闭， client 会不断重试绑定操作。 CLS: 关闭连接 AUTH: 授权 client 有多种状态：init, disconnect, connect, subscribe, closing ，状态迁移由一系列命令执行顺序决定。除此外还有 ready 状态，client 通过 RDY 更新了自己的 ready count，表示 client 最多同时处理多少条消息，如果 inflight count &gt;= ready count，则未 ready，需要等待。 client 使用 SUB 进入 subscribe 模式，该模式只能进入一次，进入后 messagePumb 会接收到 subEvent，然后从对应 channel 中读取 message 发送到 client 里。 topic messageChan chan *Message backendChan BackendChan channelsMap map[string]Channels topic 创建流程 new topic, save to topicMap lookup each lookupd, get all channels in topic $TOPIC skip “#ephemeral” and create channels start topic messagePump delete channel remove from topic channelsMap mark channel deleted if left channels is zero, and topic is ephemeral, delete topic self put messages try put message into memory message channel fallthrough into backend queue, most case into disk, but ephemeral just ignore update message count message pump read message from memory message channel else read from backend message else update channel status copy memory into each channels in current topic if message is defered, put into channels defered else put into normal channels channel clients map[string]Consumer backend BackendQueue memoryChan chan *Message deferedMessages map[MessageID]*Message defredPQ PriorityQueue inFlightMessages map[MessageID]*Message inFlightPQ PriorityQueue channel put message 和 topic put message 类似。put defered message 会把 message 放在deferedMessages 中，并加入 deferedPQ 中。如果 defered 时间到了，使用正常流程 put。clients 提供了 Add 和 Remove 接口，但管理职责不是 channel 的。 nsqlookupd nsqlookupd 数据组织方式 { {"client", "", ""} =&gt; { "127.0.0.1:9490" =&gt; Producer{"127.0.0.1:8081"}, "127.0.0.1:9491" =&gt; Producer{"127.0.0.1:8081"}, }, {"channel", "topic_a", "channel_a"} =&gt; { "ip1" =&gt; Producer{"addr"}, }, {"topic", "topic_a", ""} =&gt; { "ip1" =&gt; Producer{"addr_1"}, "ip2" =&gt; Producer{"addr2"}, }, } nsqd &lt;-&gt; nsqlookupd 交互 connect: send “ V1” ping: send “PING “ nsqlookupd update peer info’s lastUpdate response “OK” identify: send “IDENTIFY LEN(data) data” remote addr as id load broadcase address, tcp port, http port, version update peer info’s lastUpdate add producer to db: Registration{“client”} =&gt; PeerInfo{id} response {tcp_port, http_port, version, hostname, broadcast_address} register: send “REGISTER TOPIC [CHANNEL]” read topic and channel name if channel name exists: add producer to db: Registration{“channel”, $TOPIC, $CHANNEL} =&gt; PeerInfo{id} add producer to db: Registration{“topic”, $TOPIC, “”} =&gt; PeerInfo{id} response “OK” unregister: send “UNREGISTER TOPIC [CHANNEL]” read topic and channel name if channel name exists: remove producer from db: Registration{“channel”, $TOPIC, $CHANNEL} remove registration for channel has suffix “#ephemeral” if left producer is zero else: find all registrations of channel of $TOPIC remove all channels of current peer remove producer form db: Registration{“topic”, $TOPIC, “”} response “OK” nsqlookupd support http request GET /lookup?topic=topic_name { "channels": ["channel1"], "producers": [{ }], } GET /topics GET /channels?topic=topic_name GET /nodes POST /topic/create?topic= POST /topic/delete?topic= POST /channel/create?topic=topic&amp;channel=channel POST /channel/delete?topic=&amp;channel= POST /topic/tombstone?topic=topic_name&amp;node=node_id]]></summary></entry><entry><title type="html">Write Ahead Log 杂谈</title><link href="/%E5%AD%98%E5%82%A8/2018/08/04/write-ahead-log.html" rel="alternate" type="text/html" title="Write Ahead Log 杂谈" /><published>2018-08-04T16:21:38+08:00</published><updated>2018-08-04T16:21:38+08:00</updated><id>/%E5%AD%98%E5%82%A8/2018/08/04/write-ahead-log</id><content type="html" xml:base="/%E5%AD%98%E5%82%A8/2018/08/04/write-ahead-log.html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Write-ahead_logging">预写式日志</a>（Write Ahead Log, WAL）主要用于实现存储系统中的原子性和持久性。预写式日志要求存储系统的修改操作在提交前都要先写入日志（Log）中。在硬盘数据不损坏的情况下，预写式日志允许存储系统在崩溃后能够在日志的指导下恢复到崩溃前的状态，避免数据丢失。</p>

<p>预写式日志并不是实现原子性和持久性的唯一办法，影页替换（Shadow Paging）是另一种实现方式，区别是预写式日志允许数据库进行原地更新（in-place），影页替换则不行。</p>

<p>预写式日志是一种套路，并不仅限于传统数据库中，在需要原子性和持久性的系统中经常见到它的身影。关系数据库的实现里，预写式日志常会被实现为重做（Redo Log）和撤销（Undo Log）两部分。LevelDB 中的日志模块就是预写式日志的简单应用，而最佳实践参考 ARIES algorithm。</p>

<p>Linux 文件系统里也有预写式日志的身影，不过叫做 Journaling。Journaling 提供了文件系统原子写入的可能，减轻存储系统实现难度。Journaling 在存储设备上开辟一段空间，用于记录文件操作，写操作先写入日志，然后复制数据到具体文件空间中，更新文件元信息，确保写入操作完成后再删除日志。Journaling 会在系统挂载文件系统时检查是否有未完成的日志，对其进行重做；系统卸载文件系统时，会将积压的日志写入。如果日志本身就不完整，直接丢弃更改。Journaling 每次操作需要将数据写两次，一种优化方式是先将数据写入对应位置，日志里只记录操作元信息，数据写入成功后再写日志。</p>

<p>预写式日志还应用在使用复制状态机（Replicated State Machine, RSM）进行协作的分布式系统中，如 Raft 算法为了保证安全性要求节点在将日志完整写入硬盘后才能回复该消息。</p>

<p>预写式日志在存储系统中扮演着举足轻重的地位，从文件系统，到分布式系统。不过在新的硬件环境下，出现了另一种与预写式日志相对的叫 Write-Behind Logging 的日志系统。WBL 在事务提交的时候，直接把藏页写入 NVRAM 中，等脏页刷盘后，再去更新日志。关于 WBL 的具体实现方式，参考论文：<a href="http://www.vldb.org/pvldb/vol10/p337-arulraj.pdf">Write-Behind Logging
</a></p>]]></content><author><name></name></author><category term="存储" /><category term="Storage" /><summary type="html"><![CDATA[预写式日志（Write Ahead Log, WAL）主要用于实现存储系统中的原子性和持久性。预写式日志要求存储系统的修改操作在提交前都要先写入日志（Log）中。在硬盘数据不损坏的情况下，预写式日志允许存储系统在崩溃后能够在日志的指导下恢复到崩溃前的状态，避免数据丢失。 预写式日志并不是实现原子性和持久性的唯一办法，影页替换（Shadow Paging）是另一种实现方式，区别是预写式日志允许数据库进行原地更新（in-place），影页替换则不行。 预写式日志是一种套路，并不仅限于传统数据库中，在需要原子性和持久性的系统中经常见到它的身影。关系数据库的实现里，预写式日志常会被实现为重做（Redo Log）和撤销（Undo Log）两部分。LevelDB 中的日志模块就是预写式日志的简单应用，而最佳实践参考 ARIES algorithm。 Linux 文件系统里也有预写式日志的身影，不过叫做 Journaling。Journaling 提供了文件系统原子写入的可能，减轻存储系统实现难度。Journaling 在存储设备上开辟一段空间，用于记录文件操作，写操作先写入日志，然后复制数据到具体文件空间中，更新文件元信息，确保写入操作完成后再删除日志。Journaling 会在系统挂载文件系统时检查是否有未完成的日志，对其进行重做；系统卸载文件系统时，会将积压的日志写入。如果日志本身就不完整，直接丢弃更改。Journaling 每次操作需要将数据写两次，一种优化方式是先将数据写入对应位置，日志里只记录操作元信息，数据写入成功后再写日志。 预写式日志还应用在使用复制状态机（Replicated State Machine, RSM）进行协作的分布式系统中，如 Raft 算法为了保证安全性要求节点在将日志完整写入硬盘后才能回复该消息。 预写式日志在存储系统中扮演着举足轻重的地位，从文件系统，到分布式系统。不过在新的硬件环境下，出现了另一种与预写式日志相对的叫 Write-Behind Logging 的日志系统。WBL 在事务提交的时候，直接把藏页写入 NVRAM 中，等脏页刷盘后，再去更新日志。关于 WBL 的具体实现方式，参考论文：Write-Behind Logging]]></summary></entry><entry><title type="html">Raft-实现指北-领导选举</title><link href="/destribution/2018/01/07/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE.html" rel="alternate" type="text/html" title="Raft-实现指北-领导选举" /><published>2018-01-07T21:31:18+08:00</published><updated>2018-01-07T21:31:18+08:00</updated><id>/destribution/2018/01/07/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE</id><content type="html" xml:base="/destribution/2018/01/07/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE.html"><![CDATA[<p>和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。在选举上，Raft 算法使用一个随机计时器来选举领导者，这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。[1]</p>

<p><img src="https://camo.githubusercontent.com/f9b80d45d67996bb9ce63ba6e5d37b6a03150097/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245352e706e67" alt="时间被划分成一个个的任期，每个任期开始都是一次选举" /></p>

<p>Raft 把时间分割任意长度的任期（term），并使用连续整数标记，每个任期都从一次选举开始。每次选举有一个或多个候选人参选，如果一个候选人赢得选举，其就会在该任期充当领导人的职责。某些情况下会出现选票瓜分的现象，那么该任期无法选出领导人，所以进入下一期选举，其中 Raft 通过随机计时来保证选举成功。[1]</p>

<h1 id="设计">设计</h1>

<p>实现领导人选举之前，先看到上一节提到的纯函数式的状态机，将 Raft 实现成为一个无副作用的纯函数状态机。Raft 算法可以看作一个角色状态机，通过其他节点传递的消息、计时器、客户端的提交请求和快照等输入消息，从一个状态转移到另一个状态、或修改部分内部状态并返回一个发送给外部的信息。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(state, message) -&gt; state machine -&gt; message
</code></pre></div></div>

<p>state machine 是一个纯函数式的状态机，负责处理消息，并将改动写入到 state 里，然后返回给外部的消息。</p>

<p>根据 Raft 论文，一个 state 几部分组成：</p>

<table>
  <thead>
    <tr>
      <th>状态</th>
      <th>所有服务器上持久存在的</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>currentTerm</td>
      <td>服务器最后一次知道的任期号（初始化为 0，持续递增）</td>
    </tr>
    <tr>
      <td>votedFor</td>
      <td>在当前获得选票的候选人的 Id</td>
    </tr>
    <tr>
      <td>log[]</td>
      <td>日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>状态</th>
      <th>所有服务器上经常变的</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>commitIndex</td>
      <td>已知的最大的已经被提交的日志条目的索引值</td>
    </tr>
    <tr>
      <td>lastApplied</td>
      <td>最后被应用到状态机的日志条目索引值（初始化为 0，持续递增）</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>状态</th>
      <th>在领导人里经常改变的 （选举后重新初始化）</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>nextIndex[]</td>
      <td>对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一）</td>
    </tr>
    <tr>
      <td>matchIndex[]</td>
      <td>对于每一个服务器，已经复制给他的日志的最高索引值</td>
    </tr>
  </tbody>
</table>

<p>实现大体是类似的，不过以后需要加入流量控制、成员加入退出等，所以将 state 中保存的其他服务器的信息抽象一下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">node</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">id</span> <span class="kt">uint64</span> 
    <span class="n">nextIdx</span> <span class="kt">uint64</span> 
    <span class="n">matched</span> <span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">id</code> 表示其他服务器在 Raft 中的唯一 ID，<code class="language-plaintext highlighter-rouge">nextIdx</code> 与 <code class="language-plaintext highlighter-rouge">matched</code> 分别是 <code class="language-plaintext highlighter-rouge">nextIndex</code> 数组和 <code class="language-plaintext highlighter-rouge">matchIndex</code> 数据中第 <code class="language-plaintext highlighter-rouge">id</code> 个元素。</p>

<p>Raft 通过超时来驱动心跳和选举，一共由两种超时：1、心跳超时，领导人定期给跟随者发送心跳信息宣布自己的领导权；2、选举超时，超时时间是随机选择的。</p>

<p>整个 state 如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">core</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">id</span> <span class="kt">uint64</span> 
    <span class="n">leaderId</span> <span class="kt">uint64</span>
    <span class="n">state</span> <span class="n">StateRole</span>

    <span class="n">term</span> <span class="kt">uint64</span> 
    <span class="n">vote</span> <span class="kt">uint64</span> 
    <span class="n">log</span> <span class="o">*</span><span class="n">LogHolder</span> 

    <span class="n">nodes</span> <span class="p">[]</span><span class="n">node</span> 

    <span class="n">timeElapsed</span> <span class="kt">int</span> 
    <span class="n">randomizedElectionTimtout</span> <span class="kt">int</span> 
    <span class="n">electionTimeout</span> <span class="kt">int</span> 
    <span class="n">heartbeatTimeout</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">id</code> 是 Raft weiyiqueding d  <code class="language-plaintext highlighter-rouge">term</code> 和 <code class="language-plaintext highlighter-rouge">vote</code> 分别是 <code class="language-plaintext highlighter-rouge">currentTerm</code> 和 <code class="language-plaintext highlighter-rouge">voteFor</code> 的实现，而日志由应用负责持久化。<code class="language-plaintext highlighter-rouge">lastApplied</code> 和 <code class="language-plaintext highlighter-rouge">commitIndex</code> 由 <code class="language-plaintext highlighter-rouge">log</code> 负责管理。<code class="language-plaintext highlighter-rouge">nodes</code> 表示该 Raft 集群的其他服务器的状态。<code class="language-plaintext highlighter-rouge">timeElapsed</code> 表示从时间累积，<code class="language-plaintext highlighter-rouge">randomizedElectionTimeout</code> 表示随机生成的选举超时阈值，每次转为跟随者、候选人状态时都会改变。<code class="language-plaintext highlighter-rouge">heartbeatTimeout</code> 表示领导人两次心跳的间隔。<code class="language-plaintext highlighter-rouge">electionTimeout</code> 用来表示领导人选举超时基准，其用于计算<code class="language-plaintext highlighter-rouge">randomizedElectionTimeout</code>，使用公式：$electionTimeout + rand() \% electionTimeout$ 计算得到。另外还有 <code class="language-plaintext highlighter-rouge">leaderId</code> 和 <code class="language-plaintext highlighter-rouge">state</code> 状态，<code class="language-plaintext highlighter-rouge">leaderId</code> 表示当前领导人的 ID，<code class="language-plaintext highlighter-rouge">state</code> 则是 Raft 目前所处的角色。</p>

<p>此外，还需要设计消息结构作为外部应用、服务器和 Raft 状态机进行数据交换。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Message</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">From</span> <span class="kt">uint64</span> 
    <span class="n">To</span> <span class="kt">uint64</span> 
    <span class="n">MsgType</span> <span class="n">MessageType</span>
    <span class="n">Term</span> <span class="kt">uint64</span> 
    <span class="n">Index</span> <span class="kt">uint64</span>
    <span class="n">LogIndex</span> <span class="kt">uint64</span> 
    <span class="n">LogTerm</span> <span class="kt">uint64</span> 
    <span class="n">Reject</span> <span class="kt">uint64</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>该结构不仅仅用于发起请求，也用于状态机返回数据，所以需要 <code class="language-plaintext highlighter-rouge">Reject</code> 字段表示拒绝请求，比如拒绝给某个候选人投票。</p>

<p>最后，状态机需要返回消息给消息发送者，由于希望将 Raft 设计为一个纯函数式状态机，消息的接受发送交给了应用处理，所以还得提供一个 <code class="language-plaintext highlighter-rouge">Application</code> 接口，供 Raft 和应用交互。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Application</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">send</span><span class="p">(</span><span class="n">msg</span> <span class="o">*</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当应用接收到消息后，将其输入到 Raft 状态机，处理完后，调用 <code class="language-plaintext highlighter-rouge">send</code> 发送回复消息，并保存信息到机中。整个状态机由消息驱动，所以 Raft 接口如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Raft</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Step</span><span class="p">(</span><span class="n">msg</span> <span class="o">*</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span>
    <span class="n">Periodic</span><span class="p">(</span><span class="n">millsSinceLastPeriod</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当应用接受到外部传递的消息后，调用 <code class="language-plaintext highlighter-rouge">Step</code> 驱动状态机改变状态。Raft 中通过超时进行心跳或选举，外部应用需要通过某个固定的定时源隔一段时间调用 <code class="language-plaintext highlighter-rouge">Periodic</code> 驱动状态机进行心跳、选举等。</p>

<h1 id="选举过程">选举过程</h1>

<p><img src="https://camo.githubusercontent.com/6396d99ee401327500ef9eafe92617d7812ecd4d/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245342d30312e706e67" alt="服务器状态变化图" /></p>

<p>系统进行初始化时，每个节点都处于跟随者状态，由于没有领导人定期广播心跳，所以一段时间后部分跟随者成为候选人并进行下一届选举。</p>

<p>当某个候选人获得了超过半数的投票后，成为领导人，并向所有节点广播自己成功的信息。当候选人接收到其他候选人成为领导人的信息后，一届只能选出一个领导人（<strong>选举安全特性</strong>），该候选人退回到跟随者的状态，并投票给该领导人。</p>

<p>如果到了下一个选举超时，仍然没有候选人成为领导人，就会跳过这一届，开始下一届的领导人选举。</p>

<h1 id="prevote">PreVote</h1>

<p>由于<strong>选举安全特性</strong>的限制，成员会忽略已经过期的信息时，并返回自己所在的任期，用于发送者更新自己。由于这一特性的存在，在一个存在网络延迟的网络中，某个节点由于延迟进入了选举，而实际上大多数节点都能接收到领导人的心跳，也会进入选举。Raft 原论文 9.6 节中提出了 Prevote 算法：在选举前可以选询问其他节点是否愿意参与选举，如果节点能够感知到领导人的心跳，那么它就不会参与选举，否则参与选举。只有过半的节点参与选举，才能开始下一届领导人选举。</p>

<h1 id="领导人选举实现">领导人选举实现</h1>

<p>加入了 PreVote 算法后，Raft 的状态变为 4 个：领导人、跟随者，候选人，预候选人。此时的外部事件为：选举、心跳超时；以及：</p>

<ul>
  <li>MsgPreVoteRequest</li>
  <li>MsgPreVoteResponse</li>
  <li>MsgVoteRequest</li>
  <li>MsgVoteResponse</li>
  <li>MsgAppendRequest</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">MsgAppendRequest</code> 这种消息类型发生在某个节点成竞选成功后向其他节点宣示领导权，在选举过程中也由该种类型在节点间传递。比如 PreVote 阶段正常的跟随者能够接收到领导人的心跳；又或者新晋领导人首次对外宣誓领导权。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">Periodic</span><span class="p">(</span><span class="n">millsSinceLastPeriod</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span> <span class="o">+=</span> <span class="n">millsSinceLastPeriod</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Debugf</span><span class="p">(</span><span class="s">"%d periodic %d, time elapsed %d"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">millsSinceLastPeriod</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">IsLeader</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">heartbeatTick</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">.</span><span class="n">broadcastAppend</span><span class="p">()</span>
            <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span> <span class="o">=</span> <span class="m">0</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">randomizedElectionTick</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">1</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">.</span><span class="n">campaign</span><span class="p">(</span><span class="n">campaignPreCandidate</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>每次应用程序调用 <code class="language-plaintext highlighter-rouge">Periodic</code> 时，Raft 判断是否为 leader，是判断 <code class="language-plaintext highlighter-rouge">timeElapsed</code> 是否超过 <code class="language-plaintext highlighter-rouge">heartbeatTick</code>，然后向其他节点发送追加日志（心跳）信息，并清空 <code class="language-plaintext highlighter-rouge">timElapsed</code>；如果不是领导人，且已经超过随机生成的选举超时，那么状态转移到预候选人同时开始 PreVote 阶段。</p>

<p>除此之外，PreVote 算法还需要记录其他节点对某次预选举请求的响应状态，所以在 node 结构中添加字段标记：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">voteState</span> <span class="kt">int</span>

<span class="k">const</span> <span class="p">(</span>
    <span class="n">voteNone</span>    <span class="n">voteState</span> <span class="o">=</span> <span class="no">iota</span>
    <span class="n">voteReject</span>
    <span class="n">voteGranted</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">node</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="n">vote</span>    <span class="n">voteState</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="状态间转换">状态间转换</h2>

<p>继续之前需要看看 Raft 状态机的状态转换是如何实现的：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">resetRandomizedElectionTimeout</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">randomizedElectionTick</span> <span class="o">=</span>
        <span class="n">c</span><span class="o">.</span><span class="n">electionTick</span> <span class="o">+</span> <span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">electionTick</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">reset</span><span class="p">(</span><span class="n">term</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="o">!=</span> <span class="n">term</span> <span class="p">{</span>
        <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="o">=</span> <span class="n">term</span>
        <span class="n">c</span><span class="o">.</span><span class="n">vote</span> <span class="o">=</span> <span class="n">InvalidId</span>
    <span class="p">}</span>
    <span class="n">c</span><span class="o">.</span><span class="n">leaderId</span> <span class="o">=</span> <span class="n">InvalidId</span>
    <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span> <span class="o">=</span> <span class="m">0</span>
    <span class="n">c</span><span class="o">.</span><span class="n">resetRandomizedElectionTimeout</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">becomeFollower</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">leaderId</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">leaderId</span> <span class="o">=</span> <span class="n">leaderId</span>
    <span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">FOLLOWER</span>
    <span class="n">c</span><span class="o">.</span><span class="n">vote</span> <span class="o">=</span> <span class="n">leaderId</span>

    <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%v become follower at %d"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">becomeLeader</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">CANDIDATE</span><span class="p">,</span> <span class="s">"invalid translation [%v =&gt; Leader]"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>

    <span class="n">c</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">leaderId</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span>
    <span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">LEADER</span>
    <span class="n">c</span><span class="o">.</span><span class="n">vote</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span>

    <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%v become leader at %d"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">becomeCandidate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LEADER</span><span class="p">,</span> <span class="s">"invalid translation [Leader =&gt; Candidate]"</span><span class="p">)</span>

    <span class="n">c</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">vote</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span>
    <span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">CANDIDATE</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">node</span><span class="o">.</span><span class="n">resetVoteState</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%v become candidate at %d"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">becomePreCandidate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">PRE_CANDIDATE</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">node</span><span class="o">.</span><span class="n">resetVoteState</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c">// Becoming a pre-candidate changes our state,</span>
    <span class="c">// but doesn't change anything else. In particular it does not increase</span>
    <span class="c">// currentTerm or change votedFor.</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%x became pre-candidate at term %d"</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>首先看到 <code class="language-plaintext highlighter-rouge">reset</code>，它是负责在 Raft 状态转换过程中重置部分状态。<code class="language-plaintext highlighter-rouge">reset</code> 中第一步是根据任期是否改变决定重置 <code class="language-plaintext highlighter-rouge">vote</code> 和 <code class="language-plaintext highlighter-rouge">term</code> 信息；除此之外还重置了 <code class="language-plaintext highlighter-rouge">leaderId</code> 以及超时相关的两个属性: <code class="language-plaintext highlighter-rouge">timeElapsed</code> 和 <code class="language-plaintext highlighter-rouge">randomizedElectionTimeout</code>。</p>

<p>进入预选举的节点在被大多数节点拒绝后会回退到跟随者的状态，因此在 <code class="language-plaintext highlighter-rouge">becomePreCandidate</code> 中除了重置基础状态外，仅仅修改了 <code class="language-plaintext highlighter-rouge">state</code> 属性和重置其他节点的投票情况。<strong>特别需要注意的是不能修改 <code class="language-plaintext highlighter-rouge">currentTerm</code> 和 <code class="language-plaintext highlighter-rouge">votedFor</code></strong>。</p>

<p>如果预选举的节点获得了半数的节点参选支持，就会进入候选人状态，因此任期加一，同时给自己投票。</p>

<p>此外，当领导者和跟随者在发送心跳或接收到领导人的通知后，都需要重置 <code class="language-plaintext highlighter-rouge">timeElappsed</code>，因此将 <code class="language-plaintext highlighter-rouge">becomeLeader</code> 和 <code class="language-plaintext highlighter-rouge">becomeFollower</code> 设计为重入只会影响到 <code class="language-plaintext highlighter-rouge">timeElapsed</code> 和 <code class="language-plaintext highlighter-rouge">randomizedElectinTimeout</code> 属性。</p>

<h2 id="precampaign">PreCampaign</h2>

<p>竞选时首先调用 <code class="language-plaintext highlighter-rouge">campaign</code> 给其他节点发送 <code class="language-plaintext highlighter-rouge">MsgPreVoteRequest</code> 请求。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">campaign</span><span class="p">(</span><span class="n">ct</span> <span class="n">campaignState</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">LEADER</span><span class="p">,</span>
        <span class="s">"invalid translation [Leader =&gt; PreCandidate/Candidate]"</span><span class="p">)</span>

    <span class="n">msg</span> <span class="o">:=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">{}</span>
    <span class="n">msg</span><span class="o">.</span><span class="n">LogIndex</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">lastIndex</span><span class="p">()</span>
    <span class="n">msg</span><span class="o">.</span><span class="n">LogTerm</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">lastTerm</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ct</span> <span class="o">==</span> <span class="n">campaignPreCandidate</span> <span class="p">{</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="o">+</span> <span class="m">1</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgPreVoteRequest</span>
        <span class="n">c</span><span class="o">.</span><span class="n">becomePreCandidate</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgVoteRequest</span>
        <span class="n">c</span><span class="o">.</span><span class="n">becomeCandidate</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">msg</span><span class="o">.</span><span class="n">To</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span>

        <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%x [term: %d, index: %d] send %v request to %x at term %d"</span><span class="p">,</span>
            <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">lastTerm</span><span class="p">(),</span> <span class="n">c</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">lastIndex</span><span class="p">(),</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">To</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>PreVote 要求某个节点只有在长时间未和领导人交换心跳时才参与选举。同时参与选举要求候选人的日志必须是最新的（<strong>领导人完全特性</strong>）。所以在接收到其他节点发送的 <code class="language-plaintext highlighter-rouge">MsgPreVoteRequest</code> 时，1、如果在一个选举超时内（注意：<code class="language-plaintext highlighter-rouge">electionTimeout</code>）有和领导交换过一次心跳；2、或者候选人的任期号小于自身的任期号；3、或者候选人的日志不是最新的都拒绝参加选举。否则回复参加选举。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">handlePreVote</span><span class="p">(</span><span class="n">msg</span> <span class="o">*</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">reply</span> <span class="o">:=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">{}</span>
    <span class="n">reply</span><span class="o">.</span><span class="n">To</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">From</span>
    <span class="n">reply</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgPreVoteResponse</span>

    <span class="c">// Reply false if last AppendEntries call was received less than election timeout ago.</span>
    <span class="c">// Reply false if term &lt; currentTerm.</span>
    <span class="c">// Reply false if candidate's log isn't at least as up­to­date as receiver's log.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">leaderId</span> <span class="o">!=</span> <span class="n">InvalidId</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">.</span><span class="n">timeElapsed</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="n">electionTick</span><span class="p">)</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span> <span class="o">||</span>
        <span class="o">!</span><span class="n">c</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">IsUpToDate</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">LogIndex</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">LogTerm</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">reply</span><span class="o">.</span><span class="n">Reject</span> <span class="o">=</span> <span class="no">false</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">reply</span><span class="o">.</span><span class="n">Reject</span> <span class="o">=</span> <span class="no">true</span>
    <span class="p">}</span>

    <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>注意：实际上在处理远程信息时，如果接收到了过期信息，会直接丢弃（后面有讲），不会进入 <code class="language-plaintext highlighter-rouge">handlePreVote</code> 函数，所以上面第二点实际上永远为假。</p>

<p>预候选人接收到其他节点回复的信息时:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">handleVoteResponse</span><span class="p">(</span><span class="n">msg</span> <span class="o">*</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">Reject</span> <span class="p">{</span>
        <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%x received %v rejection from %x at term %d"</span><span class="p">,</span>
            <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">From</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%x received %v from %x at term %s"</span><span class="p">,</span>
            <span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">From</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">Term</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">node</span> <span class="o">:=</span> <span class="n">c</span><span class="o">.</span><span class="n">getNodeById</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">From</span><span class="p">)</span>
    <span class="n">node</span><span class="o">.</span><span class="n">updateVoteState</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">Reject</span><span class="p">)</span>

    <span class="n">count</span> <span class="o">:=</span> <span class="n">c</span><span class="o">.</span><span class="n">voteStateCount</span><span class="p">(</span><span class="n">voteGranted</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">quorum</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">==</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgVoteResponse</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">.</span><span class="n">becomeLeader</span><span class="p">()</span>
            <span class="n">c</span><span class="o">.</span><span class="n">broadcastVictory</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">.</span><span class="n">campaign</span><span class="p">(</span><span class="n">campaignCandidate</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="c">// return to follower state if it receives vote denial from a majority</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">voteStateCount</span><span class="p">(</span><span class="n">voteReject</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">quorum</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">c</span><span class="o">.</span><span class="n">becomeFollower</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">Term</span><span class="p">,</span> <span class="n">InvalidId</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>更新某个 node 对此次请求的投票情况，并判断支持者和反对者人数，如果支持者人数过半，那么调用 <code class="language-plaintext highlighter-rouge">campaign(campaignCandidate)</code> 进入候选人状态。如果反对者人数过半，那么节点会回退到跟随者的状态。</p>

<h2 id="campaign">Campaign</h2>

<p>在候选人一方，选举过程使用了相同的函数，不同的是跟随者对候选人的处理。只有当候选人未投票或者上一次投给了该候选人，候选人才能获得跟随者的选票。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">handleVote</span><span class="p">(</span><span class="n">msg</span> <span class="o">*</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">reply</span> <span class="o">:=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">{}</span>
    <span class="n">reply</span><span class="o">.</span><span class="n">To</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">From</span>
    <span class="n">reply</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">=</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgVoteResponse</span>

    <span class="c">// no vote or vote for candidate, and log is at least as up-to-date as receiver's.</span>
    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">vote</span> <span class="o">==</span> <span class="n">InvalidId</span> <span class="o">||</span> <span class="n">c</span><span class="o">.</span><span class="n">vote</span> <span class="o">==</span> <span class="n">msg</span><span class="o">.</span><span class="n">From</span> <span class="o">||</span>
        <span class="n">c</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">IsUpToDate</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">LogIndex</span><span class="p">,</span> <span class="n">msg</span><span class="o">.</span><span class="n">LogTerm</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">reply</span><span class="o">.</span><span class="n">Reject</span> <span class="o">=</span> <span class="no">false</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">reply</span><span class="o">.</span><span class="n">Reject</span> <span class="o">=</span> <span class="no">true</span>
    <span class="p">}</span>

    <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reply</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="处理过时消息">处理过时消息</h2>

<p>根据 Raft 论文中将 term 用作逻辑时间，判断过期的消息。在论文图 2 中提到如果接收到来自高任期的消息，应该回退到跟随者状态；接收到过时消息，直接忽略。所以代码可以写为：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">reject</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="p">}</span> <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">.</span><span class="n">becomeFollower</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>实际上可能某个节点成为候选人后，又重新连接到网络中。此时发起投票会导致其他节点增大任期，因此对投票相关的消息做特殊处理。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">core</span><span class="p">)</span> <span class="n">Step</span><span class="p">(</span><span class="n">msg</span> <span class="o">*</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="p">{</span>
        <span class="n">c</span><span class="o">.</span><span class="n">reject</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">Term</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">term</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">==</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgPreVoteRequest</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span> <span class="o">==</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgPreVoteResponse</span> <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="n">Reject</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">.</span><span class="n">becomeFollower</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">Term</span><span class="p">,</span> <span class="n">leaderId</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">switch</span> <span class="n">msg</span><span class="o">.</span><span class="n">MsgType</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgPreVoteRequest</span><span class="o">:</span>
        <span class="n">c</span><span class="o">.</span><span class="n">handlePreVote</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">raftpd</span><span class="o">.</span><span class="n">MsgVoteRequest</span><span class="o">:</span>
        <span class="n">c</span><span class="o">.</span><span class="n">handleVote</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">c</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Raft 算法虽然更易于理解，但是实现并不简单。就以上述代码为例，Raft 如果没有 PreVote 机制，那么重新上线的候选人会通过 <code class="language-plaintext highlighter-rouge">c.reject(msg)</code> 强制让候选人参与选举。加入 PreVote 机制也不能完全避免这种情况。如果一个节点成为了候选人，此时领导人重新上线，那么候选人仍然会强制发起一次选举[3]。</p>

<h1 id="references">References</h1>

<ol>
  <li><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">寻找一种易于理解的一致性算法（扩展版）</a></li>
  <li><a href="http://blog.neverchanje.com/2017/01/30/etcd_raft_core/">Etcd-raft-core 阅读</a></li>
  <li><a href="http://blog.neverchanje.com/2017/01/31/morning_paper_four_modifications_mongo_raft/">Morning Paper, MongoDB 对 Raft 算法的 4 个改动</a></li>
</ol>]]></content><author><name></name></author><category term="Destribution" /><category term="Raft" /><category term="Consensus" /><category term="Practice" /><category term="Destribution" /><summary type="html"><![CDATA[和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。在选举上，Raft 算法使用一个随机计时器来选举领导者，这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。[1] Raft 把时间分割任意长度的任期（term），并使用连续整数标记，每个任期都从一次选举开始。每次选举有一个或多个候选人参选，如果一个候选人赢得选举，其就会在该任期充当领导人的职责。某些情况下会出现选票瓜分的现象，那么该任期无法选出领导人，所以进入下一期选举，其中 Raft 通过随机计时来保证选举成功。[1] 设计 实现领导人选举之前，先看到上一节提到的纯函数式的状态机，将 Raft 实现成为一个无副作用的纯函数状态机。Raft 算法可以看作一个角色状态机，通过其他节点传递的消息、计时器、客户端的提交请求和快照等输入消息，从一个状态转移到另一个状态、或修改部分内部状态并返回一个发送给外部的信息。 (state, message) -&gt; state machine -&gt; message state machine 是一个纯函数式的状态机，负责处理消息，并将改动写入到 state 里，然后返回给外部的消息。 根据 Raft 论文，一个 state 几部分组成： 状态 所有服务器上持久存在的 currentTerm 服务器最后一次知道的任期号（初始化为 0，持续递增） votedFor 在当前获得选票的候选人的 Id log[] 日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号 状态 所有服务器上经常变的 commitIndex 已知的最大的已经被提交的日志条目的索引值 lastApplied 最后被应用到状态机的日志条目索引值（初始化为 0，持续递增） 状态 在领导人里经常改变的 （选举后重新初始化） nextIndex[] 对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一） matchIndex[] 对于每一个服务器，已经复制给他的日志的最高索引值 实现大体是类似的，不过以后需要加入流量控制、成员加入退出等，所以将 state 中保存的其他服务器的信息抽象一下： type node struct { id uint64 nextIdx uint64 matched uint64 } id 表示其他服务器在 Raft 中的唯一 ID，nextIdx 与 matched 分别是 nextIndex 数组和 matchIndex 数据中第 id 个元素。 Raft 通过超时来驱动心跳和选举，一共由两种超时：1、心跳超时，领导人定期给跟随者发送心跳信息宣布自己的领导权；2、选举超时，超时时间是随机选择的。 整个 state 如下： type core struct { id uint64 leaderId uint64 state StateRole term uint64 vote uint64 log *LogHolder nodes []node timeElapsed int randomizedElectionTimtout int electionTimeout int heartbeatTimeout int } id 是 Raft weiyiqueding d term 和 vote 分别是 currentTerm 和 voteFor 的实现，而日志由应用负责持久化。lastApplied 和 commitIndex 由 log 负责管理。nodes 表示该 Raft 集群的其他服务器的状态。timeElapsed 表示从时间累积，randomizedElectionTimeout 表示随机生成的选举超时阈值，每次转为跟随者、候选人状态时都会改变。heartbeatTimeout 表示领导人两次心跳的间隔。electionTimeout 用来表示领导人选举超时基准，其用于计算randomizedElectionTimeout，使用公式：$electionTimeout + rand() \% electionTimeout$ 计算得到。另外还有 leaderId 和 state 状态，leaderId 表示当前领导人的 ID，state 则是 Raft 目前所处的角色。 此外，还需要设计消息结构作为外部应用、服务器和 Raft 状态机进行数据交换。 type Message struct { From uint64 To uint64 MsgType MessageType Term uint64 Index uint64 LogIndex uint64 LogTerm uint64 Reject uint64 } 该结构不仅仅用于发起请求，也用于状态机返回数据，所以需要 Reject 字段表示拒绝请求，比如拒绝给某个候选人投票。 最后，状态机需要返回消息给消息发送者，由于希望将 Raft 设计为一个纯函数式状态机，消息的接受发送交给了应用处理，所以还得提供一个 Application 接口，供 Raft 和应用交互。 type Application interface { send(msg *raftpd.Message) } 当应用接收到消息后，将其输入到 Raft 状态机，处理完后，调用 send 发送回复消息，并保存信息到机中。整个状态机由消息驱动，所以 Raft 接口如下： type Raft interface { Step(msg *raftpd.Message) Periodic(millsSinceLastPeriod int) } 当应用接受到外部传递的消息后，调用 Step 驱动状态机改变状态。Raft 中通过超时进行心跳或选举，外部应用需要通过某个固定的定时源隔一段时间调用 Periodic 驱动状态机进行心跳、选举等。 选举过程 系统进行初始化时，每个节点都处于跟随者状态，由于没有领导人定期广播心跳，所以一段时间后部分跟随者成为候选人并进行下一届选举。 当某个候选人获得了超过半数的投票后，成为领导人，并向所有节点广播自己成功的信息。当候选人接收到其他候选人成为领导人的信息后，一届只能选出一个领导人（选举安全特性），该候选人退回到跟随者的状态，并投票给该领导人。 如果到了下一个选举超时，仍然没有候选人成为领导人，就会跳过这一届，开始下一届的领导人选举。 PreVote 由于选举安全特性的限制，成员会忽略已经过期的信息时，并返回自己所在的任期，用于发送者更新自己。由于这一特性的存在，在一个存在网络延迟的网络中，某个节点由于延迟进入了选举，而实际上大多数节点都能接收到领导人的心跳，也会进入选举。Raft 原论文 9.6 节中提出了 Prevote 算法：在选举前可以选询问其他节点是否愿意参与选举，如果节点能够感知到领导人的心跳，那么它就不会参与选举，否则参与选举。只有过半的节点参与选举，才能开始下一届领导人选举。 领导人选举实现 加入了 PreVote 算法后，Raft 的状态变为 4 个：领导人、跟随者，候选人，预候选人。此时的外部事件为：选举、心跳超时；以及： MsgPreVoteRequest MsgPreVoteResponse MsgVoteRequest MsgVoteResponse MsgAppendRequest MsgAppendRequest 这种消息类型发生在某个节点成竞选成功后向其他节点宣示领导权，在选举过程中也由该种类型在节点间传递。比如 PreVote 阶段正常的跟随者能够接收到领导人的心跳；又或者新晋领导人首次对外宣誓领导权。 func (c *core) Periodic(millsSinceLastPeriod int) { c.timeElapsed += millsSinceLastPeriod log.Debugf("%d periodic %d, time elapsed %d", c.id, millsSinceLastPeriod, c.timeElapsed) if c.state.IsLeader() { if c.heartbeatTick &lt;= c.timeElapsed { c.broadcastAppend() c.timeElapsed = 0 } } else if c.randomizedElectionTick &lt;= c.timeElapsed { if len(c.nodes) &gt; 1 { c.campaign(campaignPreCandidate) } } } 每次应用程序调用 Periodic 时，Raft 判断是否为 leader，是判断 timeElapsed 是否超过 heartbeatTick，然后向其他节点发送追加日志（心跳）信息，并清空 timElapsed；如果不是领导人，且已经超过随机生成的选举超时，那么状态转移到预候选人同时开始 PreVote 阶段。 除此之外，PreVote 算法还需要记录其他节点对某次预选举请求的响应状态，所以在 node 结构中添加字段标记： type voteState int const ( voteNone voteState = iota voteReject voteGranted ) type node struct { ... vote voteState } 状态间转换 继续之前需要看看 Raft 状态机的状态转换是如何实现的： func (c *core) resetRandomizedElectionTimeout() { c.randomizedElectionTick = c.electionTick + rand.Intn(c.electionTick) } func (c *core) reset(term uint64) { if c.term != term { c.term = term c.vote = InvalidId } c.leaderId = InvalidId c.timeElapsed = 0 c.resetRandomizedElectionTimeout() } func (c *core) becomeFollower(term, leaderId uint64) { c.reset(term) c.leaderId = leaderId c.state = FOLLOWER c.vote = leaderId log.Infof("%v become follower at %d", c.id, c.term) } func (c *core) becomeLeader() { utils.Assert(c.state == CANDIDATE, "invalid translation [%v =&gt; Leader]", c.state) c.reset(c.term) c.leaderId = c.id c.state = LEADER c.vote = c.id log.Infof("%v become leader at %d", c.id, c.term) } func (c *core) becomeCandidate() { utils.Assert(c.state != LEADER, "invalid translation [Leader =&gt; Candidate]") c.reset(c.term + 1) c.vote = c.id c.state = CANDIDATE for i := 0; i &lt; len(c.nodes); i++ { node := &amp;c.nodes[i] node.resetVoteState() } log.Infof("%v become candidate at %d", c.id, c.term) } func (c *core) becomePreCandidate() { c.reset(c.term) c.state = PRE_CANDIDATE for i := 0; i &lt; len(c.nodes); i++ { node := &amp;c.nodes[i] node.resetVoteState() } // Becoming a pre-candidate changes our state, // but doesn't change anything else. In particular it does not increase // currentTerm or change votedFor. log.Infof("%x became pre-candidate at term %d", c.id, c.term) } 首先看到 reset，它是负责在 Raft 状态转换过程中重置部分状态。reset 中第一步是根据任期是否改变决定重置 vote 和 term 信息；除此之外还重置了 leaderId 以及超时相关的两个属性: timeElapsed 和 randomizedElectionTimeout。 进入预选举的节点在被大多数节点拒绝后会回退到跟随者的状态，因此在 becomePreCandidate 中除了重置基础状态外，仅仅修改了 state 属性和重置其他节点的投票情况。特别需要注意的是不能修改 currentTerm 和 votedFor。 如果预选举的节点获得了半数的节点参选支持，就会进入候选人状态，因此任期加一，同时给自己投票。 此外，当领导者和跟随者在发送心跳或接收到领导人的通知后，都需要重置 timeElappsed，因此将 becomeLeader 和 becomeFollower 设计为重入只会影响到 timeElapsed 和 randomizedElectinTimeout 属性。 PreCampaign 竞选时首先调用 campaign 给其他节点发送 MsgPreVoteRequest 请求。 func (c *core) campaign(ct campaignState) { utils.Assert(c.state != LEADER, "invalid translation [Leader =&gt; PreCandidate/Candidate]") msg := raftpd.Message{} msg.LogIndex = c.log.lastIndex() msg.LogTerm = c.log.lastTerm() if ct == campaignPreCandidate { msg.Term = c.term + 1 msg.MsgType = raftpd.MsgPreVoteRequest c.becomePreCandidate() } else { msg.Term = c.term msg.MsgType = raftpd.MsgVoteRequest c.becomeCandidate() } for i := 0; i &lt; len(c.nodes); i++ { node := &amp;c.nodes[i] msg.To = node.id log.Infof("%x [term: %d, index: %d] send %v request to %x at term %d", c.id, c.log.lastTerm(), c.log.lastIndex(), msg.MsgType, msg.To, c.term) c.send(&amp;msg) } } PreVote 要求某个节点只有在长时间未和领导人交换心跳时才参与选举。同时参与选举要求候选人的日志必须是最新的（领导人完全特性）。所以在接收到其他节点发送的 MsgPreVoteRequest 时，1、如果在一个选举超时内（注意：electionTimeout）有和领导交换过一次心跳；2、或者候选人的任期号小于自身的任期号；3、或者候选人的日志不是最新的都拒绝参加选举。否则回复参加选举。 func (c *core) handlePreVote(msg *raftpd.Message) { reply := raftpd.Message{} reply.To = msg.From reply.MsgType = raftpd.MsgPreVoteResponse // Reply false if last AppendEntries call was received less than election timeout ago. // Reply false if term &lt; currentTerm. // Reply false if candidate's log isn't at least as up­to­date as receiver's log. if (c.leaderId != InvalidId &amp;&amp; c.timeElapsed &lt; c.electionTick) || (msg.Term &lt; c.term) || !c.log.IsUpToDate(msg.LogIndex, msg.LogTerm) { reply.Reject = false } else { reply.Reject = true } c.send(&amp;reply) } 注意：实际上在处理远程信息时，如果接收到了过期信息，会直接丢弃（后面有讲），不会进入 handlePreVote 函数，所以上面第二点实际上永远为假。 预候选人接收到其他节点回复的信息时: func (c *core) handleVoteResponse(msg *raftpd.Message) { if msg.Reject { log.Infof("%x received %v rejection from %x at term %d", c.id, msg.MsgType, msg.From, c.term) } else { log.Infof("%x received %v from %x at term %s", c.id, msg.MsgType, msg.From, msg.Term) } node := c.getNodeById(msg.From) node.updateVoteState(msg.Reject) count := c.voteStateCount(voteGranted) if count &gt;= c.quorum() { if msg.MsgType == raftpd.MsgVoteResponse { c.becomeLeader() c.broadcastVictory() } else { c.campaign(campaignCandidate) } return } // return to follower state if it receives vote denial from a majority count = c.voteStateCount(voteReject) if count &gt;= c.quorum() { c.becomeFollower(msg.Term, InvalidId) } } 更新某个 node 对此次请求的投票情况，并判断支持者和反对者人数，如果支持者人数过半，那么调用 campaign(campaignCandidate) 进入候选人状态。如果反对者人数过半，那么节点会回退到跟随者的状态。 Campaign 在候选人一方，选举过程使用了相同的函数，不同的是跟随者对候选人的处理。只有当候选人未投票或者上一次投给了该候选人，候选人才能获得跟随者的选票。 func (c *core) handleVote(msg *raftpd.Message) { reply := raftpd.Message{} reply.To = msg.From reply.MsgType = raftpd.MsgVoteResponse // no vote or vote for candidate, and log is at least as up-to-date as receiver's. if c.vote == InvalidId || c.vote == msg.From || c.log.IsUpToDate(msg.LogIndex, msg.LogTerm) { reply.Reject = false } else { reply.Reject = true } c.send(&amp;reply) } 处理过时消息 根据 Raft 论文中将 term 用作逻辑时间，判断过期的消息。在论文图 2 中提到如果接收到来自高任期的消息，应该回退到跟随者状态；接收到过时消息，直接忽略。所以代码可以写为： if msg.Term &lt; c.term { c.reject(msg) } if msg.Term &gt; c.term { c.becomeFollower() } 实际上可能某个节点成为候选人后，又重新连接到网络中。此时发起投票会导致其他节点增大任期，因此对投票相关的消息做特殊处理。 func (c *core) Step(msg *raftpd.Message) { if msg.Term &lt; c.term { c.reject(msg) } else if msg.Term &gt; c.term { if msg.MsgType == raftpd.MsgPreVoteRequest { } else if msg.MsgType == raftpd.MsgPreVoteResponse &amp;&amp; msg.Reject { } else { c.becomeFollower(msg.Term, leaderId) } } switch msg.MsgType { case raftpd.MsgPreVoteRequest: c.handlePreVote(msg) case raftpd.MsgVoteRequest: c.handleVote(msg) default: c.dispatch(msg) } } Raft 算法虽然更易于理解，但是实现并不简单。就以上述代码为例，Raft 如果没有 PreVote 机制，那么重新上线的候选人会通过 c.reject(msg) 强制让候选人参与选举。加入 PreVote 机制也不能完全避免这种情况。如果一个节点成为了候选人，此时领导人重新上线，那么候选人仍然会强制发起一次选举[3]。 References 寻找一种易于理解的一致性算法（扩展版） Etcd-raft-core 阅读 Morning Paper, MongoDB 对 Raft 算法的 4 个改动]]></summary></entry><entry><title type="html">Raft 实现指北-日志模块</title><link href="/destribution/2018/01/03/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html" rel="alternate" type="text/html" title="Raft 实现指北-日志模块" /><published>2018-01-03T05:14:14+08:00</published><updated>2018-01-03T05:14:14+08:00</updated><id>/destribution/2018/01/03/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97</id><content type="html" xml:base="/destribution/2018/01/03/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html"><![CDATA[<p>在真正开始设计之前，需要考虑好 Raft 框架的搭建。如下图所示，一个服务器由三部分组成：共识算法、状态机以及日志系统。共识算法控制多副本之间日志的同步、广播。Raft 算法主要的工作是管理日志复制，所以在 Raft 应该有一个可操作的日志模块。</p>

<p><img src="https://camo.githubusercontent.com/ad683fbaefbc0bc0fcb31b1d6ca6ca8f715c12cd/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245312d30312e706e67" alt="图一：复制状态机的结构" /></p>

<h1 id="write-ahead-log">Write Ahead Log</h1>

<p>在设计日志模块之前，需要先说说<strong>预写式日志</strong>（Write Ahead Log, WAL）。预写式日志通常出现在存储系统中，以保证数据的持久性[1]。WAL 的中心思想是对数据文件进行修改前，需要保证操作日志已经同步到稳定存储介质中。如果在进行操作时出现了错误导致程序崩溃，重启的程序可以通过读取日志重建原有状态。</p>

<p>Raft 算法中也需要 WAL 配合工作，比如领导人得知某条日志已经有超过半数的人响应，便将其应用到状态机并将其应用结果返回给客户端。状态机将数据保存在内存中，等待系统写入磁盘。此时如果发生错误，客户端的操作日志丢失，而它又接收到了应用成功的消息，便出现了不一致。</p>

<h1 id="日志模块">日志模块</h1>

<pre><code class="language-C++">struct LogHolder {
    vector&lt;Entry&gt; entries;
}
</code></pre>

<p>日志的存储结构可以简单如上设计，<code class="language-plaintext highlighter-rouge">Entry</code> 表示一套操作日志记录。所有已经通过 WAL 持久化的操作日志保存在 Raft 的 <code class="language-plaintext highlighter-rouge">LogHolder</code> 中做缓存。IO 操作非常耗时，在实际的项目中每次操作先进行 IO 操作，效率不高。通常考虑 Batch 操作，将结构修改为：</p>

<pre><code class="language-C++">struct LogHolder {
    vector&lt;Entry&gt; entries;
    size_t stabled_to;
} 
</code></pre>

<p>这样操作日志和已经持久化的日志保存在一起，并通过 <code class="language-plaintext highlighter-rouge">stable_to</code> 区分开。这样将多个日志 <code class="language-plaintext highlighter-rouge">Entry</code> 一起写入 WAL，Batch 的方法可以提升系统整体的吞吐量，不过对于单条数据，会有部分延迟，与提升比起来是非常值得的。</p>

<p>当某条日志被成功复制到集群中过半数的节点中时，Raft 变认为这条日志可以被应用到状态机中，并标记这部分日志为提交状态。提交的日志采用追加的方式，那么原有数据将一直占用存储空间，而对于系统而言，已经被应用了的日志是无用的，所以 Raft 也提出了日志压缩思想。和存储系统中的日志压缩思路一致，都是通过选取某个时间点的日志创建状态机的快照，将时间点之前的日志全部丢弃。[2]</p>

<p>这里将上述的思想也设计到日志系统中：</p>

<pre><code class="language-C++">// +--------------+--------------+-------------+-------------+
// | wait compact |  wait apply  | wait commit | wait stable |
// +--------------+--------------+-------------+-------------+
// ^ offset       ^ Applied      ^ committed   ^ stabled     ^ last
struct LogHolder {
    vector&lt;Entry&gt; entries;
    size_t offset;
    size_t last_applied;
    size_t last_committed;
    size_t last_stabled;
} 
</code></pre>

<p><code class="language-plaintext highlighter-rouge">offset</code> 表示日志压缩后日志系统里存储的第一条日志在整个日志中的偏移。整个模块需要保证 $0 \le offset \le last\_applied \lt last\_committed \lt entreis.size()$。需要注意，<code class="language-plaintext highlighter-rouge">last_stabled</code> 和 <code class="language-plaintext highlighter-rouge">last_committed</code> 之前不一定存在着先后顺序，比如一个出现了网络隔离的节点在一段时间后上线，领导者将将其日志复制给该节点并告知其已经全部提交了，那么就会出现日志属于已经提交的状态，但是还未持久化。</p>

<p>在 Raft 论文中提到，在生成日志快照时，需要保存快照最后一条日志的 <code class="language-plaintext highlighter-rouge">index</code> 和 <code class="language-plaintext highlighter-rouge">term</code> 作为元信息。也有很多访问该元信息的需求，因此可以在 <code class="language-plaintext highlighter-rouge">entries</code> 中保留一个空白（dummy）日志作为快照元信息，那么 <code class="language-plaintext highlighter-rouge">offset</code> 完全可以被该日志项替代。</p>

<p>整个 <code class="language-plaintext highlighter-rouge">LogHolder</code> 只负责维护日志在内存中的缓存，提供日志追加、应用、提交、持久化以及压缩的基本功能，至于具体的操作实际由使用者负责管理。</p>

<h2 id="api-设计">API 设计</h2>

<p>API 设计是一个模块好用与否的关键，良好的 API 设计可以减少内部设计的暴露，减少模块间的耦合，同时提供最大程度的灵活性。这里希望 API 设计简单易用，接口数量少，粒度适中。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">LogHolder</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">compactTo</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">term</span> <span class="kt">uint64</span><span class="p">)</span>
    <span class="n">commitTo</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span>
    <span class="n">applyEntries</span><span class="p">()</span> <span class="p">[]</span><span class="n">Entry</span>
    <span class="n">stableEntries</span><span class="p">()</span> <span class="p">[]</span><span class="n">Entry</span>
    <span class="n">term</span><span class="p">(</span><span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span>
    <span class="n">isUpToDate</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">term</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="n">tryAppend</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">commitIdx</span> <span class="kt">uint64</span><span class="p">,</span> <span class="n">entries</span> <span class="p">[]</span><span class="n">Entry</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
    <span class="nb">append</span><span class="p">(</span><span class="n">entries</span> <span class="p">[]</span><span class="n">Entry</span><span class="p">)</span> <span class="kt">uint64</span>
    <span class="n">slice</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">[]</span><span class="n">Entry</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">compactTo</code>: 当应用生成了快照后，需要对冗余的日志进行压缩；</li>
  <li><code class="language-plaintext highlighter-rouge">commitTo</code>: 日志复制到集群中半数节点中或跟随者接收到领导人提交日志的命令时调用，修改 <code class="language-plaintext highlighter-rouge">last_commit</code> 属性；</li>
  <li><code class="language-plaintext highlighter-rouge">stableEntries</code>: 读取待持久化的日志，并将这部分日志标记为已经持久化；</li>
  <li><code class="language-plaintext highlighter-rouge">applyEntries</code>: 读取待应用到状态机的日志，同时将其日志标记为已经应用；</li>
  <li><code class="language-plaintext highlighter-rouge">term</code>: 返回某个日志提交到集群中的 <code class="language-plaintext highlighter-rouge">term</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">isUpToDate</code>: 用于判断候选人是否拥有最新的日志；</li>
  <li><code class="language-plaintext highlighter-rouge">tryAppend</code>: 跟随者添加日志，会将冲突的日志丢弃；</li>
  <li><code class="language-plaintext highlighter-rouge">append</code>: 领导添加日志，只有追加功能；</li>
  <li><code class="language-plaintext highlighter-rouge">slice</code>: 分片</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">compactTo</code>，<code class="language-plaintext highlighter-rouge">commitTo</code> 负责修改其只修改日志模块属性信息。<code class="language-plaintext highlighter-rouge">compactTo</code> 对日志进行压缩，其可用范围为 $[offset, last\_applied]$，范围内的数据均已经应用到状态机中。实际上在跟随者从网络隔离中恢复或新加入集群时，领导人会选择发送日志来加速跟随者的同步，此时快照并没有落到可用范围内，或者日志与快照的元信息冲突（跟随者在一个少数派的网络中增加了很多日志），因此需要对整个日志系统进行重建。<code class="language-plaintext highlighter-rouge">commitTo</code> 只需要对 <code class="language-plaintext highlighter-rouge">to</code> 范围进行验证，修改 <code class="language-plaintext highlighter-rouge">last_commit</code> 即可。</p>

<p><code class="language-plaintext highlighter-rouge">stableEntries</code> 和 <code class="language-plaintext highlighter-rouge">applyEntries</code> 不需要任何参数，根据属性设置对应的 <code class="language-plaintext highlighter-rouge">slice</code>，并返回需要持久化、应用的日志队列。</p>

<p><code class="language-plaintext highlighter-rouge">isUpToDate</code> 比较给出的日志项和日志模块谁更新。根据 Raft 论文中给出了谁<strong>比较新</strong>的定义：如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新；如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</p>

<p><code class="language-plaintext highlighter-rouge">tryAppend</code> 是用于提交领导人复制给候选人的日志，由于网络分化或者节点的加入退出，获选人的日志可能落后、冲突于领导人提供的日志，日志模块需要对待追加的日志进行检查，并找出冲突项目并替换。</p>

<h2 id="实现">实现</h2>

<p><code class="language-plaintext highlighter-rouge">compactTo</code> 设计如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">holder</span> <span class="o">*</span><span class="n">LogHolder</span><span class="p">)</span> <span class="n">CompactTo</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">term</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">to</span><span class="p">)</span> <span class="o">!=</span> <span class="n">term</span> <span class="o">||</span> <span class="n">to</span> <span class="o">&lt;=</span> <span class="n">holder</span><span class="o">.</span><span class="n">offset</span><span class="p">()</span> <span class="o">||</span> <span class="n">to</span> <span class="o">&gt;</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastApplied</span> <span class="p">{</span>
		<span class="c">// log entry conflict with exists, or less than offset, or great than applied</span>
		<span class="c">// so need to rebuild log</span>
		<span class="n">entries</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Entry</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
		<span class="n">entries</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">.</span><span class="n">Index</span> <span class="o">=</span> <span class="n">to</span>
		<span class="n">entries</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">.</span><span class="n">Term</span> <span class="o">=</span> <span class="n">term</span>
		<span class="n">holder</span><span class="o">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">entries</span>
		<span class="n">holder</span><span class="o">.</span><span class="n">lastApplied</span> <span class="o">=</span> <span class="n">to</span>
		<span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span> <span class="o">=</span> <span class="n">to</span>
		<span class="n">holder</span><span class="o">.</span><span class="n">lastStabled</span> <span class="o">=</span> <span class="n">to</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">:=</span> <span class="n">holder</span><span class="o">.</span><span class="n">offset</span><span class="p">()</span>
		<span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">to</span><span class="p">,</span> <span class="s">"%d compact idx: %d less than first index: %d"</span><span class="p">,</span>
			<span class="n">holder</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
		<span class="n">holder</span><span class="o">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">drain</span><span class="p">(</span><span class="n">holder</span><span class="o">.</span><span class="n">entries</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">to</span><span class="o">-</span><span class="n">offset</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>首先检查是否存在冲突、或者没有在范围之内，都不存在才对日志队列进行压缩；否则重建日志模块，清空日志队列。因为使用了 dummy 日志项的缘故，这里也要把快照元信息作为一个 dummy log 保存。</p>

<p>和 <code class="language-plaintext highlighter-rouge">compactTo</code> 比起来，<code class="language-plaintext highlighter-rouge">commitTo</code> 的实现就容易得多。<code class="language-plaintext highlighter-rouge">commitTo</code> 需要保证<strong>状态机安全性</strong>和<strong>领导人完全性</strong>[2]，不能减少 <code class="language-plaintext highlighter-rouge">commit_index</code>；同时也要保证容错，即在服务器宕机恢复后数据具有一致性，每个可提交的日志需要已经持久化到本地。<code class="language-plaintext highlighter-rouge">commitTo</code> 需要保证数据范围在 $[commit_index, last\_stabled]$ 之间。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">holder</span> <span class="o">*</span><span class="n">LogHolder</span><span class="p">)</span> <span class="n">CommitTo</span><span class="p">(</span><span class="n">to</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span> <span class="o">&gt;=</span> <span class="n">to</span> <span class="p">{</span>
		<span class="c">/* never decrease commit */</span>
		<span class="k">return</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastStabled</span> <span class="o">&lt;</span> <span class="n">to</span> <span class="p">{</span>
		<span class="c">/* cannot commit unstable log entry */</span>
		<span class="n">to</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">MinUint64</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastStabled</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">holder</span><span class="o">.</span><span class="n">lastIndex</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">to</span><span class="p">,</span> <span class="s">"%d toCommit %d is out of range [last index: %d]"</span><span class="p">,</span>
		<span class="n">holder</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastIndex</span><span class="p">())</span>

	<span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span> <span class="o">=</span> <span class="n">to</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">stableEntries</code> 和 <code class="language-plaintext highlighter-rouge">applyEntries</code> 需要返回待持久化或待应用的日志，同时会修改属性，将这已返回的日志标记为已持久化或已经应用。<code class="language-plaintext highlighter-rouge">term</code> 的实现比较直观，<code class="language-plaintext highlighter-rouge">isUpToDate</code> 的实现按照论文给出的定义即可。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">holder</span> <span class="o">*</span><span class="n">LogHolder</span><span class="p">)</span> <span class="n">IsUpToDate</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">term</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">term</span> <span class="o">&gt;</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastTerm</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">term</span> <span class="o">==</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastTerm</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastIndex</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">append</code> 由领导人负责调用，由<strong>领导人只附加原则</strong>决定其只追加新日志到模块中。因为 Raft 的日志具有连续性，追加时要保证第一条追加的日志要紧接着日志模块的最后一条日志。<code class="language-plaintext highlighter-rouge">tryAppend</code> 由跟随者调用，正常情况下领导人发送的日志可以直接追加到跟随者的日志模块中。跟随者可能是新加入集群，并通过快照已经恢复到了快照所处的状态，此时也可以直接追加到日志模块里。当跟随者出现网络隔离导致日志远低于领导人复制来的第一条日志项（重新选举时），或日志项与领导人提供的存在冲突。如果第一条日志存在冲突，那么需要提醒领导人发送合适的日志；如果仅仅部分日志存在冲突，跟随者需要丢弃冲突日志，然后将领导人提供的日志追加到日志模块中（根据<strong>日志匹配原则</strong>），此时需要保证不能抛弃任何已经提交的日志（<strong>状态机安全性</strong>和<strong>领导人完全性</strong>）。</p>

<p><code class="language-plaintext highlighter-rouge">tryAppend</code> 的第一步是找出第一个与现有日志存在冲突的日志索引，然后根据冲突索引丢弃存在冲突的日志，并返回。<code class="language-plaintext highlighter-rouge">tryAppend</code> 的返回值表示是否成功的将日志追加到系统中。Raft 论文 5.3 节提出了一个优化方式，<em>算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化</em>，这里可以使用算法给出的一种优化方式：当附加日志 RPC 的请求被拒绝的时候，跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。因此在拒绝该追加请求时，还给领导人返回提示索引。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">holder</span> <span class="o">*</span><span class="n">LogHolder</span><span class="p">)</span> <span class="n">getHintIndex</span><span class="p">(</span><span class="n">prevIdx</span><span class="p">,</span> <span class="n">prevTerm</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
	<span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">prevIdx</span> <span class="o">!=</span> <span class="n">InvalidIndex</span> <span class="o">&amp;&amp;</span> <span class="n">prevTerm</span> <span class="o">!=</span> <span class="n">InvalidTerm</span><span class="p">,</span>
		<span class="s">"%d get hint index with invalid idx or Term"</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

	<span class="n">idx</span> <span class="o">:=</span> <span class="n">prevIdx</span>
	<span class="n">term</span> <span class="o">:=</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="n">InvalidIndex</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">!=</span> <span class="n">term</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">MaxUint64</span><span class="p">(</span><span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="n">idx</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span>
<span class="p">}</span>

<span class="c">// findConflict return the first index which Entries[i].Term is not equal</span>
<span class="c">// to holder.Term(Entries[i].Index), if all Term with same index are equals,</span>
<span class="c">// return zero.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">holder</span> <span class="o">*</span><span class="n">LogHolder</span><span class="p">)</span> <span class="n">findConflict</span><span class="p">(</span><span class="n">entries</span> <span class="p">[]</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Entry</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">Index</span><span class="p">)</span> <span class="o">!=</span> <span class="n">entry</span><span class="o">.</span><span class="n">Term</span> <span class="p">{</span>
			<span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">Index</span> <span class="o">&lt;=</span> <span class="n">holder</span><span class="o">.</span><span class="n">lastIndex</span><span class="p">()</span> <span class="p">{</span>
				<span class="n">log</span><span class="o">.</span><span class="n">Infof</span><span class="p">(</span><span class="s">"%d found conflict at index %d, "</span><span class="o">+</span>
					<span class="s">"[existing Term: %d, conflicting Term: %d]"</span><span class="p">,</span>
					<span class="n">holder</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">Index</span><span class="p">),</span> <span class="n">entry</span><span class="o">.</span><span class="n">Term</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">entry</span><span class="o">.</span><span class="n">Index</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">holder</span> <span class="o">*</span><span class="n">LogHolder</span><span class="p">)</span> <span class="n">TryAppend</span><span class="p">(</span><span class="n">prevIdx</span><span class="p">,</span> <span class="n">prevTerm</span><span class="p">,</span> <span class="n">leaderCommittedIdx</span> <span class="kt">uint64</span><span class="p">,</span>
	<span class="n">entries</span> <span class="p">[]</span><span class="n">raftpd</span><span class="o">.</span><span class="n">Entry</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">lastIdxOfEntries</span> <span class="o">:=</span> <span class="n">prevIdx</span> <span class="o">+</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">)(</span><span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">prevIdx</span><span class="p">)</span> <span class="o">==</span> <span class="n">prevTerm</span> <span class="p">{</span>
		<span class="n">conflictIdx</span> <span class="o">:=</span> <span class="n">holder</span><span class="o">.</span><span class="n">findConflict</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">conflictIdx</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
			<span class="c">/* success, no conflict */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">conflictIdx</span> <span class="o">&lt;=</span> <span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Panicf</span><span class="p">(</span><span class="s">"%d entry %d conflict with committed entry %d"</span><span class="p">,</span>
				<span class="n">holder</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">conflictIdx</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">:=</span> <span class="n">prevIdx</span> <span class="o">+</span> <span class="m">1</span>
			<span class="n">holder</span><span class="o">.</span><span class="n">Append</span><span class="p">(</span><span class="n">entries</span><span class="p">[</span><span class="n">conflictIdx</span><span class="o">-</span><span class="n">offset</span><span class="o">:</span><span class="p">])</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">lastIdxOfEntries</span><span class="p">,</span> <span class="no">true</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">utils</span><span class="o">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">prevIdx</span> <span class="o">&gt;</span> <span class="n">holder</span><span class="o">.</span><span class="n">commitIndex</span><span class="p">,</span>
			<span class="s">"%d entry %d [Term: %d] conflict with committed entry Term: %d"</span><span class="p">,</span>
			<span class="n">holder</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">prevIdx</span><span class="p">,</span> <span class="n">prevTerm</span><span class="p">,</span> <span class="n">holder</span><span class="o">.</span><span class="n">Term</span><span class="p">(</span><span class="n">prevIdx</span><span class="p">))</span>

		<span class="k">return</span> <span class="n">holder</span><span class="o">.</span><span class="n">getHintIndex</span><span class="p">(</span><span class="n">prevIdx</span><span class="p">,</span> <span class="n">prevTerm</span><span class="p">),</span> <span class="no">false</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="done">done</h1>

<p>至此，日志模块的实现就结束了。日志模块是整个 Raft 算法的基础，这里将日志模块剥离出来，并将提供一些原子方法。每个方法只干一件事，从而使分析方法正确性的分析更容易；每个方法都可以看作是纯函数，所以输入一定，输出则一定。实际上分布式程序的调试是一个非常困难的方式：</p>

<blockquote>
  <p>你的并发模型往往会成为你代码库中的病毒。你希望有细粒度的并发控制，好吧，你得到了，代码里到处都是。因此是并发导致了不确定性，而不确定性造成了麻烦。因此必须得把并发给踢出去。可是你又不能抛弃并发，你需要它。那么，你一定要禁止把并发和你的分布式状态机结合在一起。换句话说，你的分布式状态机必须成为纯函数式的。没有IO操作，没有并发，什么都没有。[3]</p>
</blockquote>

<p>好的办法是将其抽象成纯函数式的，通过消息进行驱动，这样能够对程序拥有控制力，出现问题是可以完美重现，也能够跟踪定位到问题所在。从 Raft 算法的角度看，在上面的实现里，日志模块只是一个黑匣子，每个操作好比一个按钮，如果得到的不是想要的结果，那肯定是输入有问题（前提是黑匣子实现正确）。因此上面的代码很好的解开了算法和日志模块的耦合，隔离了双方的错误干扰。</p>

<h1 id="references">References</h1>

<ol>
  <li><a href="https://zh.wikipedia.org/wiki/%E9%A2%84%E5%86%99%E5%BC%8F%E6%97%A5%E5%BF%97">预写式日志</a></li>
  <li><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">寻找一种易于理解的一致性算法（扩展版）</a></li>
  <li><a href="http://blog.jobbole.com/20304/">分布式系统编程，你到哪一级了？</a></li>
</ol>]]></content><author><name></name></author><category term="Destribution" /><category term="Raft" /><category term="Consensus" /><category term="Practice" /><category term="Destribution" /><summary type="html"><![CDATA[在真正开始设计之前，需要考虑好 Raft 框架的搭建。如下图所示，一个服务器由三部分组成：共识算法、状态机以及日志系统。共识算法控制多副本之间日志的同步、广播。Raft 算法主要的工作是管理日志复制，所以在 Raft 应该有一个可操作的日志模块。 Write Ahead Log 在设计日志模块之前，需要先说说预写式日志（Write Ahead Log, WAL）。预写式日志通常出现在存储系统中，以保证数据的持久性[1]。WAL 的中心思想是对数据文件进行修改前，需要保证操作日志已经同步到稳定存储介质中。如果在进行操作时出现了错误导致程序崩溃，重启的程序可以通过读取日志重建原有状态。 Raft 算法中也需要 WAL 配合工作，比如领导人得知某条日志已经有超过半数的人响应，便将其应用到状态机并将其应用结果返回给客户端。状态机将数据保存在内存中，等待系统写入磁盘。此时如果发生错误，客户端的操作日志丢失，而它又接收到了应用成功的消息，便出现了不一致。 日志模块 struct LogHolder { vector&lt;Entry&gt; entries; } 日志的存储结构可以简单如上设计，Entry 表示一套操作日志记录。所有已经通过 WAL 持久化的操作日志保存在 Raft 的 LogHolder 中做缓存。IO 操作非常耗时，在实际的项目中每次操作先进行 IO 操作，效率不高。通常考虑 Batch 操作，将结构修改为： struct LogHolder { vector&lt;Entry&gt; entries; size_t stabled_to; } 这样操作日志和已经持久化的日志保存在一起，并通过 stable_to 区分开。这样将多个日志 Entry 一起写入 WAL，Batch 的方法可以提升系统整体的吞吐量，不过对于单条数据，会有部分延迟，与提升比起来是非常值得的。 当某条日志被成功复制到集群中过半数的节点中时，Raft 变认为这条日志可以被应用到状态机中，并标记这部分日志为提交状态。提交的日志采用追加的方式，那么原有数据将一直占用存储空间，而对于系统而言，已经被应用了的日志是无用的，所以 Raft 也提出了日志压缩思想。和存储系统中的日志压缩思路一致，都是通过选取某个时间点的日志创建状态机的快照，将时间点之前的日志全部丢弃。[2] 这里将上述的思想也设计到日志系统中： // +--------------+--------------+-------------+-------------+ // | wait compact | wait apply | wait commit | wait stable | // +--------------+--------------+-------------+-------------+ // ^ offset ^ Applied ^ committed ^ stabled ^ last struct LogHolder { vector&lt;Entry&gt; entries; size_t offset; size_t last_applied; size_t last_committed; size_t last_stabled; } offset 表示日志压缩后日志系统里存储的第一条日志在整个日志中的偏移。整个模块需要保证 $0 \le offset \le last\_applied \lt last\_committed \lt entreis.size()$。需要注意，last_stabled 和 last_committed 之前不一定存在着先后顺序，比如一个出现了网络隔离的节点在一段时间后上线，领导者将将其日志复制给该节点并告知其已经全部提交了，那么就会出现日志属于已经提交的状态，但是还未持久化。 在 Raft 论文中提到，在生成日志快照时，需要保存快照最后一条日志的 index 和 term 作为元信息。也有很多访问该元信息的需求，因此可以在 entries 中保留一个空白（dummy）日志作为快照元信息，那么 offset 完全可以被该日志项替代。 整个 LogHolder 只负责维护日志在内存中的缓存，提供日志追加、应用、提交、持久化以及压缩的基本功能，至于具体的操作实际由使用者负责管理。 API 设计 API 设计是一个模块好用与否的关键，良好的 API 设计可以减少内部设计的暴露，减少模块间的耦合，同时提供最大程度的灵活性。这里希望 API 设计简单易用，接口数量少，粒度适中。 type LogHolder interface { compactTo(to, term uint64) commitTo(uint64) applyEntries() []Entry stableEntries() []Entry term(uint64) uint64 isUpToDate(idx, term uint64) bool tryAppend(idx, term, commitIdx uint64, entries []Entry) (uint64, bool) append(entries []Entry) uint64 slice(lo, hi uint64) []Entry } compactTo: 当应用生成了快照后，需要对冗余的日志进行压缩； commitTo: 日志复制到集群中半数节点中或跟随者接收到领导人提交日志的命令时调用，修改 last_commit 属性； stableEntries: 读取待持久化的日志，并将这部分日志标记为已经持久化； applyEntries: 读取待应用到状态机的日志，同时将其日志标记为已经应用； term: 返回某个日志提交到集群中的 term； isUpToDate: 用于判断候选人是否拥有最新的日志； tryAppend: 跟随者添加日志，会将冲突的日志丢弃； append: 领导添加日志，只有追加功能； slice: 分片 compactTo，commitTo 负责修改其只修改日志模块属性信息。compactTo 对日志进行压缩，其可用范围为 $[offset, last\_applied]$，范围内的数据均已经应用到状态机中。实际上在跟随者从网络隔离中恢复或新加入集群时，领导人会选择发送日志来加速跟随者的同步，此时快照并没有落到可用范围内，或者日志与快照的元信息冲突（跟随者在一个少数派的网络中增加了很多日志），因此需要对整个日志系统进行重建。commitTo 只需要对 to 范围进行验证，修改 last_commit 即可。 stableEntries 和 applyEntries 不需要任何参数，根据属性设置对应的 slice，并返回需要持久化、应用的日志队列。 isUpToDate 比较给出的日志项和日志模块谁更新。根据 Raft 论文中给出了谁比较新的定义：如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新；如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。 tryAppend 是用于提交领导人复制给候选人的日志，由于网络分化或者节点的加入退出，获选人的日志可能落后、冲突于领导人提供的日志，日志模块需要对待追加的日志进行检查，并找出冲突项目并替换。 实现 compactTo 设计如下： func (holder *LogHolder) CompactTo(to, term uint64) { if holder.Term(to) != term || to &lt;= holder.offset() || to &gt; holder.lastApplied { // log entry conflict with exists, or less than offset, or great than applied // so need to rebuild log entries := make([]raftpd.Entry, 1) entries[0].Index = to entries[0].Term = term holder.entries = entries holder.lastApplied = to holder.commitIndex = to holder.lastStabled = to } else { offset := holder.offset() utils.Assert(offset &lt;= to, "%d compact idx: %d less than first index: %d", holder.id, to, offset) holder.entries = drain(holder.entries, int(to-offset)) } } 首先检查是否存在冲突、或者没有在范围之内，都不存在才对日志队列进行压缩；否则重建日志模块，清空日志队列。因为使用了 dummy 日志项的缘故，这里也要把快照元信息作为一个 dummy log 保存。 和 compactTo 比起来，commitTo 的实现就容易得多。commitTo 需要保证状态机安全性和领导人完全性[2]，不能减少 commit_index；同时也要保证容错，即在服务器宕机恢复后数据具有一致性，每个可提交的日志需要已经持久化到本地。commitTo 需要保证数据范围在 $[commit_index, last\_stabled]$ 之间。 func (holder *LogHolder) CommitTo(to uint64) { if holder.commitIndex &gt;= to { /* never decrease commit */ return } else if holder.lastStabled &lt; to { /* cannot commit unstable log entry */ to = utils.MinUint64(to, holder.lastStabled) } utils.Assert(holder.lastIndex() &gt;= to, "%d toCommit %d is out of range [last index: %d]", holder.id, to, holder.lastIndex()) holder.commitIndex = to } stableEntries 和 applyEntries 需要返回待持久化或待应用的日志，同时会修改属性，将这已返回的日志标记为已持久化或已经应用。term 的实现比较直观，isUpToDate 的实现按照论文给出的定义即可。 func (holder *LogHolder) IsUpToDate(idx, term uint64) bool { return term &gt; holder.lastTerm() || (term == holder.lastTerm() &amp;&amp; idx &gt;= holder.lastIndex()) } append 由领导人负责调用，由领导人只附加原则决定其只追加新日志到模块中。因为 Raft 的日志具有连续性，追加时要保证第一条追加的日志要紧接着日志模块的最后一条日志。tryAppend 由跟随者调用，正常情况下领导人发送的日志可以直接追加到跟随者的日志模块中。跟随者可能是新加入集群，并通过快照已经恢复到了快照所处的状态，此时也可以直接追加到日志模块里。当跟随者出现网络隔离导致日志远低于领导人复制来的第一条日志项（重新选举时），或日志项与领导人提供的存在冲突。如果第一条日志存在冲突，那么需要提醒领导人发送合适的日志；如果仅仅部分日志存在冲突，跟随者需要丢弃冲突日志，然后将领导人提供的日志追加到日志模块中（根据日志匹配原则），此时需要保证不能抛弃任何已经提交的日志（状态机安全性和领导人完全性）。 tryAppend 的第一步是找出第一个与现有日志存在冲突的日志索引，然后根据冲突索引丢弃存在冲突的日志，并返回。tryAppend 的返回值表示是否成功的将日志追加到系统中。Raft 论文 5.3 节提出了一个优化方式，算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化，这里可以使用算法给出的一种优化方式：当附加日志 RPC 的请求被拒绝的时候，跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。因此在拒绝该追加请求时，还给领导人返回提示索引。 func (holder *LogHolder) getHintIndex(prevIdx, prevTerm uint64) uint64 { utils.Assert(prevIdx != InvalidIndex &amp;&amp; prevTerm != InvalidTerm, "%d get hint index with invalid idx or Term", holder.id) idx := prevIdx term := holder.Term(idx) for idx &gt; InvalidIndex { if holder.Term(idx) != term { return utils.MaxUint64(holder.commitIndex, idx) } idx-- } return holder.commitIndex } // findConflict return the first index which Entries[i].Term is not equal // to holder.Term(Entries[i].Index), if all Term with same index are equals, // return zero. func (holder *LogHolder) findConflict(entries []raftpd.Entry) uint64 { for i := 0; i &lt; len(entries); i++ { entry := &amp;entries[i] if holder.Term(entry.Index) != entry.Term { if entry.Index &lt;= holder.lastIndex() { log.Infof("%d found conflict at index %d, "+ "[existing Term: %d, conflicting Term: %d]", holder.id, entry.Index, holder.Term(entry.Index), entry.Term) } return entry.Index } } return 0 } func (holder *LogHolder) TryAppend(prevIdx, prevTerm, leaderCommittedIdx uint64, entries []raftpd.Entry) (uint64, bool) { lastIdxOfEntries := prevIdx + (uint64)(len(entries)) if holder.Term(prevIdx) == prevTerm { conflictIdx := holder.findConflict(entries) if conflictIdx == 0 { /* success, no conflict */ } else if conflictIdx &lt;= holder.commitIndex { log.Panicf("%d entry %d conflict with committed entry %d", holder.id, conflictIdx, holder.commitIndex) } else { offset := prevIdx + 1 holder.Append(entries[conflictIdx-offset:]) } return lastIdxOfEntries, true } else { utils.Assert(prevIdx &gt; holder.commitIndex, "%d entry %d [Term: %d] conflict with committed entry Term: %d", holder.id, prevIdx, prevTerm, holder.Term(prevIdx)) return holder.getHintIndex(prevIdx, prevTerm), false } } done 至此，日志模块的实现就结束了。日志模块是整个 Raft 算法的基础，这里将日志模块剥离出来，并将提供一些原子方法。每个方法只干一件事，从而使分析方法正确性的分析更容易；每个方法都可以看作是纯函数，所以输入一定，输出则一定。实际上分布式程序的调试是一个非常困难的方式： 你的并发模型往往会成为你代码库中的病毒。你希望有细粒度的并发控制，好吧，你得到了，代码里到处都是。因此是并发导致了不确定性，而不确定性造成了麻烦。因此必须得把并发给踢出去。可是你又不能抛弃并发，你需要它。那么，你一定要禁止把并发和你的分布式状态机结合在一起。换句话说，你的分布式状态机必须成为纯函数式的。没有IO操作，没有并发，什么都没有。[3] 好的办法是将其抽象成纯函数式的，通过消息进行驱动，这样能够对程序拥有控制力，出现问题是可以完美重现，也能够跟踪定位到问题所在。从 Raft 算法的角度看，在上面的实现里，日志模块只是一个黑匣子，每个操作好比一个按钮，如果得到的不是想要的结果，那肯定是输入有问题（前提是黑匣子实现正确）。因此上面的代码很好的解开了算法和日志模块的耦合，隔离了双方的错误干扰。 References 预写式日志 寻找一种易于理解的一致性算法（扩展版） 分布式系统编程，你到哪一级了？]]></summary></entry><entry><title type="html">Raft 实现指北-开篇</title><link href="/destribution/2018/01/01/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E5%BC%80%E7%AF%87.html" rel="alternate" type="text/html" title="Raft 实现指北-开篇" /><published>2018-01-01T17:34:16+08:00</published><updated>2018-01-01T17:34:16+08:00</updated><id>/destribution/2018/01/01/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E5%BC%80%E7%AF%87</id><content type="html" xml:base="/destribution/2018/01/01/Raft-%E5%AE%9E%E7%8E%B0%E6%8C%87%E5%8C%97-%E5%BC%80%E7%AF%87.html"><![CDATA[<p>Raft 是一种解决分布式共识问题的算法。何为分布式共识问题？在此之前，还得说说分布式系统中的基础模型。基础模型是对分布式算法的一个定性的评估（分类）标准，它说明了算法的作用范围，可解决什么问题。</p>

<h1 id="基础模型">基础模型</h1>

<p>基础模型也可以称为算法的属性，这里主要关心两个部分：定时模型（Timing Model）、失效模式（Failure Model）、失效检测器（Failure Detectors）[1]。</p>

<p>定时模型是研究分布式系统的网络传输时延特性，分布式系统通过消息传递来进行通信，根据消息在网络中传递时间是否有上界，可以将消息系统分类为：<strong>同步模型（Synchronous Model）</strong>和<strong>异步模型（Asynchronous Model）</strong>[2]。在同步模型中，消息传递时间是已知的，每个进程的速度也是确定的，即每个进程执行一个算法步骤耗时是确定的。在异步模型中，每个组件自行决定算法步骤的执行顺序，每一步的耗时也没有保证[1]。注意，这里的<em>同步</em>和<em>异步</em>要与编程中出现的同步异步加以区分。</p>

<p>失效模式是对分布式系统中节点失效种类的假设。最基础的是<strong>崩溃-结束（crash-stop）失效模式</strong>，节点一直正常运行，直至崩溃，节点崩溃后不会恢复。相较于崩溃-结束失效模式，另一种<strong>崩溃-恢复（crash-recovery）失效模式</strong>更为常见，即节点崩溃后，会被恢复。值得一提的是崩溃-恢复模式中，一个节点恢复时，并不等同于没崩溃的原始节点（比如 Raft 算法动态调整系群组关系，某个节点被另一个新加入节点顶替）。一种更复杂的失效模式叫做<strong>拜占庭失效模式</strong>或者<strong>任意失效模式（Byzantine or arbitrary failures mode）</strong>：进程有可能向同伴发送错误的信息；进程可能是冒充的；应答给其他进程的数据是正确的，但是篡改了本地数据库的内容，等等[2]。设计分布式系统时，失效模式必须考虑进去，通常来说，我们并不需要考虑拜占庭失效模式。</p>

<p>上述两种属性能够描述分布式系统所处的问题，另外还有部分属性用于对系统工作方式进行分类，失效检测器便是这样的一种属性。<strong>失效检测器</strong>是对<em>报告系统状态</em>的抽象，即检测节点是否已经崩溃（或者怀疑是否崩溃）。失效检测器是在异步系统中解决共识问题的关键。在著名的FLP论文中指出，在异步的分布式系统中，如果进程有可能失效，那么就不可能达成共识。要达成共识，就必须为系统引入一个能够规避上述问题的失效检测器[1]。</p>

<h1 id="分布式共识问题">分布式共识问题</h1>

<p>分布式共识问题，简单说，就是在一个或多个进程提议了一个值应当是什么后，使系统中所有进程对这个值达成一致意见。为了达到共识，每个进程都提出自己的提议（propose），最终通过共识算法，所有正确运行的进程决定（decide）相同的值[2]。</p>

<p>在同步、可靠的系统中，想要多个节点达成一致比较容易。实际的分布式场景多为异步模型，FLP不可能性说明：没有任何算法可以在存在任何故障的异步系统中确保达到共识，绕过不可能性结论的办法是考虑部分同步系统，利用故障屏蔽、故障检测器或随机化手段避开异步系统模型[2]。</p>

<p>分布式问题最常见的应用场景是多副本状态机（Replicated state machine）。<strong>多副本状态机是指多台机器具有完全相同的状态，并且运行有完全相同的确定性状态机</strong>[2]。多副本状态机主要用于解决分布式系统中的容错问题，因为副本冗余了状态机，只要保证大多数副本存活且一致，就能向外部提供服务。多副本状态机的实现思想：状态机的每个副本上都保存有完全相同的操作日志，保证所有副本状态机按照相同的顺序执行操作，这样由于状态机是确定性的，则一定会得到相同的状态[2]。具体的实现方式主要分为两种[3]：</p>

<ul>
  <li>日志复制：由 primary 机接受操作日志，并广播给 backup 机，backup 机需要跟 primary 机的操作日志保持一致；</li>
  <li>状态重演：操作日志由多个副本共享，每个副本通过重新执行操作日志从放状态；</li>
</ul>

<h1 id="raft-算法">Raft 算法</h1>

<p>有三种非常具有代表性的分布式共识算法：分别是 Viewstamped Replication 、Raft 和大名鼎鼎的 Paxos 算法，前两个工作本身就是基于多副本状态机的场景完成的，而 Paxos 算法是作为独立的分布式共识算法提出，并给出了使用该算法实现多副本状态机的范例[2]。</p>

<p>Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。从一个用户研究的结果可以证明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性[4]。</p>

<p>与其他共识算法相比，Raft 算法有三个特点[4]：</p>

<ul>
  <li>强领导者：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。</li>
  <li>领导选举：Raft 算法使用一个随机计时器来选举领导者。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。</li>
  <li>成员关系调整：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。</li>
</ul>

<p>虽然这篇文章标题有“Raft 实现”关键字，但并不会讲 Raft 算法的原理，这只是 Raft 的功能实现介绍，所以我建议在继续阅读之前，先学习一下 Raft 算法：<a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">寻找一种易于理解的一致性算法（扩展版）</a>。</p>
<h1 id="挖坑">挖坑</h1>

<p>一个基础的 Raft 功能只需要实现选举和日志复制，但这远远不够。想要应用到实际的工程中，还需要实现日至压缩、成员关系调整，才算完整的 Raft 实现。这里给出个 Raft 功能清单，实际上也是本系列文章希望实现的功能：</p>

<ul>
  <li>leader election</li>
  <li>prevote</li>
  <li>log replication</li>
  <li>log compaction &amp; snapshot</li>
  <li>linearizable read(read index &amp; lease)</li>
  <li>membership change</li>
  <li>leadership transfer</li>
</ul>

<p>拥有上述功能可以算上一个工业级的 Raft 实现，不过在实际应用中，还会有许多工业上的优化技巧比如 Batch 和 Pipeline，具体有哪些可以优化的，放到以后的章节详述。</p>

<p>这是我在学习 Raft 算法，并以之为基础实现分布式系统过程中的学习总结。在接下来的几篇文章中，将按照上述清单依次谈谈对应的实现方法和优化原理。实现方法参考优秀的开源实现：etcd/raft 以及其各语言移植版本。</p>

<h1 id="reference">Reference</h1>

<ol>
  <li><a href="http://alvaro-videla.com/2015/12/learning-about-distributed-systems.html">WHAT WE TALK ABOUT WHEN WE TALK ABOUT DISTRIBUTED SYSTEMS</a></li>
  <li><a href="http://blog.kongfy.com/2016/05/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86consensus%EF%BC%9Aviewstamped%E3%80%81raft%E5%8F%8Apaxos/">分布式共识(Consensus)：Viewstamped Replication、Raft以及Paxos</a></li>
  <li>The design of a practical system for Fault-Tolerant Virtual Machines</li>
  <li><a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">寻找一种易于理解的一致性算法（扩展版）</a></li>
  <li><a href="http://blog.jobbole.com/20304/">分布式系统编程，你到哪一级了？</a></li>
</ol>]]></content><author><name></name></author><category term="Destribution" /><category term="Raft" /><category term="Consensus" /><category term="Practice" /><category term="Destribution" /><summary type="html"><![CDATA[Raft 是一种解决分布式共识问题的算法。何为分布式共识问题？在此之前，还得说说分布式系统中的基础模型。基础模型是对分布式算法的一个定性的评估（分类）标准，它说明了算法的作用范围，可解决什么问题。 基础模型 基础模型也可以称为算法的属性，这里主要关心两个部分：定时模型（Timing Model）、失效模式（Failure Model）、失效检测器（Failure Detectors）[1]。 定时模型是研究分布式系统的网络传输时延特性，分布式系统通过消息传递来进行通信，根据消息在网络中传递时间是否有上界，可以将消息系统分类为：同步模型（Synchronous Model）和异步模型（Asynchronous Model）[2]。在同步模型中，消息传递时间是已知的，每个进程的速度也是确定的，即每个进程执行一个算法步骤耗时是确定的。在异步模型中，每个组件自行决定算法步骤的执行顺序，每一步的耗时也没有保证[1]。注意，这里的同步和异步要与编程中出现的同步异步加以区分。 失效模式是对分布式系统中节点失效种类的假设。最基础的是崩溃-结束（crash-stop）失效模式，节点一直正常运行，直至崩溃，节点崩溃后不会恢复。相较于崩溃-结束失效模式，另一种崩溃-恢复（crash-recovery）失效模式更为常见，即节点崩溃后，会被恢复。值得一提的是崩溃-恢复模式中，一个节点恢复时，并不等同于没崩溃的原始节点（比如 Raft 算法动态调整系群组关系，某个节点被另一个新加入节点顶替）。一种更复杂的失效模式叫做拜占庭失效模式或者任意失效模式（Byzantine or arbitrary failures mode）：进程有可能向同伴发送错误的信息；进程可能是冒充的；应答给其他进程的数据是正确的，但是篡改了本地数据库的内容，等等[2]。设计分布式系统时，失效模式必须考虑进去，通常来说，我们并不需要考虑拜占庭失效模式。 上述两种属性能够描述分布式系统所处的问题，另外还有部分属性用于对系统工作方式进行分类，失效检测器便是这样的一种属性。失效检测器是对报告系统状态的抽象，即检测节点是否已经崩溃（或者怀疑是否崩溃）。失效检测器是在异步系统中解决共识问题的关键。在著名的FLP论文中指出，在异步的分布式系统中，如果进程有可能失效，那么就不可能达成共识。要达成共识，就必须为系统引入一个能够规避上述问题的失效检测器[1]。 分布式共识问题 分布式共识问题，简单说，就是在一个或多个进程提议了一个值应当是什么后，使系统中所有进程对这个值达成一致意见。为了达到共识，每个进程都提出自己的提议（propose），最终通过共识算法，所有正确运行的进程决定（decide）相同的值[2]。 在同步、可靠的系统中，想要多个节点达成一致比较容易。实际的分布式场景多为异步模型，FLP不可能性说明：没有任何算法可以在存在任何故障的异步系统中确保达到共识，绕过不可能性结论的办法是考虑部分同步系统，利用故障屏蔽、故障检测器或随机化手段避开异步系统模型[2]。 分布式问题最常见的应用场景是多副本状态机（Replicated state machine）。多副本状态机是指多台机器具有完全相同的状态，并且运行有完全相同的确定性状态机[2]。多副本状态机主要用于解决分布式系统中的容错问题，因为副本冗余了状态机，只要保证大多数副本存活且一致，就能向外部提供服务。多副本状态机的实现思想：状态机的每个副本上都保存有完全相同的操作日志，保证所有副本状态机按照相同的顺序执行操作，这样由于状态机是确定性的，则一定会得到相同的状态[2]。具体的实现方式主要分为两种[3]： 日志复制：由 primary 机接受操作日志，并广播给 backup 机，backup 机需要跟 primary 机的操作日志保持一致； 状态重演：操作日志由多个副本共享，每个副本通过重新执行操作日志从放状态； Raft 算法 有三种非常具有代表性的分布式共识算法：分别是 Viewstamped Replication 、Raft 和大名鼎鼎的 Paxos 算法，前两个工作本身就是基于多副本状态机的场景完成的，而 Paxos 算法是作为独立的分布式共识算法提出，并给出了使用该算法实现多副本状态机的范例[2]。 Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。从一个用户研究的结果可以证明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性[4]。 与其他共识算法相比，Raft 算法有三个特点[4]： 强领导者：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。 领导选举：Raft 算法使用一个随机计时器来选举领导者。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。 成员关系调整：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。 虽然这篇文章标题有“Raft 实现”关键字，但并不会讲 Raft 算法的原理，这只是 Raft 的功能实现介绍，所以我建议在继续阅读之前，先学习一下 Raft 算法：寻找一种易于理解的一致性算法（扩展版）。 挖坑 一个基础的 Raft 功能只需要实现选举和日志复制，但这远远不够。想要应用到实际的工程中，还需要实现日至压缩、成员关系调整，才算完整的 Raft 实现。这里给出个 Raft 功能清单，实际上也是本系列文章希望实现的功能： leader election prevote log replication log compaction &amp; snapshot linearizable read(read index &amp; lease) membership change leadership transfer 拥有上述功能可以算上一个工业级的 Raft 实现，不过在实际应用中，还会有许多工业上的优化技巧比如 Batch 和 Pipeline，具体有哪些可以优化的，放到以后的章节详述。 这是我在学习 Raft 算法，并以之为基础实现分布式系统过程中的学习总结。在接下来的几篇文章中，将按照上述清单依次谈谈对应的实现方法和优化原理。实现方法参考优秀的开源实现：etcd/raft 以及其各语言移植版本。 Reference WHAT WE TALK ABOUT WHEN WE TALK ABOUT DISTRIBUTED SYSTEMS 分布式共识(Consensus)：Viewstamped Replication、Raft以及Paxos The design of a practical system for Fault-Tolerant Virtual Machines 寻找一种易于理解的一致性算法（扩展版） 分布式系统编程，你到哪一级了？]]></summary></entry><entry><title type="html">Mysql 事务隔离级别的使用</title><link href="/%E6%80%BB%E7%BB%93/2017/12/07/Mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E4%BD%BF%E7%94%A8.html" rel="alternate" type="text/html" title="Mysql 事务隔离级别的使用" /><published>2017-12-07T23:00:00+08:00</published><updated>2017-12-07T23:00:00+08:00</updated><id>/%E6%80%BB%E7%BB%93/2017/12/07/Mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E4%BD%BF%E7%94%A8</id><content type="html" xml:base="/%E6%80%BB%E7%BB%93/2017/12/07/Mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E4%BD%BF%E7%94%A8.html"><![CDATA[<p>最近在项目中遇到一个问题，在 Mysql 的 Repeatable Read 隔离级别下，出现了数据丢失更新。一开始怀疑的是事务失效，被排查后否定。最后定位到 Mysql 事务的使用问题上。我们的 Sql 场景类似于：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT number FROM A WHERE ID = 1;
UPDATE A SET NUMBER = number + 1 WHERE ID = 1;
</code></pre></div></div>

<h2 id="事务回顾">事务回顾</h2>

<p>事务有四种特性（ACID）：</p>

<ul>
  <li>原子性</li>
  <li>隔离性</li>
  <li>一致性</li>
  <li>持久性</li>
</ul>

<p>在执行事务时可能出现以下问题：</p>

<ul>
  <li>丢失更新：
    <ol>
      <li>第一类丢失更新：事务失败回滚时将其他事务已经提交的数据覆盖</li>
      <li>第二类丢失更新：事务提交时，覆盖了其他事务的提交（类似 += ，是不可重复读的特例）</li>
    </ol>
  </li>
  <li>脏读：事务读取了其他事务还未提交的内容</li>
  <li>不可重复读：一个事务中多次读取同一个内容，结果不一致</li>
  <li>幻读：一个事务中两次查询，但第二次查询比第一次查询多了或少了几行或几列数据</li>
</ul>

<p>为了解决上述问题，数据库系统提供了四种事务隔离级别供用户选择：</p>

<ul>
  <li>Read Uncommitted 读未提交：不允许第一类更新丢失。允许脏读，不隔离事务。</li>
  <li>Read Committed 读已提交：不允许脏读，允许不可重复读。</li>
  <li>Repeatable Read 可重复读：不允许不可重复读。但可能出现幻读。</li>
  <li>Serializable 串行化：所有的增删改查串行执行。</li>
</ul>

<p>在传统的事务隔离级别的实现中，可重复读已经能够避免了两类丢失更新，对于绝大多数的事务，只需要将
隔离级别设置为可重复读。</p>

<h2 id="snapshot-isolation--mvcc">Snapshot isolation &amp; MVCC</h2>

<p>需要明确的是，以上的ACID和隔离级别定义是在SQL规范层面的定义，不同数据库的实现方式和使用方式并不相同。上面的隔离级别标准是SQL92 基于读写锁的实现方式制定的规范。</p>

<p>为了克服并发问题，各个数据库厂商都引入了 MVCC （多版本并发控制）来提高并发度。所以实际上的事务实现与规范定义的出现了细微的差别，而这细微的差别，就是本文出现的原因。（下文主要以 Mysql innoDB 存储引擎的 MVCC 实现为主，InnoDB 中的 MVCC 为表添加了隐藏的列，打上版本号，来提供多版本功能）。</p>

<p>所以在 MVCC 中，SELECT 语句执行时，会执行快照读取（称为快照读，也称为一致性读）。如果数据被锁，直接读取 undo log 来读取其被锁前的副本。在 Read Commit 隔离级别中，快照读总是读取对应行的最新版本；如果该行被锁住，则会读取最近一次的快照。在 Repeatable Read 隔离级别中，快照读总是读取事务开始时的数据版本。</p>

<p>这种方式极大的提升了并发读取的效率，本质也非常类似乐观锁。所以这种方式实现的隔离级别与规范定义存在一定差异，在 Repeatable Read 中，这种差异导致了 innoDB 第二类更新丢失的出现。因此，使用 MVCC 实现的隔离级别也被称为快照隔离级别。</p>

<p>SI 隔离与规范的 RR 隔离级别的区别在于读取 SI 的 SELECT 语句为快照读，而传统的 SELECT 语句则为当前读（加读锁:locking read, LR）。</p>

<p>在 InnoDB 中，update, delete 执行的是加锁读，想要将 SELECT 语句也设置为加锁读，需要在语句后加上 FOR UPDATE, LOCK IN SHARE MODE。具体的加锁方式取决于用户使用的是那种查询计划：</p>

<ul>
  <li>unique index with a unique search condition</li>
  <li>a range-type search condition</li>
</ul>

<p>对于第一种方式，InnoDB 只对其所在的索引进行加锁，不影响其他内容。对于第二种方式，InnoDB 通过使用间隙锁（gap locks)或者 next-key locks 来实现。因为这种加锁落实到区间上，所以也有可能锁住不必要的内容。因此 InnoDB 也号称在 RR 级别上实现了 Serializable 隔离级别。</p>

<p>next-key locks 能排除大多数的幻读现象，只会存在 write skew style 的幻读。</p>

<p>回到题目最开始的问题上，因为这种不规范的事务实现，导致了在高并发情况下会存在第二类丢失更新问题。只需要在 SELECT 后面加上 FOR UPDATE 就能避免出现的问题。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://www.jianshu.com/p/71a79d838443">事务并发的问题以及其解决方案</a></li>
  <li><a href="http://www.fanyilun.me/2015/12/29/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8AMysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/">事务隔离级别与 Mysql 中事务的使用</a></li>
  <li><a href="https://tech.meituan.com/innodb-lock.html">Innodb中的事务隔离级别和锁的关系</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html">Consistent Nonlocking Reads</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-transaction-isolation-levels.html">innodb-transaction-isolation-levels</a></li>
</ul>]]></content><author><name></name></author><category term="总结" /><category term="Mysql" /><summary type="html"><![CDATA[最近在项目中遇到一个问题，在 Mysql 的 Repeatable Read 隔离级别下，出现了数据丢失更新。一开始怀疑的是事务失效，被排查后否定。最后定位到 Mysql 事务的使用问题上。我们的 Sql 场景类似于： SELECT number FROM A WHERE ID = 1; UPDATE A SET NUMBER = number + 1 WHERE ID = 1; 事务回顾 事务有四种特性（ACID）： 原子性 隔离性 一致性 持久性 在执行事务时可能出现以下问题： 丢失更新： 第一类丢失更新：事务失败回滚时将其他事务已经提交的数据覆盖 第二类丢失更新：事务提交时，覆盖了其他事务的提交（类似 += ，是不可重复读的特例） 脏读：事务读取了其他事务还未提交的内容 不可重复读：一个事务中多次读取同一个内容，结果不一致 幻读：一个事务中两次查询，但第二次查询比第一次查询多了或少了几行或几列数据 为了解决上述问题，数据库系统提供了四种事务隔离级别供用户选择： Read Uncommitted 读未提交：不允许第一类更新丢失。允许脏读，不隔离事务。 Read Committed 读已提交：不允许脏读，允许不可重复读。 Repeatable Read 可重复读：不允许不可重复读。但可能出现幻读。 Serializable 串行化：所有的增删改查串行执行。 在传统的事务隔离级别的实现中，可重复读已经能够避免了两类丢失更新，对于绝大多数的事务，只需要将 隔离级别设置为可重复读。 Snapshot isolation &amp; MVCC 需要明确的是，以上的ACID和隔离级别定义是在SQL规范层面的定义，不同数据库的实现方式和使用方式并不相同。上面的隔离级别标准是SQL92 基于读写锁的实现方式制定的规范。 为了克服并发问题，各个数据库厂商都引入了 MVCC （多版本并发控制）来提高并发度。所以实际上的事务实现与规范定义的出现了细微的差别，而这细微的差别，就是本文出现的原因。（下文主要以 Mysql innoDB 存储引擎的 MVCC 实现为主，InnoDB 中的 MVCC 为表添加了隐藏的列，打上版本号，来提供多版本功能）。 所以在 MVCC 中，SELECT 语句执行时，会执行快照读取（称为快照读，也称为一致性读）。如果数据被锁，直接读取 undo log 来读取其被锁前的副本。在 Read Commit 隔离级别中，快照读总是读取对应行的最新版本；如果该行被锁住，则会读取最近一次的快照。在 Repeatable Read 隔离级别中，快照读总是读取事务开始时的数据版本。 这种方式极大的提升了并发读取的效率，本质也非常类似乐观锁。所以这种方式实现的隔离级别与规范定义存在一定差异，在 Repeatable Read 中，这种差异导致了 innoDB 第二类更新丢失的出现。因此，使用 MVCC 实现的隔离级别也被称为快照隔离级别。 SI 隔离与规范的 RR 隔离级别的区别在于读取 SI 的 SELECT 语句为快照读，而传统的 SELECT 语句则为当前读（加读锁:locking read, LR）。 在 InnoDB 中，update, delete 执行的是加锁读，想要将 SELECT 语句也设置为加锁读，需要在语句后加上 FOR UPDATE, LOCK IN SHARE MODE。具体的加锁方式取决于用户使用的是那种查询计划： unique index with a unique search condition a range-type search condition 对于第一种方式，InnoDB 只对其所在的索引进行加锁，不影响其他内容。对于第二种方式，InnoDB 通过使用间隙锁（gap locks)或者 next-key locks 来实现。因为这种加锁落实到区间上，所以也有可能锁住不必要的内容。因此 InnoDB 也号称在 RR 级别上实现了 Serializable 隔离级别。 next-key locks 能排除大多数的幻读现象，只会存在 write skew style 的幻读。 回到题目最开始的问题上，因为这种不规范的事务实现，导致了在高并发情况下会存在第二类丢失更新问题。只需要在 SELECT 后面加上 FOR UPDATE 就能避免出现的问题。 References 事务并发的问题以及其解决方案 事务隔离级别与 Mysql 中事务的使用 Innodb中的事务隔离级别和锁的关系 Consistent Nonlocking Reads innodb-transaction-isolation-levels]]></summary></entry><entry><title type="html">个人站点：Mysql 5.6 内存占用配置</title><link href="/linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/2017/09/08/%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9-Mysql-5-6-%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E9%85%8D%E7%BD%AE.html" rel="alternate" type="text/html" title="个人站点：Mysql 5.6 内存占用配置" /><published>2017-09-08T06:58:09+08:00</published><updated>2017-09-08T06:58:09+08:00</updated><id>/linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/2017/09/08/%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9:Mysql-5-6-%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E9%85%8D%E7%BD%AE</id><content type="html" xml:base="/linux/%E6%9C%8D%E5%8A%A1%E5%99%A8/2017/09/08/%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9-Mysql-5-6-%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E9%85%8D%E7%BD%AE.html"><![CDATA[<p>前两天刚把服务器部署上，今天就出现了异常。在 App 上看是服务器直接宕机。原本以为仅仅是服务端挂了，在服务器上使用 <code class="language-plaintext highlighter-rouge">ps aux | grep java</code> 发现进程还在，只是不服务了。打开 log 发现 Java run out of memory，导致无法创建新的线程。</p>

<p>使用 <code class="language-plaintext highlighter-rouge">top -o %MEM</code> 查看，java 占用近 200M，mysql 占用近 500 M。因为是个人用的小服务器，只有 1G 内存，吃紧得很。既然 mysql 占用了最多的内存，就让它吐出一点好了。</p>

<p>一开始猜测是 InnoDB 缓冲区过大，不过在 <code class="language-plaintext highlighter-rouge">/etc/mysql/my.cnf</code> 中发现配置的缓存已经非常小了。后来在网上发现是因为 Mysql 5.6 版本默认 GA 配置过大，导致初始需要近 400M 空间。通过下面配置，直接讲内存降到 100M 以下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>performance_schema_max_table_instances=400
table_definition_cache=400
table_open_cache=256
</code></pre></div></div>

<p>参数意义：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">performance_schema_max_table_instances</code></li>
</ul>

<p>The maximum number of instrumented table objects</p>

<p>检测的表对象的最大数目。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">table_definition_cache</code></li>
</ul>

<p>The number of table definitions (from .frm files) that can be stored in the definition cache. If you use a large number of tables, you can create a large table definition cache to speed up opening of tables. The table definition cache takes less space and does not use file descriptors, unlike the normal table cache. The minimum and default values are both 400.</p>

<p>缓存 <code class="language-plaintext highlighter-rouge">frm</code> 文件</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">table_open_cache</code>
The number of open tables for all threads. Increasing this value increases the number of file descriptors that mysqld requires.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">table_open_cache</code> 指的是缓存数据文件的描述符(Linux/Unix)相关信息</p>

<p>在 5.6 中的默认配置：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>performance_schema_max_table_instances 12500
table_definition_cache 1400
table_open_cache 2000
</code></pre></div></div>

<p><em>References:</em></p>

<ul>
  <li><a href="http://www.cnblogs.com/yum777/p/6554901.html">解决 Mysql 内存占用巨大问题</a></li>
  <li><a href="http://blog.csdn.net/wulantian/article/details/41119755">MySQL 5.6内存占用过高解决方案</a></li>
  <li><a href="http://bbs.csdn.net/topics/390724779">linux 下mysql内存占用过高</a></li>
</ul>]]></content><author><name></name></author><category term="Linux" /><category term="服务器" /><category term="Mysql" /><summary type="html"><![CDATA[前两天刚把服务器部署上，今天就出现了异常。在 App 上看是服务器直接宕机。原本以为仅仅是服务端挂了，在服务器上使用 ps aux | grep java 发现进程还在，只是不服务了。打开 log 发现 Java run out of memory，导致无法创建新的线程。 使用 top -o %MEM 查看，java 占用近 200M，mysql 占用近 500 M。因为是个人用的小服务器，只有 1G 内存，吃紧得很。既然 mysql 占用了最多的内存，就让它吐出一点好了。 一开始猜测是 InnoDB 缓冲区过大，不过在 /etc/mysql/my.cnf 中发现配置的缓存已经非常小了。后来在网上发现是因为 Mysql 5.6 版本默认 GA 配置过大，导致初始需要近 400M 空间。通过下面配置，直接讲内存降到 100M 以下： performance_schema_max_table_instances=400 table_definition_cache=400 table_open_cache=256 参数意义： performance_schema_max_table_instances The maximum number of instrumented table objects 检测的表对象的最大数目。 table_definition_cache The number of table definitions (from .frm files) that can be stored in the definition cache. If you use a large number of tables, you can create a large table definition cache to speed up opening of tables. The table definition cache takes less space and does not use file descriptors, unlike the normal table cache. The minimum and default values are both 400. 缓存 frm 文件 table_open_cache The number of open tables for all threads. Increasing this value increases the number of file descriptors that mysqld requires. table_open_cache 指的是缓存数据文件的描述符(Linux/Unix)相关信息 在 5.6 中的默认配置： performance_schema_max_table_instances 12500 table_definition_cache 1400 table_open_cache 2000 References: 解决 Mysql 内存占用巨大问题 MySQL 5.6内存占用过高解决方案 linux 下mysql内存占用过高]]></summary></entry><entry><title type="html">CSKS-(三)、设计模式</title><link href="/%E6%80%BB%E7%BB%93/2017/08/26/CSKS-%E4%B8%89-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" rel="alternate" type="text/html" title="CSKS-(三)、设计模式" /><published>2017-08-26T18:00:49+08:00</published><updated>2017-08-26T18:00:49+08:00</updated><id>/%E6%80%BB%E7%BB%93/2017/08/26/CSKS-%E4%B8%89-%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="/%E6%80%BB%E7%BB%93/2017/08/26/CSKS-%E4%B8%89-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"><![CDATA[<h1 id="面对对象原则">面对对象原则</h1>

<ul>
  <li>单一职责：不要存在多于一个导致类变更的原因；通俗的说，即一个类只负责一项职责；</li>
  <li>里氏替换：所有引用基类的地方必须能透明地使用其子类的对象；通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能；</li>
  <li>依赖倒置：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；</li>
  <li>接口隔离：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上；</li>
  <li>迪米特法则：一个对象应该对其他对象保持最少的了解；</li>
  <li>开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭；</li>
</ul>

<h1 id="23种设计模式">23种设计模式</h1>

<p><em>References</em></p>

<ul>
  <li>
    <p><a href="http://www.jianshu.com/p/dbc8a279165d">设计模式大总汇</a></p>
  </li>
  <li>单例模式：确保整个程序中只有一个实例，并自行实例化以向整个体统提供实例</li>
  <li>工厂方法模式：将实例的创建延迟到子类</li>
  <li>抽象工厂模式：为创建一组相互依赖的对象提供一个接口，并将创建过程延迟到子类</li>
  <li>建造者模式：将一个复杂对象的创建和表示分离开来，使得同一个创建过程可以得到不同的表示</li>
  <li>原型模式：</li>
  <li>迭代器模式：在不暴露内部实现的情况下，使客户可以遍历容器内部对象</li>
  <li>责任联模式：将对象连成一条链，并沿着这条链传递该请求，直到有对象处理该请求位置，解决了发送方和接收方的耦合</li>
  <li>桥梁模式：将抽象和实现解耦，使两者可以独立变化</li>
  <li>适配器模式：将一个对象的接口转换成另一个对象期待的接口，从而使原本不匹配的对象能在一起工作</li>
  <li>中介者模式：将一系列对象的交互封装起来，使其耦合松散，而且可以独立变化</li>
  <li>观察者模式：定义一种1-N的关系，使得当一个对象更新时，所有依赖它的对象都能收到通知并响应</li>
  <li>命令模式：将客户参数化，使得客户请求可以记录、排队，并能实现撤销，恢复等功能</li>
  <li>亨元模式：使用共享对象可以有效的支持大量细粒度的对象</li>
  <li>状态模式：当一个对象状态改变时改变其行为，使得对象看起来像是改变了类</li>
  <li>解释器模式：定义一组语言及其解释器</li>
  <li>访问者模式：定义一组接口，从而是现在不改变数据结构自身的情况下添加职责</li>
  <li>装饰器模式：动态的为一个对象添加一些额外的职责，比生成子类要简单</li>
  <li>代理模式：提供一种代理以控制对对象的访问</li>
  <li>策略模式：定义并封装一组可以互换的算法</li>
  <li>模板方法模式：定义一个算法的骨架，将一些具体步骤延迟到子类。使得子类可以不改变算法结构即重定义算法特定步骤</li>
  <li>组合模式：</li>
  <li>门面模式：</li>
  <li>备忘录模式：</li>
</ul>

<h2 id="单例模式">单例模式</h2>

<p>单例模式重点在两个方面：</p>

<ul>
  <li>系统只有一个实例；</li>
  <li>自行实例化并向整个系统提供这个实例；</li>
</ul>

<p>单例模式的实现上有两个重要的因素：</p>

<ul>
  <li>线程安全；</li>
  <li>延迟加载；</li>
</ul>

<p>延迟加载技术可以解耦依赖链与初始化顺序。如果单例在程序执行前就进行初始化，某一个单例的初始化过程中，又引用到了另一个单例，便出现了加载顺序的决议问题。而使用延迟加载技术将这种依赖过程与初始化顺序进行了自动决议。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">instance</span><span class="o">()</span> <span class="o">{</span>
  <span class="kd">static</span> <span class="nc">Singleston</span> <span class="o">*</span> <span class="n">sing</span> <span class="o">=</span> <span class="no">NULL</span><span class="o">;</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">sing</span> <span class="o">==</span> <span class="no">NULL</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sing</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleston</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">sing</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>线程安全方面则根据语言不同而有所差异，以 C++ 为例，C++11 标准规定了局部静态变量初始化的线程安全特性，所以写起来非常方便：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">instance</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="n">Class</span> <span class="n">ins</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">ins</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>按照这种写法不仅线程安全，同时还解决了依赖问题。如果不想用这种办法，也可以使用标准库提供的：<code class="language-plaintext highlighter-rouge">call_once()</code> 函数。</p>

<p>Java 在方面就要麻烦得多，我个人比较偏爱的是 DCL 这种方式：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleston</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="nc">Singleston</span> <span class="n">instance</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="kd">synchronized</span><span class="o">(</span><span class="nc">Singleston</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> 
        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleston</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
  <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p>Java 版本的 DCL 需要注意使用 <code class="language-plaintext highlighter-rouge">volatile</code> 修饰，从 1.5 版本开始这种写法已经不存在问题了。</p>

<h2 id="建造者模式">建造者模式</h2>

<p>建造者模式用于将一个复杂对象的建造过程和表示过程分开。这种比较适合一旦创建好后不会怎么更改的对象。在 Android 中的 <code class="language-plaintext highlighter-rouge">AlertDialg</code> 就使用这种方式：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">dialog</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">new</span> <span class="nf">Builder</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
      <span class="o">.</span><span class="na">setMessage</span><span class="o">(</span><span class="s">"are you sure?"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">setTitle</span><span class="o">(</span><span class="s">"tips"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">setPositiveButtion</span><span class="o">(</span><span class="s">"yes"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">OnClickListener</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="nc">DialogInterface</span> <span class="n">dialog</span><span class="o">,</span> <span class="kt">int</span> <span class="n">which</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">dialog</span><span class="o">.</span><span class="na">dismiss</span><span class="o">();</span>
          <span class="nc">Main</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">finish</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">})</span>
      <span class="o">.</span><span class="na">setNegativeButton</span><span class="o">(</span><span class="s">"No"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">OnClickListener</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="nc">DialogInterface</span> <span class="n">dialog</span><span class="o">,</span> <span class="kt">int</span> <span class="n">which</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">dialog</span><span class="o">.</span><span class="na">dismiss</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">})</span>
      <span class="o">.</span><span class="na">create</span><span class="o">()</span>
      <span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>无独有偶，在 Java 著名网络库 Netty 中，创建 <code class="language-plaintext highlighter-rouge">Channel</code> 也是使用建造者模式：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Bootstrap</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Bootstrap</span><span class="o">();</span>  
<span class="n">b</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="n">group</span><span class="o">)</span>  
    <span class="o">.</span><span class="na">channel</span><span class="o">(</span><span class="nc">NioSocketChannel</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>  
    <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="nc">ChannelOption</span><span class="o">.</span><span class="na">TCP_NODELAY</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>  
    <span class="o">.</span><span class="na">handler</span><span class="o">(</span><span class="k">new</span> <span class="nc">ChannelInitializer</span><span class="o">&lt;</span><span class="nc">SocketChannel</span><span class="o">&gt;()</span> <span class="o">{</span>  
        <span class="nd">@Override</span>  
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initChannel</span><span class="o">(</span><span class="nc">SocketChannel</span> <span class="n">ch</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>  
          <span class="c1">// ...</span>
        <span class="o">}</span>  
    <span class="o">});</span>  

<span class="nc">ChannelFuture</span> <span class="n">f</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">).</span><span class="na">sync</span><span class="o">();</span>  
</code></pre></div></div>

<h2 id="迭代器模式">迭代器模式</h2>

<p>容器需要提供用户一个访问机制，而又不暴露内部细节，这种方法就叫迭代器模式。C++ 和 Java 中均有迭代器模式的影子：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C++</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">arrays</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

<span class="c1">// Java</span>
<span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">arrays</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">.</span><span class="n">iterator</span><span class="p">();</span>
<span class="k">while</span> <span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">hasNext</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="责任链模式">责任链模式</h2>

<p>如其名，整个处理过程就像链一样，一级一级传递下去，从而接触了发送方和接收方的耦合。责任链模式常见于各种事件处理机制，比如 Android 的事件处理机制、Win32 中的消息机制。责任链模式的显著特点是如果一个事件（消息）在当前处理逻辑中不处理，就将其传递给下一级处理逻辑。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">slove</span><span class="p">(</span><span class="n">Message</span> <span class="n">msg</span><span class="p">,</span> <span class="n">Handler</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">xxx</span><span class="p">:</span> <span class="p">...;</span> <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span> <span class="n">handle</span><span class="p">.</span><span class="n">slove</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="桥梁模式">桥梁模式</h2>

<p>将抽象和实现解耦的就是桥梁模式。通常在设计时，不要传播设计，而桥梁模式正好可以处理。比如一开始只有一台实验仪器，所以用单例模式来表示，某一天实验室又购进了一台新的仪器，那么之前所有引用单例的代码都要修改。而设计时如果将获取设备接口和单例分开，就没有这么多麻烦了：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Device</span> <span class="p">{</span>
  
  <span class="k">private</span> <span class="k">class</span> <span class="nc">SingleDevice</span> <span class="p">{</span>
    <span class="c1">// singleston </span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="k">static</span> <span class="n">Device</span> <span class="n">getByRandom</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">SingleDevice</span><span class="p">.</span><span class="n">getInstance</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>桥梁模式的另一个常见用途在 C++ 中，常用于实现减少 C++ 头文件编译负担：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a.h 中</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">AImpl</span><span class="p">;</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="k">do</span><span class="p">();</span>

<span class="nl">private:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">AImpl</span><span class="o">&gt;</span> <span class="n">impl</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// A.cpp 中</span>
<span class="k">class</span> <span class="nc">A</span><span class="o">::</span><span class="n">AImpl</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="k">do</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="k">do</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="k">do</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="适配器模式">适配器模式</h2>

<p>适配器模式可以使两个不兼容的接口一起工作，有 Andoird 开发经验的一定对 Adaptor 非常熟悉，这里不细讲。</p>

<h2 id="中介者模式">中介者模式</h2>

<p>中介者模式把两个独立对象的一系列操作封装起来，把这两个对象之间的联系解耦，这样两个对象不依赖对方，可以独立变化。</p>

<h2 id="观察者模式">观察者模式</h2>

<p>解耦操作最好的还属观察者模式。观察者模式重新定义了对象之间的依赖关系，将原有的监听操作转变为通知操作。</p>

<p>关于使用观察者模式，比较典型的例子是控件事件的监听–在指定控件上绑定一个回调函数，事件发生的时候，控件负责调用该函数通知用户。在 Java 中大名鼎鼎的响应式库 RxJava 就是以观察者模式为基础，还解决了长期以来困扰的 Callback hell 问题。Vue.js 中实现数据绑定也是以观察者模式为基础的。</p>

<h2 id="命令模式">命令模式</h2>

<p>命令模式最重要的一点就是将客户端的请求参数化，从而实现请求排队、记录回滚等。在游戏中，命令模式可以将用户对角色控制的输入进行参数化，实现死亡回放等。在服务器开发中，将客户端的请求参数化，并放入请求队列，实现流量控制。</p>

<h2 id="状态模式">状态模式</h2>

<p>说到命令模式不得不提状态模式，以任务操纵为例，人在地面上可以进行跳跃，而在跳跃的过程中则不可以。那么对于相同的命令，在不同的状态下有不同的响应，这就是状态模式。状态模式可以在改变对象状态的同时改变对象的行为。</p>

<h2 id="享元模式">享元模式</h2>

<p>游戏中地图大量元素存在重复的情况，大量创建相同的对象非常浪费内存，此时可以创建几个单例，让地图引用具体的单例，这就是享元模式。</p>

<h2 id="解释器模式">解释器模式</h2>

<p>现在很多游戏的基本框架由 C/C++ 来写，具体业务逻辑则交给 lua 之类的脚本处理。如果是自己设计的脚本，那么就需要写出对应的解释器：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Expr</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Value</span> <span class="n">execute</span><span class="p">();</span>

<span class="nl">private:</span> 
  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">Expr</span> <span class="o">*</span> <span class="n">left</span><span class="p">,</span> <span class="o">*</span> <span class="n">right</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// 解释器模式</span>
</code></pre></div></div>

<h2 id="访问者模式">访问者模式</h2>

<p>一开始我们只提供了游戏脚本解释器的解释功能，某次调试的时候希望将具体的抽象语法书打印出来，所以在每个元素类中添加了打印支持：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Expr</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Value</span> <span class="n">execute</span><span class="p">();</span>
  <span class="n">Value</span> <span class="n">dump</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">left</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="p">;</span>
    <span class="n">right</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">();</span>
  <span class="p">}</span>

<span class="nl">private:</span> 
  <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">Expr</span> <span class="o">*</span> <span class="n">left</span><span class="p">,</span> <span class="o">*</span> <span class="n">right</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>每当出现一个新的需求时，都要对原有的数据结构进行修改。而访问者模式为我们提供了遍历，可以在不修改数据结构的同时增加数据结构上的操作。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Visitor</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Expr</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Value</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Visitable</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">Visitor</span> <span class="o">*</span><span class="n">visitor</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">//...</span>
<span class="k">class</span> <span class="nc">Expr</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Visitable</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">Visitor</span> <span class="o">*</span><span class="n">visitor</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">visit</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Dump</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Visitor</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Value</span> <span class="o">*</span> <span class="n">v</span><span class="p">);</span>

  <span class="kt">void</span> <span class="n">visit</span><span class="p">(</span><span class="n">Expr</span> <span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">e</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">;</span>
    <span class="n">e</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="装饰器模式">装饰器模式</h2>

<p>装饰器模式可以在不继承对象的同时给对象增加操作。Python 中有一个装饰器的概念，比如我们要给原来的函数添加上调用记录到日志的功能：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'call %s():'</span> <span class="o">%</span> <span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="o">@</span><span class="n">log</span>
<span class="k">def</span> <span class="nf">do</span><span class="p">():</span>
  <span class="k">pass</span>
</code></pre></div></div>

<p>与之类似的还有 Java 提供的注解功能，这里不展开。</p>

<h2 id="代理模式">代理模式</h2>

<p>说到代理，常见有 VPN、HTTP Proxy ，代理模式用于控制对对象的访问。比如实现一个 RPC 功能，在客户端定义一个接口，由代理服务生成接口对应的实例。客户在调用接口时，代理服务监测并将请求转发给服务器，等到服务端计算完成并返回时，代理服务把结果返回给客户端。从客户端的角度上，这个过程和调用一个耗时的函数没有区别。</p>]]></content><author><name></name></author><category term="总结" /><summary type="html"><![CDATA[面对对象原则 单一职责：不要存在多于一个导致类变更的原因；通俗的说，即一个类只负责一项职责； 里氏替换：所有引用基类的地方必须能透明地使用其子类的对象；通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能； 依赖倒置：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象； 接口隔离：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上； 迪米特法则：一个对象应该对其他对象保持最少的了解； 开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭； 23种设计模式 References 设计模式大总汇 单例模式：确保整个程序中只有一个实例，并自行实例化以向整个体统提供实例 工厂方法模式：将实例的创建延迟到子类 抽象工厂模式：为创建一组相互依赖的对象提供一个接口，并将创建过程延迟到子类 建造者模式：将一个复杂对象的创建和表示分离开来，使得同一个创建过程可以得到不同的表示 原型模式： 迭代器模式：在不暴露内部实现的情况下，使客户可以遍历容器内部对象 责任联模式：将对象连成一条链，并沿着这条链传递该请求，直到有对象处理该请求位置，解决了发送方和接收方的耦合 桥梁模式：将抽象和实现解耦，使两者可以独立变化 适配器模式：将一个对象的接口转换成另一个对象期待的接口，从而使原本不匹配的对象能在一起工作 中介者模式：将一系列对象的交互封装起来，使其耦合松散，而且可以独立变化 观察者模式：定义一种1-N的关系，使得当一个对象更新时，所有依赖它的对象都能收到通知并响应 命令模式：将客户参数化，使得客户请求可以记录、排队，并能实现撤销，恢复等功能 亨元模式：使用共享对象可以有效的支持大量细粒度的对象 状态模式：当一个对象状态改变时改变其行为，使得对象看起来像是改变了类 解释器模式：定义一组语言及其解释器 访问者模式：定义一组接口，从而是现在不改变数据结构自身的情况下添加职责 装饰器模式：动态的为一个对象添加一些额外的职责，比生成子类要简单 代理模式：提供一种代理以控制对对象的访问 策略模式：定义并封装一组可以互换的算法 模板方法模式：定义一个算法的骨架，将一些具体步骤延迟到子类。使得子类可以不改变算法结构即重定义算法特定步骤 组合模式： 门面模式： 备忘录模式： 单例模式 单例模式重点在两个方面： 系统只有一个实例； 自行实例化并向整个系统提供这个实例； 单例模式的实现上有两个重要的因素： 线程安全； 延迟加载； 延迟加载技术可以解耦依赖链与初始化顺序。如果单例在程序执行前就进行初始化，某一个单例的初始化过程中，又引用到了另一个单例，便出现了加载顺序的决议问题。而使用延迟加载技术将这种依赖过程与初始化顺序进行了自动决议。 void instance() { static Singleston * sing = NULL; if (sing == NULL) { sing = new Singleston; } return sing; } 线程安全方面则根据语言不同而有所差异，以 C++ 为例，C++11 标准规定了局部静态变量初始化的线程安全特性，所以写起来非常方便： void instance() { static Class ins; return ins; } 按照这种写法不仅线程安全，同时还解决了依赖问题。如果不想用这种办法，也可以使用标准库提供的：call_once() 函数。 Java 在方面就要麻烦得多，我个人比较偏爱的是 DCL 这种方式： public class Singleston { private static volatile Singleston instance; public static getInstance() { if (instance == null) synchronized(Singleston.class) { if (instance == null) instance = new Singleston; } return instance; } } Java 版本的 DCL 需要注意使用 volatile 修饰，从 1.5 版本开始这种写法已经不存在问题了。 建造者模式 建造者模式用于将一个复杂对象的建造过程和表示过程分开。这种比较适合一旦创建好后不会怎么更改的对象。在 Android 中的 AlertDialg 就使用这种方式： protected void dialog() { new Builder(this) .setMessage("are you sure?") .setTitle("tips") .setPositiveButtion("yes", new OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); Main.this.finish(); } }) .setNegativeButton("No", new OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }) .create() .show(); } 无独有偶，在 Java 著名网络库 Netty 中，创建 Channel 也是使用建造者模式： Bootstrap b = new Bootstrap(); b.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override public void initChannel(SocketChannel ch) throws Exception { // ... } }); ChannelFuture f = b.connect(host, port).sync(); 迭代器模式 容器需要提供用户一个访问机制，而又不暴露内部细节，这种方法就叫迭代器模式。C++ 和 Java 中均有迭代器模式的影子： // C++ vector&lt;int&gt; arrays; // ... auto it = arrays.begin(); // Java ArrayList&lt;Integer&gt; arrays = new ArrayList&lt;Integer&gt;(); // ... Iterator&lt;Integer&gt; it = arrays.iterator(); while (it.hasNext()) { ... } 责任链模式 如其名，整个处理过程就像链一样，一级一级传递下去，从而接触了发送方和接收方的耦合。责任链模式常见于各种事件处理机制，比如 Android 的事件处理机制、Win32 中的消息机制。责任链模式的显著特点是如果一个事件（消息）在当前处理逻辑中不处理，就将其传递给下一级处理逻辑。 void slove(Message msg, Handler handle) { switch (msg) { case xxx: ...; break; default: handle.slove(msg); } } 桥梁模式 将抽象和实现解耦的就是桥梁模式。通常在设计时，不要传播设计，而桥梁模式正好可以处理。比如一开始只有一台实验仪器，所以用单例模式来表示，某一天实验室又购进了一台新的仪器，那么之前所有引用单例的代码都要修改。而设计时如果将获取设备接口和单例分开，就没有这么多麻烦了： public class Device { private class SingleDevice { // singleston } public static Device getByRandom() { return SingleDevice.getInstance(); } } 桥梁模式的另一个常见用途在 C++ 中，常用于实现减少 C++ 头文件编译负担： // a.h 中 class A { class AImpl; public: void do(); private: std::shared_ptr&lt;AImpl&gt; impl; }; // A.cpp 中 class A::AImpl { public: void do() { ... } }; void A::do() { impl-&gt;do(); } 适配器模式 适配器模式可以使两个不兼容的接口一起工作，有 Andoird 开发经验的一定对 Adaptor 非常熟悉，这里不细讲。 中介者模式 中介者模式把两个独立对象的一系列操作封装起来，把这两个对象之间的联系解耦，这样两个对象不依赖对方，可以独立变化。 观察者模式 解耦操作最好的还属观察者模式。观察者模式重新定义了对象之间的依赖关系，将原有的监听操作转变为通知操作。 关于使用观察者模式，比较典型的例子是控件事件的监听–在指定控件上绑定一个回调函数，事件发生的时候，控件负责调用该函数通知用户。在 Java 中大名鼎鼎的响应式库 RxJava 就是以观察者模式为基础，还解决了长期以来困扰的 Callback hell 问题。Vue.js 中实现数据绑定也是以观察者模式为基础的。 命令模式 命令模式最重要的一点就是将客户端的请求参数化，从而实现请求排队、记录回滚等。在游戏中，命令模式可以将用户对角色控制的输入进行参数化，实现死亡回放等。在服务器开发中，将客户端的请求参数化，并放入请求队列，实现流量控制。 状态模式 说到命令模式不得不提状态模式，以任务操纵为例，人在地面上可以进行跳跃，而在跳跃的过程中则不可以。那么对于相同的命令，在不同的状态下有不同的响应，这就是状态模式。状态模式可以在改变对象状态的同时改变对象的行为。 享元模式 游戏中地图大量元素存在重复的情况，大量创建相同的对象非常浪费内存，此时可以创建几个单例，让地图引用具体的单例，这就是享元模式。 解释器模式 现在很多游戏的基本框架由 C/C++ 来写，具体业务逻辑则交给 lua 之类的脚本处理。如果是自己设计的脚本，那么就需要写出对应的解释器： class Expr { public: Value execute(); private: char c; Expr * left, * right; }; // 解释器模式 访问者模式 一开始我们只提供了游戏脚本解释器的解释功能，某次调试的时候希望将具体的抽象语法书打印出来，所以在每个元素类中添加了打印支持： class Expr { public: Value execute(); Value dump() { left-&gt;dump(); cout &lt;&lt; c ; right-&gt;dump(); } private: char c; Expr * left, * right; }; 每当出现一个新的需求时，都要对原有的数据结构进行修改。而访问者模式为我们提供了遍历，可以在不修改数据结构的同时增加数据结构上的操作。 class Visitor { public: virtual void visit(Expr *ptr); virtual void visit(Value *ptr); }; class Visitable { public: virtual void accept(Visitor *visitor); }; //... class Expr : public Visitable { public: void accept(Visitor *visitor) { visitor-&gt;visit(this); } }; class Dump : public Visitor { public: void visit(Value * v); void visit(Expr * e) { e-&gt;left-&gt;accept(this); cout &lt;&lt; e-&gt;c; e-&gt;right-&gt;accept(this); } }; 装饰器模式 装饰器模式可以在不继承对象的同时给对象增加操作。Python 中有一个装饰器的概念，比如我们要给原来的函数添加上调用记录到日志的功能： def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper @log def do(): pass 与之类似的还有 Java 提供的注解功能，这里不展开。 代理模式 说到代理，常见有 VPN、HTTP Proxy ，代理模式用于控制对对象的访问。比如实现一个 RPC 功能，在客户端定义一个接口，由代理服务生成接口对应的实例。客户在调用接口时，代理服务监测并将请求转发给服务器，等到服务端计算完成并返回时，代理服务把结果返回给客户端。从客户端的角度上，这个过程和调用一个耗时的函数没有区别。]]></summary></entry></feed>